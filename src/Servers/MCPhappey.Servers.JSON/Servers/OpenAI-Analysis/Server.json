{
  "serverInfo": {
    "name": "OpenAI-Analysis",
    "version": "1.0.0"
  },
  "instructions": "Compose queries in this exact pipeline (omit any stages you do not need): ➊ **compute** → ➋ **filter** → ➌ **groupBy** → ➍ **aggregate** → ➎ *optional* **topKPerGroup** → ➏ *optional* **having** → ➐ **sort** → ➑ **limit** → ➒ **select**.\n\n• **compute** *(per‑row stage, JSON object)* – adds or transforms columns before filtering or grouping. Keys are aliases, values are expressions that support all row operators: $toLower, $substr, $concat, $toNumber, $toDate, $add/$sub/$mul/$divide, $abs, $dateDiffDays, etc. *Example*: \"compute\": { \"Year\": { \"$substr\": [\"InvoiceDate\", 0, 4] }, \"Net\": { \"$sub\": [\"Gross\", \"Discount\"] } }.\n\n• **filter** – same predicate dialect as having (see below).\n\n• **groupBy** – array of column names; prefix with \"~\" to case‑fold ({ \"$toLower\": \"Col\" }).\n\n• **aggregate / aggregateJson** – use **shorthand** [\"alias:op:Col\"] for the six primitives (count, countDistinct, sum, avg, min, max). For everything else—math, $countIf, converters, date logic—use **aggregateJson** (alias‑first objects). Supported operators: {$count:true}, {$countDistinct:\"Col\"}, {$countIf:{<predicate>}}, {$sum:\"Col\"|rowExpr}, {$avg:\"Col\"|rowExpr}, {$min:\"Col\"|rowExpr}, {$max:\"Col\"|rowExpr}, arithmetic {$add:[…]}, {$sub:[A,B]} (alias {$subtract:…}), {$mul:[…]}, {$divide:[A,B]}, {$abs:expr}, converters {$toNumber:expr}, {$toDate:expr}, dates {$dateDiffDays:[A,B]}. **Numeric tip:** any *single* unparsable value (\"\", \"n/a\", \"‑\", etc.) downgrades the whole metric to string sorting; always wrap input with {$toNumber:\"Col\"} and aggregate on that alias to guarantee numeric behaviour.\n\n• **topKPerGroup** – \"metricAlias:order:k\" (order asc|desc). Works when grouping on ≥1 key; keeps the best *k* rows within each super‑group (all keys except the last).\n\n• **having** – post‑aggregate filter using **the exact same predicate dialect** as filter (field predicates, $or/$and/$not, regex, numeric comparators, $isTrue/$isFalse). Evaluates on aggregated rows, so you may reference metric aliases as fields.\n\n• **sort** – \"field:asc|desc|1|-1\" on group keys or metric aliases. The engine treats a column as numeric **only if every non‑empty value parses successfully**; otherwise it falls back to lexicographic order. Therefore, if any row may contain blanks, dashes or text, create a clean numeric alias with $toNumber and sort on that alias.\n\n• **limit** – integer applied after sort.\n\n• **select** – JSON object with optional sub‑properties:\n  – **include**: [\"FieldA\",\"MetricB\"],\n  – **rename**: {\"from\":\"to\"},\n  – **expressions**: per‑row expressions (same operators as compute) computed *after* aggregation, e.g. \"cityLower\": { \"$toLower\": \"City\" },\n  – **excludeNulls**: true. Use **limitFields** outside select for the lightest raw‑row extractions.\n\n• **Global aggregates** (no groupBy) return a single row; set includeGroupKeys:false to omit the implicit group keys.\n\n• **Null / empty handling** – never output parameters with null, empty array, or empty object. Compact result size with selectExcludeNulls and compactNulls.\n\n• **Predicate cheatsheet** (for **filter**, **having**, and **$countIf**): field predicates {\"Status\":{\"$eqi\":\"Open\"}}, {\"Amount\":{\"$gt\":1000}}, {\"Date\":{\"$gte\":\"2025-01-01\",\"$lt\":\"2026-01-01\"}}, {\"Ref\":{\"$regex\":\"pat\",\"$options\":\"i\"}}, {\"Flag\":{\"$isTrue\":true}}; logic {\"$or\":[…]}, {\"$and\":[…]}, {\"$not\":{…}}. Binary expression comparators for $countIf: {\"$lt\":[{\"$toNumber\":\"Invoiced\"},{\"$toNumber\":\"Spent\"}]}. \n\n• **Examples**\n(1) *Global row count* → filter:{\"Name\":{\"$regexi\":\"alpha\"}} compute:{} groupBy:[] aggregate:{\"rows\":{\"$count\":true}} select.include:[\"rows\"].\n(2) *Sum & max per Customer* → compute:{} groupBy:[\"Customer\"] aggregate:{\"total\":{\"$sum\":{\"$toNumber\":\"Amount\"}},\"peak\":{\"$max\":{\"$toNumber\":\"Amount\"}}} sort:{\"total\":\"desc\"}.\n(3) *Count negative mismatches* → groupBy:[\"Customer\"] aggregate:{\"items\":{\"$count\":true},\"neg\":{\"$countIf\":{\"$lt\":[{\"$toNumber\":\"Invoiced\"},{\"$toNumber\":\"Spent\"}]}}} sort:{\"neg\":\"desc\",\"items\":\"desc\"}.\n(4) *Earliest start by Customer × Manager in 2025* → filter:{\"StartDate\":{\"$gte\":\"2025-01-01\",\"$lt\":\"2026-01-01\"}} groupBy:[\"Customer\",\"Manager\"] aggregate:{\"firstStart\":{\"$min\":{\"$toDate\":\"StartDate\"}}} sort:{\"firstStart\":\"asc\"}.\n(5) *Duration stats* → filter:{\"Status\":{\"$in\":[\"Completed\",\"Closed\"]},\"StartDate\":{\"$ne\":\"\"},\"EndDate\":{\"$ne\":\"\"}} groupBy:[\"Type\",\"Customer\"] aggregate:{\"avgDays\":{\"$avg\":{\"$dateDiffDays\":[{\"$toDate\":\"EndDate\"},{\"$toDate\":\"StartDate\"}]}},\"maxDays\":{\"$max\":{\"$dateDiffDays\":[{\"$toDate\":\"EndDate\"},{\"$toDate\":\"StartDate\"}]}},\"count\":{\"$count\":true}} sort:{\"avgDays\":\"desc\"}.\n\n• **Pitfalls to avoid**: empty aggregate objects (always choose an operator); sending null / empty parameters; sorting on raw string dates or numbers; regex‑matching years instead of range predicates; duplicating heavy predicates in both filter and $countIf (filter gates rows first; $countIf is conditional tally within the group).",
  "plugins": [
    "MCPhappey.Tools.OpenAI.Analysis.OpenAIAnalysis, MCPhappey.Tools"
  ],
  "obo": {
    "graph.microsoft.com": "https://graph.microsoft.com/User.Read https://graph.microsoft.com/Files.ReadWrite"
  }
}
