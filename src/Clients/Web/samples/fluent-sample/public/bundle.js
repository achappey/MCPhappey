"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // <define:__DEFAULT_MCP_SERVER_LIST_URLS__>
  var define_DEFAULT_MCP_SERVER_LIST_URLS_default;
  var init_define_DEFAULT_MCP_SERVER_LIST_URLS = __esm({
    "<define:__DEFAULT_MCP_SERVER_LIST_URLS__>"() {
      define_DEFAULT_MCP_SERVER_LIST_URLS_default = ["http://localhost:3001/mcp.json"];
    }
  });

  // ../../node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "../../node_modules/react/cjs/react.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var l = Symbol.for("react.element");
      var n = Symbol.for("react.portal");
      var p = Symbol.for("react.fragment");
      var q = Symbol.for("react.strict_mode");
      var r = Symbol.for("react.profiler");
      var t = Symbol.for("react.provider");
      var u = Symbol.for("react.context");
      var v = Symbol.for("react.forward_ref");
      var w = Symbol.for("react.suspense");
      var x = Symbol.for("react.memo");
      var y = Symbol.for("react.lazy");
      var z = Symbol.iterator;
      function A(a) {
        if (null === a || "object" !== typeof a) return null;
        a = z && a[z] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var C = Object.assign;
      var D = {};
      function E(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      E.prototype.isReactComponent = {};
      E.prototype.setState = function(a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      E.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function F() {
      }
      F.prototype = E.prototype;
      function G(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      var H = G.prototype = new F();
      H.constructor = G;
      C(H, E.prototype);
      H.isPureReactComponent = true;
      var I = Array.isArray;
      var J = Object.prototype.hasOwnProperty;
      var K = { current: null };
      var L = { key: true, ref: true, __self: true, __source: true };
      function M(a, b, e) {
        var d, c = {}, k = null, h = null;
        if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
        var g = arguments.length - 2;
        if (1 === g) c.children = e;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
          c.children = f;
        }
        if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
        return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
      }
      function N(a, b) {
        return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
      }
      function O(a) {
        return "object" === typeof a && null !== a && a.$$typeof === l;
      }
      function escape(a) {
        var b = { "=": "=0", ":": "=2" };
        return "$" + a.replace(/[=:]/g, function(a2) {
          return b[a2];
        });
      }
      var P = /\/+/g;
      function Q(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
      }
      function R(a, b, e, d, c) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k) a = null;
        var h = false;
        if (null === a) h = true;
        else switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
        if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
        h = 0;
        d = "" === d ? "." : d + ":";
        if (I(a)) for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
        else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
        else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
        return h;
      }
      function S(a, b, e) {
        if (null == a) return a;
        var d = [], c = 0;
        R(a, d, "", "", function(a2) {
          return b.call(e, a2, c++);
        });
        return d;
      }
      function T(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          b.then(function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
          }, function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
          });
          -1 === a._status && (a._status = 0, a._result = b);
        }
        if (1 === a._status) return a._result.default;
        throw a._result;
      }
      var U = { current: null };
      var V = { transition: null };
      var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
      function X() {
        throw Error("act(...) is not supported in production builds of React.");
      }
      exports.Children = { map: S, forEach: function(a, b, e) {
        S(a, function() {
          b.apply(this, arguments);
        }, e);
      }, count: function(a) {
        var b = 0;
        S(a, function() {
          b++;
        });
        return b;
      }, toArray: function(a) {
        return S(a, function(a2) {
          return a2;
        }) || [];
      }, only: function(a) {
        if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
        return a;
      } };
      exports.Component = E;
      exports.Fragment = p;
      exports.Profiler = r;
      exports.PureComponent = G;
      exports.StrictMode = q;
      exports.Suspense = w;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
      exports.act = X;
      exports.cloneElement = function(a, b, e) {
        if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
        var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
        if (null != b) {
          void 0 !== b.ref && (k = b.ref, h = K.current);
          void 0 !== b.key && (c = "" + b.key);
          if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
          for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f) d.children = e;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
          d.children = g;
        }
        return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
      };
      exports.createContext = function(a) {
        a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a.Provider = { $$typeof: t, _context: a };
        return a.Consumer = a;
      };
      exports.createElement = M;
      exports.createFactory = function(a) {
        var b = M.bind(null, a);
        b.type = a;
        return b;
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(a) {
        return { $$typeof: v, render: a };
      };
      exports.isValidElement = O;
      exports.lazy = function(a) {
        return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
      };
      exports.memo = function(a, b) {
        return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
      };
      exports.startTransition = function(a) {
        var b = V.transition;
        V.transition = {};
        try {
          a();
        } finally {
          V.transition = b;
        }
      };
      exports.unstable_act = X;
      exports.useCallback = function(a, b) {
        return U.current.useCallback(a, b);
      };
      exports.useContext = function(a) {
        return U.current.useContext(a);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(a) {
        return U.current.useDeferredValue(a);
      };
      exports.useEffect = function(a, b) {
        return U.current.useEffect(a, b);
      };
      exports.useId = function() {
        return U.current.useId();
      };
      exports.useImperativeHandle = function(a, b, e) {
        return U.current.useImperativeHandle(a, b, e);
      };
      exports.useInsertionEffect = function(a, b) {
        return U.current.useInsertionEffect(a, b);
      };
      exports.useLayoutEffect = function(a, b) {
        return U.current.useLayoutEffect(a, b);
      };
      exports.useMemo = function(a, b) {
        return U.current.useMemo(a, b);
      };
      exports.useReducer = function(a, b, e) {
        return U.current.useReducer(a, b, e);
      };
      exports.useRef = function(a) {
        return U.current.useRef(a);
      };
      exports.useState = function(a) {
        return U.current.useState(a);
      };
      exports.useSyncExternalStore = function(a, b, e) {
        return U.current.useSyncExternalStore(a, b, e);
      };
      exports.useTransition = function() {
        return U.current.useTransition();
      };
      exports.version = "18.3.1";
    }
  });

  // ../../node_modules/react/index.js
  var require_react = __commonJS({
    "../../node_modules/react/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      if (true) {
        module.exports = require_react_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/react-dom/node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "../../node_modules/react-dom/node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a: for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
          else break a;
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length) return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
            else break a;
          }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l = performance;
        exports.unstable_now = function() {
          return l.now();
        };
      } else {
        p = Date, q = p.now();
        exports.unstable_now = function() {
          return p.now() - q;
        };
      }
      var l;
      var p;
      var q;
      var r = [];
      var t = [];
      var u = 1;
      var v = null;
      var y = 3;
      var z = false;
      var A = false;
      var B = false;
      var D = "function" === typeof setTimeout ? setTimeout : null;
      var E = "function" === typeof clearTimeout ? clearTimeout : null;
      var F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
          else break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A) if (null !== h(r)) A = true, I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L), L = -1);
        z = true;
        var c = y;
        try {
          G(b);
          for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r) && k(r);
              G(b);
            } else k(r);
            v = h(r);
          }
          if (null !== v) var w = true;
          else {
            var m = h(t);
            null !== m && K(H, m.startTime - b);
            w = false;
          }
          return w;
        } finally {
          v = null, y = c, z = false;
        }
      }
      var N = false;
      var O = null;
      var L = -1;
      var P = 5;
      var Q = -1;
      function M() {
        return exports.unstable_now() - Q < P ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports.unstable_now();
          Q = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else N = false;
      }
      var S;
      if ("function" === typeof F) S = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else S = function() {
        D(R, 0);
      };
      var T;
      var U;
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K(a, b) {
        L = D(function() {
          a(exports.unstable_now());
        }, b);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A || z || (A = true, I(J));
      };
      exports.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h(r);
      };
      exports.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports.unstable_scheduleCallback = function(a, b, c) {
        var d = exports.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
        return a;
      };
      exports.unstable_shouldYield = M;
      exports.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    }
  });

  // ../../node_modules/react-dom/node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "../../node_modules/react-dom/node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      if (true) {
        module.exports = require_scheduler_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "../../node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var aa = require_react();
      var ca = require_scheduler();
      function p(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set();
      var ea = {};
      function fa(a, b) {
        ha(a, b);
        ha(a + "Capture", b);
      }
      function ha(a, b) {
        ea[a] = b;
        for (a = 0; a < b.length; a++) da.add(b[a]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ja = Object.prototype.hasOwnProperty;
      var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var la = {};
      var ma = {};
      function oa(a) {
        if (ja.call(ma, a)) return true;
        if (ja.call(la, a)) return false;
        if (ka.test(a)) return ma[a] = true;
        la[a] = true;
        return false;
      }
      function pa(a, b, c, d) {
        if (null !== c && 0 === c.type) return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d) return false;
            if (null !== c) return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function qa(a, b, c, d) {
        if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
        if (d) return false;
        if (null !== c) switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
        return false;
      }
      function v(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var z = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        z[a] = new v(a, 0, false, a, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
        var b = a[0];
        z[b] = new v(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
        z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
        z[a] = new v(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a) {
        z[a] = new v(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function(a) {
        z[a] = new v(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a) {
        z[a] = new v(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a) {
        z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(
          ra,
          sa
        );
        z[b] = new v(b, 1, false, a, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
      });
      z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function ta(a, b, c, d) {
        var e = z.hasOwnProperty(b) ? z[b] : null;
        if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var va = Symbol.for("react.element");
      var wa = Symbol.for("react.portal");
      var ya = Symbol.for("react.fragment");
      var za = Symbol.for("react.strict_mode");
      var Aa = Symbol.for("react.profiler");
      var Ba = Symbol.for("react.provider");
      var Ca = Symbol.for("react.context");
      var Da = Symbol.for("react.forward_ref");
      var Ea = Symbol.for("react.suspense");
      var Fa = Symbol.for("react.suspense_list");
      var Ga = Symbol.for("react.memo");
      var Ha = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      Symbol.for("react.debug_trace_mode");
      var Ia = Symbol.for("react.offscreen");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.cache");
      Symbol.for("react.tracing_marker");
      var Ja = Symbol.iterator;
      function Ka(a) {
        if (null === a || "object" !== typeof a) return null;
        a = Ja && a[Ja] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var A = Object.assign;
      var La;
      function Ma(a) {
        if (void 0 === La) try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
        return "\n" + La + a;
      }
      var Na = false;
      function Oa(a, b) {
        if (!a || Na) return "";
        Na = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b) if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && "string" === typeof l.stack) {
            for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
            for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
              if (1 !== g || 1 !== h) {
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  }
                while (1 <= g && 0 <= h);
              }
              break;
            }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
      }
      function Pa(a) {
        switch (a.tag) {
          case 5:
            return Ma(a.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = Oa(a.type, false), a;
          case 11:
            return a = Oa(a.type.render, false), a;
          case 1:
            return a = Oa(a.type, true), a;
          default:
            return "";
        }
      }
      function Qa(a) {
        if (null == a) return null;
        if ("function" === typeof a) return a.displayName || a.name || null;
        if ("string" === typeof a) return a;
        switch (a) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a) switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload;
            a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {
            }
        }
        return null;
      }
      function Ra(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b);
          case 8:
            return b === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b) return b.displayName || b.name || null;
            if ("string" === typeof b) return b;
        }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a;
          case "object":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
          var e = c.get, f = c.set;
          Object.defineProperty(a, b, { configurable: true, get: function() {
            return e.call(this);
          }, set: function(a2) {
            d = "" + a2;
            f.call(this, a2);
          } });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return { getValue: function() {
            return d;
          }, setValue: function(a2) {
            d = "" + a2;
          }, stopTracking: function() {
            a._valueTracker = null;
            delete a[b];
          } };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a) return false;
        var b = a._valueTracker;
        if (!b) return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a) return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
      }
      function ab(a, b) {
        b = b.checked;
        null != b && ta(a, "checked", b, false);
      }
      function bb(a, b) {
        ab(a, b);
        var c = Sa(b.value), d = b.type;
        if (null != c) if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
        } else a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
      }
      function db(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function cb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      var eb = Array.isArray;
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
        return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b) throw Error(p(92));
            if (eb(c)) {
              if (1 < c.length) throw Error(p(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value), d = Sa(b.defaultValue);
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
      }
      function kb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
      }
      var mb;
      var nb = function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
          MSApp.execUnsafeLocalFunction(function() {
            return a(b, c, d, e);
          });
        } : a;
      }(function(a, b) {
        if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
          for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
          for (; b.firstChild; ) a.appendChild(b.firstChild);
        }
      });
      function ob(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a) {
        qb.forEach(function(b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          pb[b] = pb[a];
        });
      });
      function rb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
      }
      function sb(a, b) {
        a = a.style;
        for (var c in b) if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
      }
      var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a, b) {
        if (b) {
          if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children) throw Error(p(60));
            if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
          }
          if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
        }
      }
      function vb(a, b) {
        if (-1 === a.indexOf("-")) return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a) {
        if (a = Cb(a)) {
          if ("function" !== typeof yb) throw Error(p(280));
          var b = a.stateNode;
          b && (b = Db(b), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
      }
      function Fb() {
        if (zb) {
          var a = zb, b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a, b, c) {
        if (Ib) return a(b, c);
        Ib = true;
        try {
          return Gb(a, b, c);
        } finally {
          if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
        }
      }
      function Kb(a, b) {
        var c = a.stateNode;
        if (null === c) return null;
        var d = Db(c);
        if (null === d) return null;
        c = d[b];
        a: switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
        if (a) return null;
        if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
        return c;
      }
      var Lb = false;
      if (ia) try {
        Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
      var Mb;
      function Nb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (m) {
          this.onError(m);
        }
      }
      var Ob = false;
      var Pb = null;
      var Qb = false;
      var Rb = null;
      var Sb = { onError: function(a) {
        Ob = true;
        Pb = a;
      } };
      function Tb(a, b, c, d, e, f, g, h, k) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a, b, c, d, e, f, g, h, k) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p(198));
          Qb || (Qb = true, Rb = l);
        }
      }
      function Vb(a) {
        var b = a, c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else {
          a = b;
          do
            b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function Wb(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
          if (null !== b) return b.dehydrated;
        }
        return null;
      }
      function Xb(a) {
        if (Vb(a) !== a) throw Error(p(188));
      }
      function Yb(a) {
        var b = a.alternate;
        if (!b) {
          b = Vb(a);
          if (null === b) throw Error(p(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e) break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c) return Xb(e), a;
              if (f === d) return Xb(e), b;
              f = f.sibling;
            }
            throw Error(p(188));
          }
          if (c.return !== d.return) c = e, d = f;
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g) throw Error(p(189));
            }
          }
          if (c.alternate !== d) throw Error(p(190));
        }
        if (3 !== c.tag) throw Error(p(188));
        return c.stateNode.current === c ? a : b;
      }
      function Zb(a) {
        a = Yb(a);
        return null !== a ? $b(a) : null;
      }
      function $b(a) {
        if (5 === a.tag || 6 === a.tag) return a;
        for (a = a.child; null !== a; ) {
          var b = $b(a);
          if (null !== b) return b;
          a = a.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback;
      var bc = ca.unstable_cancelCallback;
      var cc = ca.unstable_shouldYield;
      var dc = ca.unstable_requestPaint;
      var B = ca.unstable_now;
      var ec = ca.unstable_getCurrentPriorityLevel;
      var fc = ca.unstable_ImmediatePriority;
      var gc = ca.unstable_UserBlockingPriority;
      var hc = ca.unstable_NormalPriority;
      var ic = ca.unstable_LowPriority;
      var jc = ca.unstable_IdlePriority;
      var kc = null;
      var lc = null;
      function mc(a) {
        if (lc && "function" === typeof lc.onCommitFiberRoot) try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {
        }
      }
      var oc = Math.clz32 ? Math.clz32 : nc;
      var pc = Math.log;
      var qc = Math.LN2;
      function nc(a) {
        a >>>= 0;
        return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
      }
      var rc = 64;
      var sc = 4194304;
      function tc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c) return 0;
        var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
        if (0 !== g) {
          var h = g & ~e;
          0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
        } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
        if (0 === d) return 0;
        if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
        0 !== (d & 4) && (d |= c & 16);
        b = a.entangledLanes;
        if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function vc(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 4:
            return b + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a, b) {
        for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
          var g = 31 - oc(f), h = 1 << g, k = e[g];
          if (-1 === k) {
            if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
          } else k <= b && (a.expiredLanes |= h);
          f &= ~h;
        }
      }
      function xc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a;
      }
      function zc(a) {
        for (var b = [], c = 0; 31 > c; c++) b.push(a);
        return b;
      }
      function Ac(a, b, c) {
        a.pendingLanes |= b;
        536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
        a = a.eventTimes;
        b = 31 - oc(b);
        a[b] = c;
      }
      function Bc(a, b) {
        var c = a.pendingLanes & ~b;
        a.pendingLanes = b;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= b;
        a.mutableReadLanes &= b;
        a.entangledLanes &= b;
        b = a.entanglements;
        var d = a.eventTimes;
        for (a = a.expirationTimes; 0 < c; ) {
          var e = 31 - oc(c), f = 1 << e;
          b[e] = 0;
          d[e] = -1;
          a[e] = -1;
          c &= ~f;
        }
      }
      function Cc(a, b) {
        var c = a.entangledLanes |= b;
        for (a = a.entanglements; c; ) {
          var d = 31 - oc(c), e = 1 << d;
          e & b | a[d] & b && (a[d] |= b);
          c &= ~e;
        }
      }
      var C = 0;
      function Dc(a) {
        a &= -a;
        return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec;
      var Fc;
      var Gc;
      var Hc;
      var Ic;
      var Jc = false;
      var Kc = [];
      var Lc = null;
      var Mc = null;
      var Nc = null;
      var Oc = /* @__PURE__ */ new Map();
      var Pc = /* @__PURE__ */ new Map();
      var Qc = [];
      var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b.pointerId);
        }
      }
      function Tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function Uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return Lc = Tc(Lc, a, b, c, d, e), true;
          case "dragenter":
            return Mc = Tc(Mc, a, b, c, d, e), true;
          case "mouseover":
            return Nc = Tc(Nc, a, b, c, d, e), true;
          case "pointerover":
            var f = e.pointerId;
            Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
        }
        return false;
      }
      function Vc(a) {
        var b = Wc(a.target);
        if (null !== b) {
          var c = Vb(b);
          if (null !== c) {
            if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function() {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a.blockedOn = null;
      }
      function Xc(a) {
        if (null !== a.blockedOn) return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null === c) {
            c = a.nativeEvent;
            var d = new c.constructor(c.type, c);
            wb = d;
            c.target.dispatchEvent(d);
            wb = null;
          } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
          b.shift();
        }
        return true;
      }
      function Zc(a, b, c) {
        Xc(a) && c.delete(b);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a, b) {
        a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a) {
        function b(b2) {
          return ad(b2, a);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a);
          for (var c = 1; c < Kc.length; c++) {
            var d = Kc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a);
        null !== Mc && ad(Mc, a);
        null !== Nc && ad(Nc, a);
        Oc.forEach(b);
        Pc.forEach(b);
        for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
        for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig;
      var dd = true;
      function ed(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 1, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function gd(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 4, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function fd(a, b, c, d) {
        if (dd) {
          var e = Yc(a, b, c, d);
          if (null === e) hd(a, b, d, id, c), Sc(a, d);
          else if (Uc(e, a, b, c, d)) d.stopPropagation();
          else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
            for (; null !== e; ) {
              var f = Cb(e);
              null !== f && Ec(f);
              f = Yc(a, b, c, d);
              null === f && hd(a, b, d, id, c);
              if (f === e) break;
              e = f;
            }
            null !== e && d.stopPropagation();
          } else hd(a, b, d, null, c);
        }
      }
      var id = null;
      function Yc(a, b, c, d) {
        id = null;
        a = xb(d);
        a = Wc(a);
        if (null !== a) if (b = Vb(a), null === b) a = null;
        else if (c = b.tag, 13 === c) {
          a = Wb(b);
          if (null !== a) return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else b !== a && (a = null);
        id = a;
        return null;
      }
      function jd(a) {
        switch (a) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md) return md;
        var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++) ;
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
        return md = e.slice(a, 1 < d ? 1 - d : void 0);
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b2, d, e, f, g) {
          this._reactName = b2;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
          this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A(b.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a2 = this.nativeEvent;
          a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
        return a.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = A({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
        return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      }, movementX: function(a) {
        if ("movementX" in a) return a.movementX;
        a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
        return wd;
      }, movementY: function(a) {
        return "movementY" in a ? a.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = A({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = A({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id = A({}, sd, { clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id);
      var Kd = A({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A({}, ud, { key: function(a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b) return b;
        }
        return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
        return "keypress" === a.type ? od(a) : 0;
      }, keyCode: function(a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      }, which: function(a) {
        return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = A({}, Ad, {
        deltaX: function(a) {
          return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
          return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = ia && "CompositionEvent" in window;
      var be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be;
      var de = ia && (!ae || be && 8 < be && 11 >= be);
      var ee = String.fromCharCode(32);
      var fe = false;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he(b);
          case "keypress":
            if (32 !== b.which) return null;
            fe = true;
            return ee;
          case "textInput":
            return a = b.data, a === ee && fe ? null : a;
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
              if (b.char && 1 < b.char.length) return b.char;
              if (b.which) return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
      }
      function ne(a, b, c, d) {
        Eb(d);
        b = oe(b, "onChange");
        0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
      }
      var pe = null;
      var qe = null;
      function re(a) {
        se(a, 0);
      }
      function te(a) {
        var b = ue(a);
        if (Wa(b)) return a;
      }
      function ve(a, b) {
        if ("change" === a) return b;
      }
      var we = false;
      if (ia) {
        if (ia) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      var xe;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a) {
        if ("value" === a.propertyName && te(qe)) {
          var b = [];
          ne(b, qe, a, xb(a));
          Jb(re, b);
        }
      }
      function Ce(a, b, c) {
        "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a) return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a) return te(b);
      }
      function Ge(a, b) {
        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a, b) {
        if (He(a, b)) return true;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length) return false;
        for (d = 0; d < c.length; d++) {
          var e = c[d];
          if (!ja.call(b, e) || !He(a[e], b[e])) return false;
        }
        return true;
      }
      function Je(a) {
        for (; a && a.firstChild; ) a = a.firstChild;
        return a;
      }
      function Ke(a, b) {
        var c = Je(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b) return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Je(c);
        }
      }
      function Le(a, b) {
        return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
      }
      function Me() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c) a = b.contentWindow;
          else break;
          b = Xa(a.document);
        }
        return b;
      }
      function Ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
      }
      function Oe(a) {
        var b = Me(), c = a.focusedElem, d = a.selectionRange;
        if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
          if (null !== d && Ne(c)) {
            if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
            else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length, f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke(c, f);
              var g = Ke(
                c,
                d
              );
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
          }
          b = [];
          for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
          "function" === typeof c.focus && c.focus();
          for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a, b, c) {
        var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
      }
      function Ve(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
      var Xe = {};
      var Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a) {
        if (Xe[a]) return Xe[a];
        if (!We[a]) return a;
        var b = We[a], c;
        for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
        return a;
      }
      var $e = Ze("animationend");
      var af = Ze("animationiteration");
      var bf = Ze("animationstart");
      var cf = Ze("transitionend");
      var df = /* @__PURE__ */ new Map();
      var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a, b) {
        df.set(a, b);
        fa(b, [a]);
      }
      for (gf = 0; gf < ef.length; gf++) {
        hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      var hf;
      var jf;
      var kf;
      var gf;
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Ub(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c], e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b) for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
            else for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
          }
        }
        if (Qb) throw a = Rb, Qb = false, Rb = null, a;
      }
      function D(a, b) {
        var c = b[of];
        void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
        var d = a + "__bubble";
        c.has(d) || (pf(b, a, 2, false), c.add(d));
      }
      function qf(a, b, c) {
        var d = 0;
        b && (d |= 4);
        pf(c, a, d, b);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a) {
        if (!a[rf]) {
          a[rf] = true;
          da.forEach(function(b2) {
            "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
          });
          var b = 9 === a.nodeType ? a : a.ownerDocument;
          null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
        }
      }
      function pf(a, b, c, d) {
        switch (jd(b)) {
          case 1:
            var e = ed;
            break;
          case 4:
            e = gd;
            break;
          default:
            e = fd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
        d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
      }
      function hd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
          if (null === d) return;
          var g = d.tag;
          if (3 === g || 4 === g) {
            var h = d.stateNode.containerInfo;
            if (h === e || 8 === h.nodeType && h.parentNode === e) break;
            if (4 === g) for (g = d.return; null !== g; ) {
              var k = g.tag;
              if (3 === k || 4 === k) {
                if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
              }
              g = g.return;
            }
            for (; null !== h; ) {
              g = Wc(h);
              if (null === g) return;
              k = g.tag;
              if (5 === k || 6 === k) {
                d = f = g;
                continue a;
              }
              h = h.parentNode;
            }
          }
          d = d.return;
        }
        Jb(function() {
          var d2 = f, e2 = xb(c), g2 = [];
          a: {
            var h2 = df.get(a);
            if (void 0 !== h2) {
              var k2 = td, n = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c)) break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  n = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  n = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k2 = Hd;
                  break;
                case cf:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
              t = [];
              for (var w = d2, u; null !== w; ) {
                u = w;
                var F = u.stateNode;
                5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                if (J) break;
                w = w.return;
              }
              0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h2 = "mouseover" === a || "pointerover" === a;
              k2 = "mouseout" === a || "pointerout" === a;
              if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
              if (k2 || h2) {
                h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                if (k2) {
                  if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                } else k2 = null, n = d2;
                if (k2 !== n) {
                  t = Bd;
                  F = "onMouseLeave";
                  x = "onMouseEnter";
                  w = "mouse";
                  if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                  J = null == k2 ? h2 : ue(k2);
                  u = null == n ? h2 : ue(n);
                  h2 = new t(F, w + "leave", k2, c, e2);
                  h2.target = J;
                  h2.relatedTarget = u;
                  F = null;
                  Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                  J = F;
                  if (k2 && n) b: {
                    t = k2;
                    x = n;
                    w = 0;
                    for (u = t; u; u = vf(u)) w++;
                    u = 0;
                    for (F = x; F; F = vf(F)) u++;
                    for (; 0 < w - u; ) t = vf(t), w--;
                    for (; 0 < u - w; ) x = vf(x), u--;
                    for (; w--; ) {
                      if (t === x || null !== x && t === x.alternate) break b;
                      t = vf(t);
                      x = vf(x);
                    }
                    t = null;
                  }
                  else t = null;
                  null !== k2 && wf(g2, h2, k2, t, false);
                  null !== n && null !== J && wf(g2, J, n, t, true);
                }
              }
            }
            a: {
              h2 = d2 ? ue(d2) : window;
              k2 = h2.nodeName && h2.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
              else if (me(h2)) if (we) na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
              else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
              if (na && (na = na(a, d2))) {
                ne(g2, na, c, e2);
                break a;
              }
              xa && xa(a, h2, d2);
              "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
            }
            xa = d2 ? ue(d2) : window;
            switch (a) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g2, c, e2);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g2, c, e2);
            }
            var $a;
            if (ae) b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
            else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
          }
          se(g2, b);
        });
      }
      function tf(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a, f = e.stateNode;
          5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function vf(a) {
        if (null === a) return null;
        do
          a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function wf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c, k = h.alternate, l = h.stateNode;
          if (null !== k && k === d) break;
          5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      var xf = /\r\n?/g;
      var yf = /\u0000|\uFFFD/g;
      function zf(a) {
        return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
      }
      function Af(a, b, c) {
        b = zf(b);
        if (zf(a) !== b && c) throw Error(p(425));
      }
      function Bf() {
      }
      var Cf = null;
      var Df = null;
      function Ef(a, b) {
        return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
      var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var Hf = "function" === typeof Promise ? Promise : void 0;
      var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
        return Hf.resolve(null).then(a).catch(If);
      } : Ff;
      function If(a) {
        setTimeout(function() {
          throw a;
        });
      }
      function Kf(a, b) {
        var c = b, d = 0;
        do {
          var e = c.nextSibling;
          a.removeChild(c);
          if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
            if (0 === d) {
              a.removeChild(e);
              bd(b);
              return;
            }
            d--;
          } else "$" !== c && "$?" !== c && "$!" !== c || d++;
          c = e;
        } while (c);
        bd(b);
      }
      function Lf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b) break;
          if (8 === b) {
            b = a.data;
            if ("$" === b || "$!" === b || "$?" === b) break;
            if ("/$" === b) return null;
          }
        }
        return a;
      }
      function Mf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b) return a;
              b--;
            } else "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2);
      var Of = "__reactFiber$" + Nf;
      var Pf = "__reactProps$" + Nf;
      var uf = "__reactContainer$" + Nf;
      var of = "__reactEvents$" + Nf;
      var Qf = "__reactListeners$" + Nf;
      var Rf = "__reactHandles$" + Nf;
      function Wc(a) {
        var b = a[Of];
        if (b) return b;
        for (var c = a.parentNode; c; ) {
          if (b = c[uf] || c[Of]) {
            c = b.alternate;
            if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
              if (c = a[Of]) return c;
              a = Mf(a);
            }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[Of] || a[uf];
        return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        throw Error(p(33));
      }
      function Db(a) {
        return a[Pf] || null;
      }
      var Sf = [];
      var Tf = -1;
      function Uf(a) {
        return { current: a };
      }
      function E(a) {
        0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a, b) {
        Tf++;
        Sf[Tf] = a.current;
        a.current = b;
      }
      var Vf = {};
      var H = Uf(Vf);
      var Wf = Uf(false);
      var Xf = Vf;
      function Yf(a, b) {
        var c = a.type.contextTypes;
        if (!c) return Vf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c) e[f] = b[f];
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
        return e;
      }
      function Zf(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function $f() {
        E(Wf);
        E(H);
      }
      function ag(a, b, c) {
        if (H.current !== Vf) throw Error(p(168));
        G(H, b);
        G(Wf, c);
      }
      function bg(a, b, c) {
        var d = a.stateNode;
        b = b.childContextTypes;
        if ("function" !== typeof d.getChildContext) return c;
        d = d.getChildContext();
        for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
        return A({}, c, d);
      }
      function cg(a) {
        a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H.current;
        G(H, a);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(p(169));
        c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
        G(Wf, c);
      }
      var eg = null;
      var fg = false;
      var gg = false;
      function hg(a) {
        null === eg ? eg = [a] : eg.push(a);
      }
      function ig(a) {
        fg = true;
        hg(a);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a = 0, b = C;
          try {
            var c = eg;
            for (C = 1; a < c.length; a++) {
              var d = c[a];
              do
                d = d(true);
              while (null !== d);
            }
            eg = null;
            fg = false;
          } catch (e) {
            throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
          } finally {
            C = b, gg = false;
          }
        }
        return null;
      }
      var kg = [];
      var lg = 0;
      var mg = null;
      var ng = 0;
      var og = [];
      var pg = 0;
      var qg = null;
      var rg = 1;
      var sg = "";
      function tg(a, b) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a;
        ng = b;
      }
      function ug(a, b, c) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a;
        var d = rg;
        a = sg;
        var e = 32 - oc(d) - 1;
        d &= ~(1 << e);
        c += 1;
        var f = 32 - oc(b) + e;
        if (30 < f) {
          var g = e - e % 5;
          f = (d & (1 << g) - 1).toString(32);
          d >>= g;
          e -= g;
          rg = 1 << 32 - oc(b) + e | c << e | d;
          sg = f + a;
        } else rg = 1 << f | c << e | d, sg = a;
      }
      function vg(a) {
        null !== a.return && (tg(a, 1), ug(a, 1, 0));
      }
      function wg(a) {
        for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null;
      var yg = null;
      var I = false;
      var zg = null;
      function Ag(a, b) {
        var c = Bg(5, null, null, 0);
        c.elementType = "DELETED";
        c.stateNode = b;
        c.return = a;
        b = a.deletions;
        null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
      }
      function Cg(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
            return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
          case 6:
            return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
          case 13:
            return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a) {
        return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
      }
      function Eg(a) {
        if (I) {
          var b = yg;
          if (b) {
            var c = b;
            if (!Cg(a, b)) {
              if (Dg(a)) throw Error(p(418));
              b = Lf(c.nextSibling);
              var d = xg;
              b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
            }
          } else {
            if (Dg(a)) throw Error(p(418));
            a.flags = a.flags & -4097 | 2;
            I = false;
            xg = a;
          }
        }
      }
      function Fg(a) {
        for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
        xg = a;
      }
      function Gg(a) {
        if (a !== xg) return false;
        if (!I) return Fg(a), I = true, false;
        var b;
        (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
        if (b && (b = yg)) {
          if (Dg(a)) throw Hg(), Error(p(418));
          for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
        }
        Fg(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a) throw Error(p(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    yg = Lf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else "$" !== c && "$!" !== c && "$?" !== c || b++;
              }
              a = a.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a = yg; a; ) a = Lf(a.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a) {
        null === zg ? zg = [a] : zg.push(a);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag) throw Error(p(309));
              var d = c.stateNode;
            }
            if (!d) throw Error(p(147, a));
            var e = d, f = "" + a;
            if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
            b = function(a2) {
              var b2 = e.refs;
              null === a2 ? delete b2[f] : b2[f] = a2;
            };
            b._stringRef = f;
            return b;
          }
          if ("string" !== typeof a) throw Error(p(284));
          if (!c._owner) throw Error(p(290, a));
        }
        return a;
      }
      function Mg(a, b) {
        a = Object.prototype.toString.call(b);
        throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
      }
      function Ng(a) {
        var b = a._init;
        return b(a._payload);
      }
      function Og(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.deletions;
            null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
          }
        }
        function c(c2, d2) {
          if (!a) return null;
          for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          a2 = Pg(a2, b2);
          a2.index = 0;
          a2.sibling = null;
          return a2;
        }
        function f(b2, c2, d2) {
          b2.index = d2;
          if (!a) return b2.flags |= 1048576, c2;
          d2 = b2.alternate;
          if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
          b2.flags |= 2;
          return c2;
        }
        function g(b2) {
          a && null === b2.alternate && (b2.flags |= 2);
          return b2;
        }
        function h(a2, b2, c2, d2) {
          if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function k(a2, b2, c2, d2) {
          var f2 = c2.type;
          if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
          if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
          d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
          d2.ref = Lg(a2, b2, c2);
          d2.return = a2;
          return d2;
        }
        function l(a2, b2, c2, d2) {
          if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2.children || []);
          b2.return = a2;
          return b2;
        }
        function m(a2, b2, c2, d2, f2) {
          if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function q(a2, b2, c2) {
          if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
          if ("object" === typeof b2 && null !== b2) {
            switch (b2.$$typeof) {
              case va:
                return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
              case wa:
                return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
              case Ha:
                var d2 = b2._init;
                return q(a2, d2(b2._payload), c2);
            }
            if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
            Mg(a2, b2);
          }
          return null;
        }
        function r(a2, b2, c2, d2) {
          var e2 = null !== b2 ? b2.key : null;
          if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
          if ("object" === typeof c2 && null !== c2) {
            switch (c2.$$typeof) {
              case va:
                return c2.key === e2 ? k(a2, b2, c2, d2) : null;
              case wa:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
              case Ha:
                return e2 = c2._init, r(
                  a2,
                  b2,
                  e2(c2._payload),
                  d2
                );
            }
            if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
            Mg(a2, c2);
          }
          return null;
        }
        function y(a2, b2, c2, d2, e2) {
          if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if ("object" === typeof d2 && null !== d2) {
            switch (d2.$$typeof) {
              case va:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
              case wa:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
              case Ha:
                var f2 = d2._init;
                return y(a2, b2, c2, f2(d2._payload), e2);
            }
            if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
            Mg(b2, d2);
          }
          return null;
        }
        function n(e2, g2, h2, k2) {
          for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
            u.index > w ? (x = u, u = null) : x = u.sibling;
            var n2 = r(e2, u, h2[w], k2);
            if (null === n2) {
              null === u && (u = x);
              break;
            }
            a && u && null === n2.alternate && b(e2, u);
            g2 = f(n2, g2, w);
            null === m2 ? l2 = n2 : m2.sibling = n2;
            m2 = n2;
            u = x;
          }
          if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
          if (null === u) {
            for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
            I && tg(e2, w);
            return l2;
          }
          for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function t(e2, g2, h2, k2) {
          var l2 = Ka(h2);
          if ("function" !== typeof l2) throw Error(p(150));
          h2 = l2.call(h2);
          if (null == h2) throw Error(p(151));
          for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
            m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
            var t2 = r(e2, m2, n2.value, k2);
            if (null === t2) {
              null === m2 && (m2 = x);
              break;
            }
            a && m2 && null === t2.alternate && b(e2, m2);
            g2 = f(t2, g2, w);
            null === u ? l2 = t2 : u.sibling = t2;
            u = t2;
            m2 = x;
          }
          if (n2.done) return c(
            e2,
            m2
          ), I && tg(e2, w), l2;
          if (null === m2) {
            for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
            I && tg(e2, w);
            return l2;
          }
          for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          a && m2.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function J(a2, d2, f2, h2) {
          "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
          if ("object" === typeof f2 && null !== f2) {
            switch (f2.$$typeof) {
              case va:
                a: {
                  for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                    if (l2.key === k2) {
                      k2 = f2.type;
                      if (k2 === ya) {
                        if (7 === l2.tag) {
                          c(a2, l2.sibling);
                          d2 = e(l2, f2.props.children);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                      } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props);
                        d2.ref = Lg(a2, l2, f2);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                      c(a2, l2);
                      break;
                    } else b(a2, l2);
                    l2 = l2.sibling;
                  }
                  f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case wa:
                a: {
                  for (l2 = f2.key; null !== d2; ) {
                    if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                    else b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = Sg(f2, a2.mode, h2);
                  d2.return = a2;
                  a2 = d2;
                }
                return g(a2);
              case Ha:
                return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
            }
            if (eb(f2)) return n(a2, d2, f2, h2);
            if (Ka(f2)) return t(a2, d2, f2, h2);
            Mg(a2, f2);
          }
          return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
        }
        return J;
      }
      var Ug = Og(true);
      var Vg = Og(false);
      var Wg = Uf(null);
      var Xg = null;
      var Yg = null;
      var Zg = null;
      function $g() {
        Zg = Yg = Xg = null;
      }
      function ah(a) {
        var b = Wg.current;
        E(Wg);
        a._currentValue = b;
      }
      function bh(a, b, c) {
        for (; null !== a; ) {
          var d = a.alternate;
          (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
          if (a === c) break;
          a = a.return;
        }
      }
      function ch(a, b) {
        Xg = a;
        Zg = Yg = null;
        a = a.dependencies;
        null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
      }
      function eh(a) {
        var b = a._currentValue;
        if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
          if (null === Xg) throw Error(p(308));
          Yg = a;
          Xg.dependencies = { lanes: 0, firstContext: a };
        } else Yg = Yg.next = a;
        return b;
      }
      var fh = null;
      function gh(a) {
        null === fh ? fh = [a] : fh.push(a);
      }
      function hh(a, b, c, d) {
        var e = b.interleaved;
        null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
        b.interleaved = c;
        return ih(a, d);
      }
      function ih(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
        return 3 === c.tag ? c.stateNode : null;
      }
      var jh = false;
      function kh(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function lh(a, b) {
        a = a.updateQueue;
        b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function mh(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function nh(a, b, c) {
        var d = a.updateQueue;
        if (null === d) return null;
        d = d.shared;
        if (0 !== (K & 2)) {
          var e = d.pending;
          null === e ? b.next = b : (b.next = e.next, e.next = b);
          d.pending = b;
          return ih(a, c);
        }
        e = d.interleaved;
        null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
        d.interleaved = b;
        return ih(a, c);
      }
      function oh(a, b, c) {
        b = b.updateQueue;
        if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      function ph(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (null !== d && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              null === f ? e = f = g : f = f.next = g;
              c = c.next;
            } while (null !== c);
            null === f ? e = f = b : f = f.next = b;
          } else e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? c.firstBaseUpdate = b : a.next = b;
        c.lastBaseUpdate = b;
      }
      function qh(a, b, c, d) {
        var e = a.updateQueue;
        jh = false;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null;
          null === g ? f = l : g.next = l;
          g = k;
          var m = a.alternate;
          null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
        }
        if (null !== f) {
          var q = e.baseState;
          g = 0;
          m = l = k = null;
          h = f;
          do {
            var r = h.lane, y = h.eventTime;
            if ((d & r) === r) {
              null !== m && (m = m.next = {
                eventTime: y,
                lane: 0,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              });
              a: {
                var n = a, t = h;
                r = b;
                y = c;
                switch (t.tag) {
                  case 1:
                    n = t.payload;
                    if ("function" === typeof n) {
                      q = n.call(y, q, r);
                      break a;
                    }
                    q = n;
                    break a;
                  case 3:
                    n.flags = n.flags & -65537 | 128;
                  case 0:
                    n = t.payload;
                    r = "function" === typeof n ? n.call(y, q, r) : n;
                    if (null === r || void 0 === r) break a;
                    q = A({}, q, r);
                    break a;
                  case 2:
                    jh = true;
                }
              }
              null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
            } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
            h = h.next;
            if (null === h) if (h = e.shared.pending, null === h) break;
            else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
          } while (1);
          null === m && (k = q);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = m;
          b = e.shared.interleaved;
          if (null !== b) {
            e = b;
            do
              g |= e.lane, e = e.next;
            while (e !== b);
          } else null === f && (e.shared.lanes = 0);
          rh |= g;
          a.lanes = g;
          a.memoizedState = q;
        }
      }
      function sh(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a) for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e) throw Error(p(191, e));
            e.call(d);
          }
        }
      }
      var th = {};
      var uh = Uf(th);
      var vh = Uf(th);
      var wh = Uf(th);
      function xh(a) {
        if (a === th) throw Error(p(174));
        return a;
      }
      function yh(a, b) {
        G(wh, b);
        G(vh, a);
        G(uh, th);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
            break;
          default:
            a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
        }
        E(uh);
        G(uh, b);
      }
      function zh() {
        E(uh);
        E(vh);
        E(wh);
      }
      function Ah(a) {
        xh(wh.current);
        var b = xh(uh.current);
        var c = lb(b, a.type);
        b !== c && (G(vh, a), G(uh, c));
      }
      function Bh(a) {
        vh.current === a && (E(uh), E(vh));
      }
      var L = Uf(0);
      function Ch(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 128)) return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var Dh = [];
      function Eh() {
        for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
        Dh.length = 0;
      }
      var Fh = ua.ReactCurrentDispatcher;
      var Gh = ua.ReactCurrentBatchConfig;
      var Hh = 0;
      var M = null;
      var N = null;
      var O = null;
      var Ih = false;
      var Jh = false;
      var Kh = 0;
      var Lh = 0;
      function P() {
        throw Error(p(321));
      }
      function Mh(a, b) {
        if (null === b) return false;
        for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
        return true;
      }
      function Nh(a, b, c, d, e, f) {
        Hh = f;
        M = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
        a = c(d, e);
        if (Jh) {
          f = 0;
          do {
            Jh = false;
            Kh = 0;
            if (25 <= f) throw Error(p(301));
            f += 1;
            O = N = null;
            b.updateQueue = null;
            Fh.current = Qh;
            a = c(d, e);
          } while (Jh);
        }
        Fh.current = Rh;
        b = null !== N && null !== N.next;
        Hh = 0;
        O = N = M = null;
        Ih = false;
        if (b) throw Error(p(300));
        return a;
      }
      function Sh() {
        var a = 0 !== Kh;
        Kh = 0;
        return a;
      }
      function Th() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === O ? M.memoizedState = O = a : O = O.next = a;
        return O;
      }
      function Uh() {
        if (null === N) {
          var a = M.alternate;
          a = null !== a ? a.memoizedState : null;
        } else a = N.next;
        var b = null === O ? M.memoizedState : O.next;
        if (null !== b) O = b, N = a;
        else {
          if (null === a) throw Error(p(310));
          N = a;
          a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
          null === O ? M.memoizedState = O = a : O = O.next = a;
        }
        return O;
      }
      function Vh(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function Wh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = N, e = d.baseQueue, f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          f = e.next;
          d = d.baseState;
          var h = g = null, k = null, l = f;
          do {
            var m = l.lane;
            if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
            else {
              var q = {
                lane: m,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              };
              null === k ? (h = k = q, g = d) : k = k.next = q;
              M.lanes |= m;
              rh |= m;
            }
            l = l.next;
          } while (null !== l && l !== f);
          null === k ? g = d : k.next = h;
          He(d, b.memoizedState) || (dh = true);
          b.memoizedState = d;
          b.baseState = g;
          b.baseQueue = k;
          c.lastRenderedState = d;
        }
        a = c.interleaved;
        if (null !== a) {
          e = a;
          do
            f = e.lane, M.lanes |= f, rh |= f, e = e.next;
          while (e !== a);
        } else null === e && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function Xh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          He(f, b.memoizedState) || (dh = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Yh() {
      }
      function Zh(a, b) {
        var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
        f && (d.memoizedState = e, dh = true);
        d = d.queue;
        $h(ai.bind(null, c, d, a), [a]);
        if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
          c.flags |= 2048;
          bi(9, ci.bind(null, c, d, e, b), void 0, null);
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(c, b, e);
        }
        return e;
      }
      function di(a, b, c) {
        a.flags |= 16384;
        a = { getSnapshot: b, value: c };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
      }
      function ci(a, b, c, d) {
        b.value = c;
        b.getSnapshot = d;
        ei(b) && fi(a);
      }
      function ai(a, b, c) {
        return c(function() {
          ei(b) && fi(a);
        });
      }
      function ei(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !He(a, c);
        } catch (d) {
          return true;
        }
      }
      function fi(a) {
        var b = ih(a, 1);
        null !== b && gi(b, a, 1, -1);
      }
      function hi(a) {
        var b = Th();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
        b.queue = a;
        a = a.dispatch = ii.bind(null, M, a);
        return [b.memoizedState, a];
      }
      function bi(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
        return a;
      }
      function ji() {
        return Uh().memoizedState;
      }
      function ki(a, b, c, d) {
        var e = Th();
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function li(a, b, c, d) {
        var e = Uh();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== N) {
          var g = N.memoizedState;
          f = g.destroy;
          if (null !== d && Mh(d, g.deps)) {
            e.memoizedState = bi(b, c, f, d);
            return;
          }
        }
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, f, d);
      }
      function mi(a, b) {
        return ki(8390656, 8, a, b);
      }
      function $h(a, b) {
        return li(2048, 8, a, b);
      }
      function ni(a, b) {
        return li(4, 2, a, b);
      }
      function oi(a, b) {
        return li(4, 4, a, b);
      }
      function pi(a, b) {
        if ("function" === typeof b) return a = a(), b(a), function() {
          b(null);
        };
        if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
          b.current = null;
        };
      }
      function qi(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return li(4, 4, pi.bind(null, b, a), c);
      }
      function ri() {
      }
      function si(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function ti(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function ui(a, b, c) {
        if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
        He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
        return b;
      }
      function vi(a, b) {
        var c = C;
        C = 0 !== c && 4 > c ? c : 4;
        a(true);
        var d = Gh.transition;
        Gh.transition = {};
        try {
          a(false), b();
        } finally {
          C = c, Gh.transition = d;
        }
      }
      function wi() {
        return Uh().memoizedState;
      }
      function xi(a, b, c) {
        var d = yi(a);
        c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, c);
        else if (c = hh(a, b, c, d), null !== c) {
          var e = R();
          gi(c, a, d, e);
          Bi(c, b, d);
        }
      }
      function ii(a, b, c) {
        var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, e);
        else {
          var f = a.alternate;
          if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
            var g = b.lastRenderedState, h = f(g, c);
            e.hasEagerState = true;
            e.eagerState = h;
            if (He(h, g)) {
              var k = b.interleaved;
              null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
              b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
          c = hh(a, b, e, d);
          null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
        }
      }
      function zi(a) {
        var b = a.alternate;
        return a === M || null !== b && b === M;
      }
      function Ai(a, b) {
        Jh = Ih = true;
        var c = a.pending;
        null === c ? b.next = b : (b.next = c.next, c.next = b);
        a.pending = b;
      }
      function Bi(a, b, c) {
        if (0 !== (c & 4194240)) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false };
      var Oh = { readContext: eh, useCallback: function(a, b) {
        Th().memoizedState = [a, void 0 === b ? null : b];
        return a;
      }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return ki(
          4194308,
          4,
          pi.bind(null, b, a),
          c
        );
      }, useLayoutEffect: function(a, b) {
        return ki(4194308, 4, a, b);
      }, useInsertionEffect: function(a, b) {
        return ki(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = Th();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      }, useReducer: function(a, b, c) {
        var d = Th();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
        d.queue = a;
        a = a.dispatch = xi.bind(null, M, a);
        return [d.memoizedState, a];
      }, useRef: function(a) {
        var b = Th();
        a = { current: a };
        return b.memoizedState = a;
      }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
        return Th().memoizedState = a;
      }, useTransition: function() {
        var a = hi(false), b = a[0];
        a = vi.bind(null, a[1]);
        Th().memoizedState = a;
        return [b, a];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a, b, c) {
        var d = M, e = Th();
        if (I) {
          if (void 0 === c) throw Error(p(407));
          c = c();
        } else {
          c = b();
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(d, b, c);
        }
        e.memoizedState = c;
        var f = { value: c, getSnapshot: b };
        e.queue = f;
        mi(ai.bind(
          null,
          d,
          f,
          a
        ), [a]);
        d.flags |= 2048;
        bi(9, ci.bind(null, d, f, c, b), void 0, null);
        return c;
      }, useId: function() {
        var a = Th(), b = Q.identifierPrefix;
        if (I) {
          var c = sg;
          var d = rg;
          c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
          b = ":" + b + "R" + c;
          c = Kh++;
          0 < c && (b += "H" + c.toString(32));
          b += ":";
        } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
        return a.memoizedState = b;
      }, unstable_isNewReconciler: false };
      var Ph = {
        readContext: eh,
        useCallback: si,
        useContext: eh,
        useEffect: $h,
        useImperativeHandle: qi,
        useInsertionEffect: ni,
        useLayoutEffect: oi,
        useMemo: ti,
        useReducer: Wh,
        useRef: ji,
        useState: function() {
          return Wh(Vh);
        },
        useDebugValue: ri,
        useDeferredValue: function(a) {
          var b = Uh();
          return ui(b, N.memoizedState, a);
        },
        useTransition: function() {
          var a = Wh(Vh)[0], b = Uh().memoizedState;
          return [a, b];
        },
        useMutableSource: Yh,
        useSyncExternalStore: Zh,
        useId: wi,
        unstable_isNewReconciler: false
      };
      var Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
        return Xh(Vh);
      }, useDebugValue: ri, useDeferredValue: function(a) {
        var b = Uh();
        return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
      }, useTransition: function() {
        var a = Xh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
      function Ci(a, b) {
        if (a && a.defaultProps) {
          b = A({}, b);
          a = a.defaultProps;
          for (var c in a) void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      function Di(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : A({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Ei = { isMounted: function(a) {
        return (a = a._reactInternals) ? Vb(a) === a : false;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = R(), d = yi(a), e = mh(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        b = nh(a, e, d);
        null !== b && (gi(b, a, d, c), oh(b, a, d));
      } };
      function Fi(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
      }
      function Gi(a, b, c) {
        var d = false, e = Vf;
        var f = b.contextType;
        "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
        b = new b(c, f);
        a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = Ei;
        a.stateNode = b;
        b._reactInternals = a;
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
        return b;
      }
      function Hi(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
      }
      function Ii(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = {};
        kh(a);
        var f = b.contextType;
        "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
        "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
        "function" === typeof e.componentDidMount && (a.flags |= 4194308);
      }
      function Ji(a, b) {
        try {
          var c = "", d = b;
          do
            c += Pa(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Ki(a, b, c) {
        return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
      }
      function Li(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Mi = "function" === typeof WeakMap ? WeakMap : Map;
      function Ni(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function() {
          Oi || (Oi = true, Pi = d);
          Li(a, b);
        };
        return c;
      }
      function Qi(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function() {
            return d(e);
          };
          c.callback = function() {
            Li(a, b);
          };
        }
        var f = a.stateNode;
        null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
          Li(a, b);
          "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
        });
        return c;
      }
      function Si(a, b, c) {
        var d = a.pingCache;
        if (null === d) {
          d = a.pingCache = new Mi();
          var e = /* @__PURE__ */ new Set();
          d.set(b, e);
        } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
        e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
      }
      function Ui(a) {
        do {
          var b;
          if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
          if (b) return a;
          a = a.return;
        } while (null !== a);
        return null;
      }
      function Vi(a, b, c, d, e) {
        if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
        a.flags |= 65536;
        a.lanes = e;
        return a;
      }
      var Wi = ua.ReactCurrentOwner;
      var dh = false;
      function Xi(a, b, c, d) {
        b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
      }
      function Yi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        ch(b, e);
        d = Nh(a, b, c, d, f, e);
        c = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && c && vg(b);
        b.flags |= 1;
        Xi(a, b, d, e);
        return b.child;
      }
      function $i(a, b, c, d, e) {
        if (null === a) {
          var f = c.type;
          if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
          a = Rg(c.type, null, d, b, b.mode, e);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        f = a.child;
        if (0 === (a.lanes & e)) {
          var g = f.memoizedProps;
          c = c.compare;
          c = null !== c ? c : Ie;
          if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
        }
        b.flags |= 1;
        a = Pg(f, d);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      function bj(a, b, c, d, e) {
        if (null !== a) {
          var f = a.memoizedProps;
          if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
          else return b.lanes = a.lanes, Zi(a, b, e);
        }
        return cj(a, b, c, d, e);
      }
      function dj(a, b, c) {
        var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
        else {
          if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f ? f.baseLanes : c;
          G(ej, fj);
          fj |= d;
        }
        else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
        Xi(a, b, e, c);
        return b.child;
      }
      function gj(a, b) {
        var c = b.ref;
        if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
      }
      function cj(a, b, c, d, e) {
        var f = Zf(c) ? Xf : H.current;
        f = Yf(b, f);
        ch(b, e);
        c = Nh(a, b, c, d, f, e);
        d = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && d && vg(b);
        b.flags |= 1;
        Xi(a, b, c, e);
        return b.child;
      }
      function hj(a, b, c, d, e) {
        if (Zf(c)) {
          var f = true;
          cg(b);
        } else f = false;
        ch(b, e);
        if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
        else if (null === a) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
          var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
          q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
          jh = false;
          var r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          k = b.memoizedState;
          h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
        } else {
          g = b.stateNode;
          lh(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : Ci(b.type, h);
          g.props = l;
          q = b.pendingProps;
          r = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
          var y = c.getDerivedStateFromProps;
          (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
          jh = false;
          r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          var n = b.memoizedState;
          h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
        }
        return jj(a, b, c, d, f, e);
      }
      function jj(a, b, c, d, e, f) {
        gj(a, b);
        var g = 0 !== (b.flags & 128);
        if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
        d = b.stateNode;
        Wi.current = b;
        var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
        b.flags |= 1;
        null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
        b.memoizedState = d.state;
        e && dg(b, c, true);
        return b.child;
      }
      function kj(a) {
        var b = a.stateNode;
        b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
        yh(a, b.containerInfo);
      }
      function lj(a, b, c, d, e) {
        Ig();
        Jg(e);
        b.flags |= 256;
        Xi(a, b, c, d);
        return b.child;
      }
      var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function nj(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function oj(a, b, c) {
        var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
        (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        if (h) f = true, b.flags &= -129;
        else if (null === a || null !== a.memoizedState) e |= 1;
        G(L, e & 1);
        if (null === a) {
          Eg(b);
          a = b.memoizedState;
          if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
          g = d.children;
          a = d.fallback;
          return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
        }
        e = a.memoizedState;
        if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
        if (f) {
          f = d.fallback;
          g = b.mode;
          e = a.child;
          h = e.sibling;
          var k = { mode: "hidden", children: d.children };
          0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
          null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
          f.return = b;
          d.return = b;
          d.sibling = f;
          b.child = d;
          d = f;
          f = b.child;
          g = a.child.memoizedState;
          g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
          f.memoizedState = g;
          f.childLanes = a.childLanes & ~c;
          b.memoizedState = mj;
          return d;
        }
        f = a.child;
        a = f.sibling;
        d = Pg(f, { mode: "visible", children: d.children });
        0 === (b.mode & 1) && (d.lanes = c);
        d.return = b;
        d.sibling = null;
        null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
        b.child = d;
        b.memoizedState = null;
        return d;
      }
      function qj(a, b) {
        b = pj({ mode: "visible", children: b }, a.mode, 0, null);
        b.return = a;
        return a.child = b;
      }
      function sj(a, b, c, d) {
        null !== d && Jg(d);
        Ug(b, a.child, null, c);
        a = qj(b, b.pendingProps.children);
        a.flags |= 2;
        b.memoizedState = null;
        return a;
      }
      function rj(a, b, c, d, e, f, g) {
        if (c) {
          if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
          if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
          f = d.fallback;
          e = b.mode;
          d = pj({ mode: "visible", children: d.children }, e, 0, null);
          f = Tg(f, e, g, null);
          f.flags |= 2;
          d.return = b;
          f.return = b;
          d.sibling = f;
          b.child = d;
          0 !== (b.mode & 1) && Ug(b, a.child, null, g);
          b.child.memoizedState = nj(g);
          b.memoizedState = mj;
          return f;
        }
        if (0 === (b.mode & 1)) return sj(a, b, g, null);
        if ("$!" === e.data) {
          d = e.nextSibling && e.nextSibling.dataset;
          if (d) var h = d.dgst;
          d = h;
          f = Error(p(419));
          d = Ki(f, d, void 0);
          return sj(a, b, g, d);
        }
        h = 0 !== (g & a.childLanes);
        if (dh || h) {
          d = Q;
          if (null !== d) {
            switch (g & -g) {
              case 4:
                e = 2;
                break;
              case 16:
                e = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e = 32;
                break;
              case 536870912:
                e = 268435456;
                break;
              default:
                e = 0;
            }
            e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
            0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
          }
          tj();
          d = Ki(Error(p(421)));
          return sj(a, b, g, d);
        }
        if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
        a = f.treeContext;
        yg = Lf(e.nextSibling);
        xg = b;
        I = true;
        zg = null;
        null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
        b = qj(b, d.children);
        b.flags |= 4096;
        return b;
      }
      function vj(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        null !== d && (d.lanes |= b);
        bh(a.return, b, c);
      }
      function wj(a, b, c, d, e) {
        var f = a.memoizedState;
        null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
      }
      function xj(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        Xi(a, b, d.children, c);
        d = L.current;
        if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
        else {
          if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
            if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
            else if (19 === a.tag) vj(a, c, b);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b) break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b) break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
          d &= 1;
        }
        G(L, d);
        if (0 === (b.mode & 1)) b.memoizedState = null;
        else switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            wj(b, false, e, c, f);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Ch(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            wj(b, true, c, null, f);
            break;
          case "together":
            wj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
        return b.child;
      }
      function ij(a, b) {
        0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      }
      function Zi(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        rh |= b.lanes;
        if (0 === (c & b.childLanes)) return null;
        if (null !== a && b.child !== a.child) throw Error(p(153));
        if (null !== b.child) {
          a = b.child;
          c = Pg(a, a.pendingProps);
          b.child = c;
          for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      function yj(a, b, c) {
        switch (b.tag) {
          case 3:
            kj(b);
            Ig();
            break;
          case 5:
            Ah(b);
            break;
          case 1:
            Zf(b.type) && cg(b);
            break;
          case 4:
            yh(b, b.stateNode.containerInfo);
            break;
          case 10:
            var d = b.type._context, e = b.memoizedProps.value;
            G(Wg, d._currentValue);
            d._currentValue = e;
            break;
          case 13:
            d = b.memoizedState;
            if (null !== d) {
              if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
              if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
              G(L, L.current & 1);
              a = Zi(a, b, c);
              return null !== a ? a.sibling : null;
            }
            G(L, L.current & 1);
            break;
          case 19:
            d = 0 !== (c & b.childLanes);
            if (0 !== (a.flags & 128)) {
              if (d) return xj(a, b, c);
              b.flags |= 128;
            }
            e = b.memoizedState;
            null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
            G(L, L.current);
            if (d) break;
            else return null;
          case 22:
          case 23:
            return b.lanes = 0, dj(a, b, c);
        }
        return Zi(a, b, c);
      }
      var zj;
      var Aj;
      var Bj;
      var Cj;
      zj = function(a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b) break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b) return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Aj = function() {
      };
      Bj = function(a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          xh(uh.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "select":
              e = A({}, e, { value: void 0 });
              d = A({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
          }
          ub(c, d);
          var g;
          c = null;
          for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
            var h = e[l];
            for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
          } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
              for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
              for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
            } else c || (f || (f = []), f.push(
              l,
              c
            )), c = k;
            else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
          }
          c && (f = f || []).push("style", c);
          var l = f;
          if (b.updateQueue = l) b.flags |= 4;
        }
      };
      Cj = function(a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Dj(a, b) {
        if (!I) switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
      }
      function S(a) {
        var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
        if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
        else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
        a.subtreeFlags |= d;
        a.childLanes = c;
        return b;
      }
      function Ej(a, b, c) {
        var d = b.pendingProps;
        wg(b);
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S(b), null;
          case 1:
            return Zf(b.type) && $f(), S(b), null;
          case 3:
            d = b.stateNode;
            zh();
            E(Wf);
            E(H);
            Eh();
            d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
            if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
            Aj(a, b);
            S(b);
            return null;
          case 5:
            Bh(b);
            var e = xh(wh.current);
            c = b.type;
            if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            else {
              if (!d) {
                if (null === b.stateNode) throw Error(p(166));
                S(b);
                return null;
              }
              a = xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[Of] = b;
                d[Pf] = f;
                a = 0 !== (b.mode & 1);
                switch (c) {
                  case "dialog":
                    D("cancel", d);
                    D("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], d);
                    break;
                  case "source":
                    D("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      d
                    );
                    D("load", d);
                    break;
                  case "details":
                    D("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    D("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    D("invalid", d);
                    break;
                  case "textarea":
                    hb(d, f), D("invalid", d);
                }
                ub(c, f);
                e = null;
                for (var g in f) if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                }
                switch (c) {
                  case "input":
                    Va(d);
                    db(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = Bf);
                }
                d = e;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                a[Of] = b;
                a[Pf] = d;
                zj(a, b, false, false);
                b.stateNode = a;
                a: {
                  g = vb(c, d);
                  switch (c) {
                    case "dialog":
                      D("cancel", a);
                      D("close", a);
                      e = d;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", a);
                      e = d;
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D(lf[e], a);
                      e = d;
                      break;
                    case "source":
                      D("error", a);
                      e = d;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D(
                        "error",
                        a
                      );
                      D("load", a);
                      e = d;
                      break;
                    case "details":
                      D("toggle", a);
                      e = d;
                      break;
                    case "input":
                      Za(a, d);
                      e = Ya(a, d);
                      D("invalid", a);
                      break;
                    case "option":
                      e = d;
                      break;
                    case "select":
                      a._wrapperState = { wasMultiple: !!d.multiple };
                      e = A({}, d, { value: void 0 });
                      D("invalid", a);
                      break;
                    case "textarea":
                      hb(a, d);
                      e = gb(a, d);
                      D("invalid", a);
                      break;
                    default:
                      e = d;
                  }
                  ub(c, e);
                  h = e;
                  for (f in h) if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                  }
                  switch (c) {
                    case "input":
                      Va(a);
                      db(a, d, false);
                      break;
                    case "textarea":
                      Va(a);
                      jb(a);
                      break;
                    case "option":
                      null != d.value && a.setAttribute("value", "" + Sa(d.value));
                      break;
                    case "select":
                      a.multiple = !!d.multiple;
                      f = d.value;
                      null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                        a,
                        !!d.multiple,
                        d.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e.onClick && (a.onclick = Bf);
                  }
                  switch (c) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d = !!d.autoFocus;
                      break a;
                    case "img":
                      d = true;
                      break a;
                    default:
                      d = false;
                  }
                }
                d && (b.flags |= 4);
              }
              null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            }
            S(b);
            return null;
          case 6:
            if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
              c = xh(wh.current);
              xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.memoizedProps;
                d[Of] = b;
                if (f = d.nodeValue !== c) {
                  if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                }
                f && (b.flags |= 4);
              } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
            }
            S(b);
            return null;
          case 13:
            E(L);
            d = b.memoizedState;
            if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
              if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
              else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                if (null === a) {
                  if (!f) throw Error(p(318));
                  f = b.memoizedState;
                  f = null !== f ? f.dehydrated : null;
                  if (!f) throw Error(p(317));
                  f[Of] = b;
                } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                S(b);
                f = false;
              } else null !== zg && (Fj(zg), zg = null), f = true;
              if (!f) return b.flags & 65536 ? b : null;
            }
            if (0 !== (b.flags & 128)) return b.lanes = c, b;
            d = null !== d;
            d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
            null !== b.updateQueue && (b.flags |= 4);
            S(b);
            return null;
          case 4:
            return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
          case 10:
            return ah(b.type._context), S(b), null;
          case 17:
            return Zf(b.type) && $f(), S(b), null;
          case 19:
            E(L);
            f = b.memoizedState;
            if (null === f) return S(b), null;
            d = 0 !== (b.flags & 128);
            g = f.rendering;
            if (null === g) if (d) Dj(f, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
                g = Ch(a);
                if (null !== g) {
                  b.flags |= 128;
                  Dj(f, false);
                  d = g.updateQueue;
                  null !== d && (b.updateQueue = d, b.flags |= 4);
                  b.subtreeFlags = 0;
                  d = c;
                  for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                  G(L, L.current & 1 | 2);
                  return b.child;
                }
                a = a.sibling;
              }
              null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            }
            else {
              if (!d) if (a = Ch(g), null !== a) {
                if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
              } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
              f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
            }
            if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
            S(b);
            return null;
          case 22:
          case 23:
            return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p(156, b.tag));
      }
      function Ij(a, b) {
        wg(b);
        switch (b.tag) {
          case 1:
            return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 3:
            return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
          case 5:
            return Bh(b), null;
          case 13:
            E(L);
            a = b.memoizedState;
            if (null !== a && null !== a.dehydrated) {
              if (null === b.alternate) throw Error(p(340));
              Ig();
            }
            a = b.flags;
            return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 19:
            return E(L), null;
          case 4:
            return zh(), null;
          case 10:
            return ah(b.type._context), null;
          case 22:
          case 23:
            return Hj(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Jj = false;
      var U = false;
      var Kj = "function" === typeof WeakSet ? WeakSet : Set;
      var V = null;
      function Lj(a, b) {
        var c = a.ref;
        if (null !== c) if ("function" === typeof c) try {
          c(null);
        } catch (d) {
          W(a, b, d);
        }
        else c.current = null;
      }
      function Mj(a, b, c) {
        try {
          c();
        } catch (d) {
          W(a, b, d);
        }
      }
      var Nj = false;
      function Oj(a, b) {
        Cf = dd;
        a = Me();
        if (Ne(a)) {
          if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
          else a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F) {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b: for (; ; ) {
                for (var y; ; ) {
                  q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                  q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                  3 === q.nodeType && (g += q.nodeValue.length);
                  if (null === (y = q.firstChild)) break;
                  r = q;
                  q = y;
                }
                for (; ; ) {
                  if (q === a) break b;
                  r === c && ++l === e && (h = g);
                  r === f && ++m === d && (k = g);
                  if (null !== (y = q.nextSibling)) break;
                  q = r;
                  r = q.parentNode;
                }
                q = y;
              }
              c = -1 === h || -1 === k ? null : { start: h, end: k };
            } else c = null;
          }
          c = c || { start: 0, end: 0 };
        } else c = null;
        Df = { focusedElem: a, selectionRange: c };
        dd = false;
        for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
        else for (; null !== V; ) {
          b = V;
          try {
            var n = b.alternate;
            if (0 !== (b.flags & 1024)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n) {
                  var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                  x.__reactInternalSnapshotBeforeUpdate = w;
                }
                break;
              case 3:
                var u = b.stateNode.containerInfo;
                1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p(163));
            }
          } catch (F) {
            W(b, b.return, F);
          }
          a = b.sibling;
          if (null !== a) {
            a.return = b.return;
            V = a;
            break;
          }
          V = b.return;
        }
        n = Nj;
        Nj = false;
        return n;
      }
      function Pj(a, b, c) {
        var d = b.updateQueue;
        d = null !== d ? d.lastEffect : null;
        if (null !== d) {
          var e = d = d.next;
          do {
            if ((e.tag & a) === a) {
              var f = e.destroy;
              e.destroy = void 0;
              void 0 !== f && Mj(b, c, f);
            }
            e = e.next;
          } while (e !== d);
        }
      }
      function Qj(a, b) {
        b = b.updateQueue;
        b = null !== b ? b.lastEffect : null;
        if (null !== b) {
          var c = b = b.next;
          do {
            if ((c.tag & a) === a) {
              var d = c.create;
              c.destroy = d();
            }
            c = c.next;
          } while (c !== b);
        }
      }
      function Rj(a) {
        var b = a.ref;
        if (null !== b) {
          var c = a.stateNode;
          switch (a.tag) {
            case 5:
              a = c;
              break;
            default:
              a = c;
          }
          "function" === typeof b ? b(a) : b.current = a;
        }
      }
      function Sj(a) {
        var b = a.alternate;
        null !== b && (a.alternate = null, Sj(b));
        a.child = null;
        a.deletions = null;
        a.sibling = null;
        5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
        a.stateNode = null;
        a.return = null;
        a.dependencies = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.stateNode = null;
        a.updateQueue = null;
      }
      function Tj(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function Uj(a) {
        a: for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Tj(a.return)) return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2) continue a;
            if (null === a.child || 4 === a.tag) continue a;
            else a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2)) return a.stateNode;
        }
      }
      function Vj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
        else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
      }
      function Wj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
        else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
      }
      var X = null;
      var Xj = false;
      function Yj(a, b, c) {
        for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
      }
      function Zj(a, b, c) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h) {
        }
        switch (c.tag) {
          case 5:
            U || Lj(c, b);
          case 6:
            var d = X, e = Xj;
            X = null;
            Yj(a, b, c);
            X = d;
            Xj = e;
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
            break;
          case 18:
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
            break;
          case 4:
            d = X;
            e = Xj;
            X = c.stateNode.containerInfo;
            Xj = true;
            Yj(a, b, c);
            X = d;
            Xj = e;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
              e = d = d.next;
              do {
                var f = e, g = f.destroy;
                f = f.tag;
                void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                e = e.next;
              } while (e !== d);
            }
            Yj(a, b, c);
            break;
          case 1:
            if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
            Yj(a, b, c);
            break;
          case 21:
            Yj(a, b, c);
            break;
          case 22:
            c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
            break;
          default:
            Yj(a, b, c);
        }
      }
      function ak(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Kj());
          b.forEach(function(b2) {
            var d = bk.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function ck(a, b) {
        var c = b.deletions;
        if (null !== c) for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a: for (; null !== h; ) {
              switch (h.tag) {
                case 5:
                  X = h.stateNode;
                  Xj = false;
                  break a;
                case 3:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
                case 4:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
              }
              h = h.return;
            }
            if (null === X) throw Error(p(160));
            Zj(f, g, e);
            X = null;
            Xj = false;
            var k = e.alternate;
            null !== k && (k.return = null);
            e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
        if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
      }
      function dk(a, b) {
        var c = a.alternate, d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ck(b, a);
            ek(a);
            if (d & 4) {
              try {
                Pj(3, a, a.return), Qj(3, a);
              } catch (t) {
                W(a, a.return, t);
              }
              try {
                Pj(5, a, a.return);
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 1:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            break;
          case 5:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            if (a.flags & 32) {
              var e = a.stateNode;
              try {
                ob(e, "");
              } catch (t) {
                W(a, a.return, t);
              }
            }
            if (d & 4 && (e = a.stateNode, null != e)) {
              var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
              a.updateQueue = null;
              if (null !== k) try {
                "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      true
                    ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 6:
            ck(b, a);
            ek(a);
            if (d & 4) {
              if (null === a.stateNode) throw Error(p(162));
              e = a.stateNode;
              f = a.memoizedProps;
              try {
                e.nodeValue = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 3:
            ck(b, a);
            ek(a);
            if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
            break;
          case 4:
            ck(b, a);
            ek(a);
            break;
          case 13:
            ck(b, a);
            ek(a);
            e = a.child;
            e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
            d & 4 && ak(a);
            break;
          case 22:
            m = null !== c && null !== c.memoizedState;
            a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
            ek(a);
            if (d & 8192) {
              l = null !== a.memoizedState;
              if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
                for (q = V = m; null !== V; ) {
                  r = V;
                  y = r.child;
                  switch (r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r, r.return);
                      break;
                    case 1:
                      Lj(r, r.return);
                      var n = r.stateNode;
                      if ("function" === typeof n.componentWillUnmount) {
                        d = r;
                        c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Lj(r, r.return);
                      break;
                    case 22:
                      if (null !== r.memoizedState) {
                        gk(q);
                        continue;
                      }
                  }
                  null !== y ? (y.return = r, V = y) : gk(q);
                }
                m = m.sibling;
              }
              a: for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m) try {
                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                  } catch (t) {
                    W(a, a.return, t);
                  }
                } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a) break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a) break a;
                  m === q && (m = null);
                  q = q.return;
                }
                m === q && (m = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
            }
            break;
          case 19:
            ck(b, a);
            ek(a);
            d & 4 && ak(a);
            break;
          case 21:
            break;
          default:
            ck(
              b,
              a
            ), ek(a);
        }
      }
      function ek(a) {
        var b = a.flags;
        if (b & 2) {
          try {
            a: {
              for (var c = a.return; null !== c; ) {
                if (Tj(c)) {
                  var d = c;
                  break a;
                }
                c = c.return;
              }
              throw Error(p(160));
            }
            switch (d.tag) {
              case 5:
                var e = d.stateNode;
                d.flags & 32 && (ob(e, ""), d.flags &= -33);
                var f = Uj(a);
                Wj(a, f, e);
                break;
              case 3:
              case 4:
                var g = d.stateNode.containerInfo, h = Uj(a);
                Vj(a, h, g);
                break;
              default:
                throw Error(p(161));
            }
          } catch (k) {
            W(a, a.return, k);
          }
          a.flags &= -3;
        }
        b & 4096 && (a.flags &= -4097);
      }
      function hk(a, b, c) {
        V = a;
        ik(a, b, c);
      }
      function ik(a, b, c) {
        for (var d = 0 !== (a.mode & 1); null !== V; ) {
          var e = V, f = e.child;
          if (22 === e.tag && d) {
            var g = null !== e.memoizedState || Jj;
            if (!g) {
              var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
              h = Jj;
              var l = U;
              Jj = g;
              if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
              for (; null !== f; ) V = f, ik(f, b, c), f = f.sibling;
              V = e;
              Jj = h;
              U = l;
            }
            kk(a, b, c);
          } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a, b, c);
        }
      }
      function kk(a) {
        for (; null !== V; ) {
          var b = V;
          if (0 !== (b.flags & 8772)) {
            var c = b.alternate;
            try {
              if (0 !== (b.flags & 8772)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                  else {
                    var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f = b.updateQueue;
                  null !== f && sh(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child) switch (b.child.tag) {
                      case 5:
                        c = b.child.stateNode;
                        break;
                      case 1:
                        c = b.child.stateNode;
                    }
                    sh(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l = b.alternate;
                    if (null !== l) {
                      var m = l.memoizedState;
                      if (null !== m) {
                        var q = m.dehydrated;
                        null !== q && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
              U || b.flags & 512 && Rj(b);
            } catch (r) {
              W(b, b.return, r);
            }
          }
          if (b === a) {
            V = null;
            break;
          }
          c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function gk(a) {
        for (; null !== V; ) {
          var b = V;
          if (b === a) {
            V = null;
            break;
          }
          var c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function jk(a) {
        for (; null !== V; ) {
          var b = V;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Qj(4, b);
                } catch (k) {
                  W(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if ("function" === typeof d.componentDidMount) {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    W(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, g, k);
                }
            }
          } catch (k) {
            W(b, b.return, k);
          }
          if (b === a) {
            V = null;
            break;
          }
          var h = b.sibling;
          if (null !== h) {
            h.return = b.return;
            V = h;
            break;
          }
          V = b.return;
        }
      }
      var lk = Math.ceil;
      var mk = ua.ReactCurrentDispatcher;
      var nk = ua.ReactCurrentOwner;
      var ok = ua.ReactCurrentBatchConfig;
      var K = 0;
      var Q = null;
      var Y = null;
      var Z = 0;
      var fj = 0;
      var ej = Uf(0);
      var T = 0;
      var pk = null;
      var rh = 0;
      var qk = 0;
      var rk = 0;
      var sk = null;
      var tk = null;
      var fk = 0;
      var Gj = Infinity;
      var uk = null;
      var Oi = false;
      var Pi = null;
      var Ri = null;
      var vk = false;
      var wk = null;
      var xk = 0;
      var yk = 0;
      var zk = null;
      var Ak = -1;
      var Bk = 0;
      function R() {
        return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
      }
      function yi(a) {
        if (0 === (a.mode & 1)) return 1;
        if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
        a = C;
        if (0 !== a) return a;
        a = window.event;
        a = void 0 === a ? 16 : jd(a.type);
        return a;
      }
      function gi(a, b, c, d) {
        if (50 < yk) throw yk = 0, zk = null, Error(p(185));
        Ac(a, c, d);
        if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
      }
      function Dk(a, b) {
        var c = a.callbackNode;
        wc(a, b);
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
        else if (b = d & -d, a.callbackPriority !== b) {
          null != c && bc(c);
          if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c = null;
          else {
            switch (Dc(d)) {
              case 1:
                c = fc;
                break;
              case 4:
                c = gc;
                break;
              case 16:
                c = hc;
                break;
              case 536870912:
                c = jc;
                break;
              default:
                c = hc;
            }
            c = Fk(c, Gk.bind(null, a));
          }
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Gk(a, b) {
        Ak = -1;
        Bk = 0;
        if (0 !== (K & 6)) throw Error(p(327));
        var c = a.callbackNode;
        if (Hk() && a.callbackNode !== c) return null;
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) return null;
        if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
        else {
          b = d;
          var e = K;
          K |= 2;
          var f = Jk();
          if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
          do
            try {
              Lk();
              break;
            } catch (h) {
              Mk(a, h);
            }
          while (1);
          $g();
          mk.current = f;
          K = e;
          null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
        }
        if (0 !== b) {
          2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
          if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          if (6 === b) Ck(a, d);
          else {
            e = a.current.alternate;
            if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
            a.finishedWork = e;
            a.finishedLanes = d;
            switch (b) {
              case 0:
              case 1:
                throw Error(p(345));
              case 2:
                Pk(a, tk, uk);
                break;
              case 3:
                Ck(a, d);
                if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                  if (0 !== uc(a, 0)) break;
                  e = a.suspendedLanes;
                  if ((e & d) !== d) {
                    R();
                    a.pingedLanes |= a.suspendedLanes & e;
                    break;
                  }
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 4:
                Ck(a, d);
                if ((d & 4194240) === d) break;
                b = a.eventTimes;
                for (e = -1; 0 < d; ) {
                  var g = 31 - oc(d);
                  f = 1 << g;
                  g = b[g];
                  g > e && (e = g);
                  d &= ~f;
                }
                d = e;
                d = B() - d;
                d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
                if (10 < d) {
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 5:
                Pk(a, tk, uk);
                break;
              default:
                throw Error(p(329));
            }
          }
        }
        Dk(a, B());
        return a.callbackNode === c ? Gk.bind(null, a) : null;
      }
      function Nk(a, b) {
        var c = sk;
        a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
        a = Ik(a, b);
        2 !== a && (b = tk, tk = c, null !== b && Fj(b));
        return a;
      }
      function Fj(a) {
        null === tk ? tk = a : tk.push.apply(tk, a);
      }
      function Ok(a) {
        for (var b = a; ; ) {
          if (b.flags & 16384) {
            var c = b.updateQueue;
            if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e)) return false;
              } catch (g) {
                return false;
              }
            }
          }
          c = b.child;
          if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
          else {
            if (b === a) break;
            for (; null === b.sibling; ) {
              if (null === b.return || b.return === a) return true;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return true;
      }
      function Ck(a, b) {
        b &= ~rk;
        b &= ~qk;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - oc(b), d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Ek(a) {
        if (0 !== (K & 6)) throw Error(p(327));
        Hk();
        var b = uc(a, 0);
        if (0 === (b & 1)) return Dk(a, B()), null;
        var c = Ik(a, b);
        if (0 !== a.tag && 2 === c) {
          var d = xc(a);
          0 !== d && (b = d, c = Nk(a, d));
        }
        if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
        if (6 === c) throw Error(p(345));
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Pk(a, tk, uk);
        Dk(a, B());
        return null;
      }
      function Qk(a, b) {
        var c = K;
        K |= 1;
        try {
          return a(b);
        } finally {
          K = c, 0 === K && (Gj = B() + 500, fg && jg());
        }
      }
      function Rk(a) {
        null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
        var b = K;
        K |= 1;
        var c = ok.transition, d = C;
        try {
          if (ok.transition = null, C = 1, a) return a();
        } finally {
          C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
        }
      }
      function Hj() {
        fj = ej.current;
        E(ej);
      }
      function Kk(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && (a.timeoutHandle = -1, Gf(c));
        if (null !== Y) for (c = Y.return; null !== c; ) {
          var d = c;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              zh();
              E(Wf);
              E(H);
              Eh();
              break;
            case 5:
              Bh(d);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c = c.return;
        }
        Q = a;
        Y = a = Pg(a.current, null);
        Z = fj = b;
        T = 0;
        pk = null;
        rk = qk = rh = 0;
        tk = sk = null;
        if (null !== fh) {
          for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (null !== f) {
              var g = f.next;
              f.next = e;
              d.next = g;
            }
            c.pending = d;
          }
          fh = null;
        }
        return a;
      }
      function Mk(a, b) {
        do {
          var c = Y;
          try {
            $g();
            Fh.current = Rh;
            if (Ih) {
              for (var d = M.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              Ih = false;
            }
            Hh = 0;
            O = N = M = null;
            Jh = false;
            Kh = 0;
            nk.current = null;
            if (null === c || null === c.return) {
              T = 1;
              pk = b;
              Y = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              b = Z;
              h.flags |= 32768;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l = k, m = h, q = m.tag;
                if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r = m.alternate;
                  r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                }
                var y = Ui(g);
                if (null !== y) {
                  y.flags &= -257;
                  Vi(y, g, h, f, b);
                  y.mode & 1 && Si(f, l, b);
                  b = y;
                  k = l;
                  var n = b.updateQueue;
                  if (null === n) {
                    var t = /* @__PURE__ */ new Set();
                    t.add(k);
                    b.updateQueue = t;
                  } else n.add(k);
                  break a;
                } else {
                  if (0 === (b & 1)) {
                    Si(f, l, b);
                    tj();
                    break a;
                  }
                  k = Error(p(426));
                }
              } else if (I && h.mode & 1) {
                var J = Ui(g);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Vi(J, g, h, f, b);
                  Jg(Ji(k, h));
                  break a;
                }
              }
              f = k = Ji(k, h);
              4 !== T && (T = 2);
              null === sk ? sk = [f] : sk.push(f);
              f = g;
              do {
                switch (f.tag) {
                  case 3:
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var x = Ni(f, k, b);
                    ph(f, x);
                    break a;
                  case 1:
                    h = k;
                    var w = f.type, u = f.stateNode;
                    if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var F = Qi(f, h, b);
                      ph(f, F);
                      break a;
                    }
                }
                f = f.return;
              } while (null !== f);
            }
            Sk(c);
          } catch (na) {
            b = na;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Jk() {
        var a = mk.current;
        mk.current = Rh;
        return null === a ? Rh : a;
      }
      function tj() {
        if (0 === T || 3 === T || 2 === T) T = 4;
        null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
      }
      function Ik(a, b) {
        var c = K;
        K |= 2;
        var d = Jk();
        if (Q !== a || Z !== b) uk = null, Kk(a, b);
        do
          try {
            Tk();
            break;
          } catch (e) {
            Mk(a, e);
          }
        while (1);
        $g();
        K = c;
        mk.current = d;
        if (null !== Y) throw Error(p(261));
        Q = null;
        Z = 0;
        return T;
      }
      function Tk() {
        for (; null !== Y; ) Uk(Y);
      }
      function Lk() {
        for (; null !== Y && !cc(); ) Uk(Y);
      }
      function Uk(a) {
        var b = Vk(a.alternate, a, fj);
        a.memoizedProps = a.pendingProps;
        null === b ? Sk(a) : Y = b;
        nk.current = null;
      }
      function Sk(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 32768)) {
            if (c = Ej(c, b, fj), null !== c) {
              Y = c;
              return;
            }
          } else {
            c = Ij(c, b);
            if (null !== c) {
              c.flags &= 32767;
              Y = c;
              return;
            }
            if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
            else {
              T = 6;
              Y = null;
              return;
            }
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === T && (T = 5);
      }
      function Pk(a, b, c) {
        var d = C, e = ok.transition;
        try {
          ok.transition = null, C = 1, Wk(a, b, c, d);
        } finally {
          ok.transition = e, C = d;
        }
        return null;
      }
      function Wk(a, b, c, d) {
        do
          Hk();
        while (null !== wk);
        if (0 !== (K & 6)) throw Error(p(327));
        c = a.finishedWork;
        var e = a.finishedLanes;
        if (null === c) return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current) throw Error(p(177));
        a.callbackNode = null;
        a.callbackPriority = 0;
        var f = c.lanes | c.childLanes;
        Bc(a, f);
        a === Q && (Y = Q = null, Z = 0);
        0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
          Hk();
          return null;
        }));
        f = 0 !== (c.flags & 15990);
        if (0 !== (c.subtreeFlags & 15990) || f) {
          f = ok.transition;
          ok.transition = null;
          var g = C;
          C = 1;
          var h = K;
          K |= 4;
          nk.current = null;
          Oj(a, c);
          dk(c, a);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a.current = c;
          hk(c, a, e);
          dc();
          K = h;
          C = g;
          ok.transition = f;
        } else a.current = c;
        vk && (vk = false, wk = a, xk = e);
        f = a.pendingLanes;
        0 === f && (Ri = null);
        mc(c.stateNode, d);
        Dk(a, B());
        if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
        if (Oi) throw Oi = false, a = Pi, Pi = null, a;
        0 !== (xk & 1) && 0 !== a.tag && Hk();
        f = a.pendingLanes;
        0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
        jg();
        return null;
      }
      function Hk() {
        if (null !== wk) {
          var a = Dc(xk), b = ok.transition, c = C;
          try {
            ok.transition = null;
            C = 16 > a ? 16 : a;
            if (null === wk) var d = false;
            else {
              a = wk;
              wk = null;
              xk = 0;
              if (0 !== (K & 6)) throw Error(p(331));
              var e = K;
              K |= 4;
              for (V = a.current; null !== V; ) {
                var f = V, g = f.child;
                if (0 !== (V.flags & 16)) {
                  var h = f.deletions;
                  if (null !== h) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (V = l; null !== V; ) {
                        var m = V;
                        switch (m.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Pj(8, m, f);
                        }
                        var q = m.child;
                        if (null !== q) q.return = m, V = q;
                        else for (; null !== V; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          Sj(m);
                          if (m === l) {
                            V = null;
                            break;
                          }
                          if (null !== r) {
                            r.return = y;
                            V = r;
                            break;
                          }
                          V = y;
                        }
                      }
                    }
                    var n = f.alternate;
                    if (null !== n) {
                      var t = n.child;
                      if (null !== t) {
                        n.child = null;
                        do {
                          var J = t.sibling;
                          t.sibling = null;
                          t = J;
                        } while (null !== t);
                      }
                    }
                    V = f;
                  }
                }
                if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
                else b: for (; null !== V; ) {
                  f = V;
                  if (0 !== (f.flags & 2048)) switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f, f.return);
                  }
                  var x = f.sibling;
                  if (null !== x) {
                    x.return = f.return;
                    V = x;
                    break b;
                  }
                  V = f.return;
                }
              }
              var w = a.current;
              for (V = w; null !== V; ) {
                g = V;
                var u = g.child;
                if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
                else b: for (g = w; null !== V; ) {
                  h = V;
                  if (0 !== (h.flags & 2048)) try {
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h);
                    }
                  } catch (na) {
                    W(h, h.return, na);
                  }
                  if (h === g) {
                    V = null;
                    break b;
                  }
                  var F = h.sibling;
                  if (null !== F) {
                    F.return = h.return;
                    V = F;
                    break b;
                  }
                  V = h.return;
                }
              }
              K = e;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
              d = true;
            }
            return d;
          } finally {
            C = c, ok.transition = b;
          }
        }
        return false;
      }
      function Xk(a, b, c) {
        b = Ji(c, b);
        b = Ni(a, b, 1);
        a = nh(a, b, 1);
        b = R();
        null !== a && (Ac(a, 1, b), Dk(a, b));
      }
      function W(a, b, c) {
        if (3 === a.tag) Xk(a, a, c);
        else for (; null !== b; ) {
          if (3 === b.tag) {
            Xk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
              a = Ji(c, a);
              a = Qi(b, a, 1);
              b = nh(b, a, 1);
              a = R();
              null !== b && (Ac(b, 1, a), Dk(b, a));
              break;
            }
          }
          b = b.return;
        }
      }
      function Ti(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = R();
        a.pingedLanes |= a.suspendedLanes & c;
        Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
        Dk(a, b);
      }
      function Yk(a, b) {
        0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c = R();
        a = ih(a, b);
        null !== a && (Ac(a, b, c), Dk(a, c));
      }
      function uj(a) {
        var b = a.memoizedState, c = 0;
        null !== b && (c = b.retryLane);
        Yk(a, c);
      }
      function bk(a, b) {
        var c = 0;
        switch (a.tag) {
          case 13:
            var d = a.stateNode;
            var e = a.memoizedState;
            null !== e && (c = e.retryLane);
            break;
          case 19:
            d = a.stateNode;
            break;
          default:
            throw Error(p(314));
        }
        null !== d && d.delete(b);
        Yk(a, c);
      }
      var Vk;
      Vk = function(a, b, c) {
        if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
          dh = 0 !== (a.flags & 131072) ? true : false;
        }
        else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            var d = b.type;
            ij(a, b);
            a = b.pendingProps;
            var e = Yf(b, H.current);
            ch(b, c);
            e = Nh(null, b, d, a, e, c);
            var f = Sh();
            b.flags |= 1;
            "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
            return b;
          case 16:
            d = b.elementType;
            a: {
              ij(a, b);
              a = b.pendingProps;
              e = d._init;
              d = e(d._payload);
              b.type = d;
              e = b.tag = Zk(d);
              a = Ci(d, a);
              switch (e) {
                case 0:
                  b = cj(null, b, d, a, c);
                  break a;
                case 1:
                  b = hj(null, b, d, a, c);
                  break a;
                case 11:
                  b = Yi(null, b, d, a, c);
                  break a;
                case 14:
                  b = $i(null, b, d, Ci(d.type, a), c);
                  break a;
              }
              throw Error(p(
                306,
                d,
                ""
              ));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
          case 3:
            a: {
              kj(b);
              if (null === a) throw Error(p(387));
              d = b.pendingProps;
              f = b.memoizedState;
              e = f.element;
              lh(a, b);
              qh(b, d, null, c);
              var g = b.memoizedState;
              d = g.element;
              if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ji(Error(p(423)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ji(Error(p(424)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
              else {
                Ig();
                if (d === e) {
                  b = Zi(a, b, c);
                  break a;
                }
                Xi(a, b, d, c);
              }
              b = b.child;
            }
            return b;
          case 5:
            return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
          case 6:
            return null === a && Eg(b), null;
          case 13:
            return oj(a, b, c);
          case 4:
            return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
          case 7:
            return Xi(a, b, b.pendingProps, c), b.child;
          case 8:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 12:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              f = b.memoizedProps;
              g = e.value;
              G(Wg, d._currentValue);
              d._currentValue = g;
              if (null !== f) if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = Zi(a, b, c);
                  break a;
                }
              } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                var h = f.dependencies;
                if (null !== h) {
                  g = f.child;
                  for (var k = h.firstContext; null !== k; ) {
                    if (k.context === d) {
                      if (1 === f.tag) {
                        k = mh(-1, c & -c);
                        k.tag = 2;
                        var l = f.updateQueue;
                        if (null !== l) {
                          l = l.shared;
                          var m = l.pending;
                          null === m ? k.next = k : (k.next = m.next, m.next = k);
                          l.pending = k;
                        }
                      }
                      f.lanes |= c;
                      k = f.alternate;
                      null !== k && (k.lanes |= c);
                      bh(
                        f.return,
                        c,
                        b
                      );
                      h.lanes |= c;
                      break;
                    }
                    k = k.next;
                  }
                } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
                else if (18 === f.tag) {
                  g = f.return;
                  if (null === g) throw Error(p(341));
                  g.lanes |= c;
                  h = g.alternate;
                  null !== h && (h.lanes |= c);
                  bh(g, c, b);
                  g = f.sibling;
                } else g = f.child;
                if (null !== g) g.return = f;
                else for (g = f; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  f = g.sibling;
                  if (null !== f) {
                    f.return = g.return;
                    g = f;
                    break;
                  }
                  g = g.return;
                }
                f = g;
              }
              Xi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
          case 14:
            return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
          case 15:
            return bj(a, b, b.type, b.pendingProps, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
          case 19:
            return xj(a, b, c);
          case 22:
            return dj(a, b, c);
        }
        throw Error(p(156, b.tag));
      };
      function Fk(a, b) {
        return ac(a, b);
      }
      function $k(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a, b, c, d) {
        return new $k(a, b, c, d);
      }
      function aj(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function Zk(a) {
        if ("function" === typeof a) return aj(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Da) return 11;
          if (a === Ga) return 14;
        }
        return 2;
      }
      function Pg(a, b) {
        var c = a.alternate;
        null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
        c.flags = a.flags & 14680064;
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function Rg(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a) aj(a) && (g = 1);
        else if ("string" === typeof a) g = 5;
        else a: switch (a) {
          case ya:
            return Tg(c.children, e, f, b);
          case za:
            g = 8;
            e |= 8;
            break;
          case Aa:
            return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
          case Ea:
            return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
          case Fa:
            return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
          case Ia:
            return pj(c, e, f, b);
          default:
            if ("object" === typeof a && null !== a) switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d = null;
                break a;
            }
            throw Error(p(130, null == a ? a : typeof a, ""));
        }
        b = Bg(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Tg(a, b, c, d) {
        a = Bg(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function pj(a, b, c, d) {
        a = Bg(22, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        a.stateNode = { isHidden: false };
        return a;
      }
      function Qg(a, b, c) {
        a = Bg(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function Sg(a, b, c) {
        b = Bg(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b;
      }
      function al(a, b, c, d, e) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d;
        this.onRecoverableError = e;
        this.mutableSourceEagerHydrationData = null;
      }
      function bl(a, b, c, d, e, f, g, h, k) {
        a = new al(a, b, c, h, k);
        1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
        f = Bg(3, null, null, b);
        a.current = f;
        f.stateNode = a;
        f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        kh(f);
        return a;
      }
      function cl(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }
      function dl(a) {
        if (!a) return Vf;
        a = a._reactInternals;
        a: {
          if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (Zf(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b = b.return;
          } while (null !== b);
          throw Error(p(171));
        }
        if (1 === a.tag) {
          var c = a.type;
          if (Zf(c)) return bg(a, c, b);
        }
        return b;
      }
      function el(a, b, c, d, e, f, g, h, k) {
        a = bl(c, d, true, a, e, f, g, h, k);
        a.context = dl(null);
        c = a.current;
        d = R();
        e = yi(c);
        f = mh(d, e);
        f.callback = void 0 !== b && null !== b ? b : null;
        nh(c, f, e);
        a.current.lanes = e;
        Ac(a, e, d);
        Dk(a, d);
        return a;
      }
      function fl(a, b, c, d) {
        var e = b.current, f = R(), g = yi(e);
        c = dl(c);
        null === b.context ? b.context = c : b.pendingContext = c;
        b = mh(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        a = nh(e, b, g);
        null !== a && (gi(a, e, g, f), oh(a, e, g));
        return g;
      }
      function gl(a) {
        a = a.current;
        if (!a.child) return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function hl(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function il(a, b) {
        hl(a, b);
        (a = a.alternate) && hl(a, b);
      }
      function jl() {
        return null;
      }
      var kl = "function" === typeof reportError ? reportError : function(a) {
        console.error(a);
      };
      function ll(a) {
        this._internalRoot = a;
      }
      ml.prototype.render = ll.prototype.render = function(a) {
        var b = this._internalRoot;
        if (null === b) throw Error(p(409));
        fl(a, b, null, null);
      };
      ml.prototype.unmount = ll.prototype.unmount = function() {
        var a = this._internalRoot;
        if (null !== a) {
          this._internalRoot = null;
          var b = a.containerInfo;
          Rk(function() {
            fl(null, a, null, null);
          });
          b[uf] = null;
        }
      };
      function ml(a) {
        this._internalRoot = a;
      }
      ml.prototype.unstable_scheduleHydration = function(a) {
        if (a) {
          var b = Hc();
          a = { blockedOn: null, target: a, priority: b };
          for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
          Qc.splice(c, 0, a);
          0 === c && Vc(a);
        }
      };
      function nl(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
      }
      function ol(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
      }
      function pl() {
      }
      function ql(a, b, c, d, e) {
        if (e) {
          if ("function" === typeof d) {
            var f = d;
            d = function() {
              var a2 = gl(g);
              f.call(a2);
            };
          }
          var g = el(b, d, a, 0, null, false, false, "", pl);
          a._reactRootContainer = g;
          a[uf] = g.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Rk();
          return g;
        }
        for (; e = a.lastChild; ) a.removeChild(e);
        if ("function" === typeof d) {
          var h = d;
          d = function() {
            var a2 = gl(k);
            h.call(a2);
          };
        }
        var k = bl(a, 0, false, null, null, false, false, "", pl);
        a._reactRootContainer = k;
        a[uf] = k.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Rk(function() {
          fl(b, k, c, d);
        });
        return k;
      }
      function rl(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f;
          if ("function" === typeof e) {
            var h = e;
            e = function() {
              var a2 = gl(g);
              h.call(a2);
            };
          }
          fl(b, g, a, e);
        } else g = ql(c, b, a, e, d);
        return gl(g);
      }
      Ec = function(a) {
        switch (a.tag) {
          case 3:
            var b = a.stateNode;
            if (b.current.memoizedState.isDehydrated) {
              var c = tc(b.pendingLanes);
              0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
            }
            break;
          case 13:
            Rk(function() {
              var b2 = ih(a, 1);
              if (null !== b2) {
                var c2 = R();
                gi(b2, a, 1, c2);
              }
            }), il(a, 1);
        }
      };
      Fc = function(a) {
        if (13 === a.tag) {
          var b = ih(a, 134217728);
          if (null !== b) {
            var c = R();
            gi(b, a, 134217728, c);
          }
          il(a, 134217728);
        }
      };
      Gc = function(a) {
        if (13 === a.tag) {
          var b = yi(a), c = ih(a, b);
          if (null !== c) {
            var d = R();
            gi(c, a, b, d);
          }
          il(a, b);
        }
      };
      Hc = function() {
        return C;
      };
      Ic = function(a, b) {
        var c = C;
        try {
          return C = a, b();
        } finally {
          C = c;
        }
      };
      yb = function(a, b, c) {
        switch (b) {
          case "input":
            bb(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; ) c = c.parentNode;
              c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e) throw Error(p(90));
                  Wa(d);
                  bb(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            b = c.value, null != b && fb(a, !!c.multiple, b, false);
        }
      };
      Gb = Qk;
      Hb = Rk;
      var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] };
      var tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
      var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
        a = Zb(a);
        return null === a ? null : a.stateNode;
      }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!vl.isDisabled && vl.supportsFiber) try {
          kc = vl.inject(ul), lc = vl;
        } catch (a) {
        }
      }
      var vl;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
      exports.createPortal = function(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!nl(b)) throw Error(p(200));
        return cl(a, b, null, c);
      };
      exports.createRoot = function(a, b) {
        if (!nl(a)) throw Error(p(299));
        var c = false, d = "", e = kl;
        null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
        b = bl(a, 1, false, null, null, c, false, d, e);
        a[uf] = b.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        return new ll(b);
      };
      exports.findDOMNode = function(a) {
        if (null == a) return null;
        if (1 === a.nodeType) return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render) throw Error(p(188));
          a = Object.keys(a).join(",");
          throw Error(p(268, a));
        }
        a = Zb(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      exports.flushSync = function(a) {
        return Rk(a);
      };
      exports.hydrate = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, true, c);
      };
      exports.hydrateRoot = function(a, b, c) {
        if (!nl(a)) throw Error(p(405));
        var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
        null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
        b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
        a[uf] = b.current;
        sf(a);
        if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
          c,
          e
        );
        return new ml(b);
      };
      exports.render = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, false, c);
      };
      exports.unmountComponentAtNode = function(a) {
        if (!ol(a)) throw Error(p(40));
        return a._reactRootContainer ? (Rk(function() {
          rl(null, null, a, false, function() {
            a._reactRootContainer = null;
            a[uf] = null;
          });
        }), true) : false;
      };
      exports.unstable_batchedUpdates = Qk;
      exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
        if (!ol(c)) throw Error(p(200));
        if (null == a || void 0 === a._reactInternals) throw Error(p(38));
        return rl(a, b, c, false, d);
      };
      exports.version = "18.3.1-next-f1338f8080-20240426";
    }
  });

  // ../../node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "../../node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/react-dom/client.js
  var require_client = __commonJS({
    "../../node_modules/react-dom/client.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var m = require_react_dom();
      if (true) {
        exports.createRoot = m.createRoot;
        exports.hydrateRoot = m.hydrateRoot;
      } else {
        i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.createRoot(c, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c, h, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.hydrateRoot(c, h, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
      }
      var i;
    }
  });

  // ../../node_modules/react-router/node_modules/cookie/dist/index.js
  var require_dist = __commonJS({
    "../../node_modules/react-router/node_modules/cookie/dist/index.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = parse2;
      exports.serialize = serialize2;
      var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
      var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
      var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
      var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
      var __toString = Object.prototype.toString;
      var NullObject = /* @__PURE__ */ (() => {
        const C = function() {
        };
        C.prototype = /* @__PURE__ */ Object.create(null);
        return C;
      })();
      function parse2(str, options) {
        const obj = new NullObject();
        const len = str.length;
        if (len < 2)
          return obj;
        const dec = options?.decode || decode;
        let index = 0;
        do {
          const eqIdx = str.indexOf("=", index);
          if (eqIdx === -1)
            break;
          const colonIdx = str.indexOf(";", index);
          const endIdx = colonIdx === -1 ? len : colonIdx;
          if (eqIdx > endIdx) {
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
          }
          const keyStartIdx = startIndex(str, index, eqIdx);
          const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
          const key = str.slice(keyStartIdx, keyEndIdx);
          if (obj[key] === void 0) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value;
          }
          index = endIdx + 1;
        } while (index < len);
        return obj;
      }
      function startIndex(str, index, max) {
        do {
          const code = str.charCodeAt(index);
          if (code !== 32 && code !== 9)
            return index;
        } while (++index < max);
        return max;
      }
      function endIndex(str, index, min) {
        while (index > min) {
          const code = str.charCodeAt(--index);
          if (code !== 32 && code !== 9)
            return index + 1;
        }
        return min;
      }
      function serialize2(name, val, options) {
        const enc = options?.encode || encodeURIComponent;
        if (!cookieNameRegExp.test(name)) {
          throw new TypeError(`argument name is invalid: ${name}`);
        }
        const value = enc(val);
        if (!cookieValueRegExp.test(value)) {
          throw new TypeError(`argument val is invalid: ${val}`);
        }
        let str = name + "=" + value;
        if (!options)
          return str;
        if (options.maxAge !== void 0) {
          if (!Number.isInteger(options.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
          }
          str += "; Max-Age=" + options.maxAge;
        }
        if (options.domain) {
          if (!domainValueRegExp.test(options.domain)) {
            throw new TypeError(`option domain is invalid: ${options.domain}`);
          }
          str += "; Domain=" + options.domain;
        }
        if (options.path) {
          if (!pathValueRegExp.test(options.path)) {
            throw new TypeError(`option path is invalid: ${options.path}`);
          }
          str += "; Path=" + options.path;
        }
        if (options.expires) {
          if (!isDate2(options.expires) || !Number.isFinite(options.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options.expires}`);
          }
          str += "; Expires=" + options.expires.toUTCString();
        }
        if (options.httpOnly) {
          str += "; HttpOnly";
        }
        if (options.secure) {
          str += "; Secure";
        }
        if (options.partitioned) {
          str += "; Partitioned";
        }
        if (options.priority) {
          const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : void 0;
          switch (priority) {
            case "low":
              str += "; Priority=Low";
              break;
            case "medium":
              str += "; Priority=Medium";
              break;
            case "high":
              str += "; Priority=High";
              break;
            default:
              throw new TypeError(`option priority is invalid: ${options.priority}`);
          }
        }
        if (options.sameSite) {
          const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
          switch (sameSite) {
            case true:
            case "strict":
              str += "; SameSite=Strict";
              break;
            case "lax":
              str += "; SameSite=Lax";
              break;
            case "none":
              str += "; SameSite=None";
              break;
            default:
              throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
          }
        }
        return str;
      }
      function decode(str) {
        if (str.indexOf("%") === -1)
          return str;
        try {
          return decodeURIComponent(str);
        } catch (e) {
          return str;
        }
      }
      function isDate2(val) {
        return __toString.call(val) === "[object Date]";
      }
    }
  });

  // ../../node_modules/react/cjs/react-jsx-runtime.production.min.js
  var require_react_jsx_runtime_production_min = __commonJS({
    "../../node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var f = require_react();
      var k = Symbol.for("react.element");
      var l = Symbol.for("react.fragment");
      var m = Object.prototype.hasOwnProperty;
      var n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
      var p = { key: true, ref: true, __self: true, __source: true };
      function q(c, a, g) {
        var b, d = {}, e = null, h = null;
        void 0 !== g && (e = "" + g);
        void 0 !== a.key && (e = "" + a.key);
        void 0 !== a.ref && (h = a.ref);
        for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
        if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
        return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
      }
      exports.Fragment = l;
      exports.jsx = q;
      exports.jsxs = q;
    }
  });

  // ../../node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "../../node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      if (true) {
        module.exports = require_react_jsx_runtime_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js
  var require_use_sync_external_store_shim_production = __commonJS({
    "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var React139 = require_react();
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      var useState28 = React139.useState;
      var useEffect29 = React139.useEffect;
      var useLayoutEffect6 = React139.useLayoutEffect;
      var useDebugValue2 = React139.useDebugValue;
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        var value = getSnapshot(), _useState = useState28({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect6(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect29(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue2(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React139.useSyncExternalStore ? React139.useSyncExternalStore : shim;
    }
  });

  // ../../node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "../../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      if (true) {
        module.exports = require_use_sync_external_store_shim_production();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js
  var require_with_selector_production = __commonJS({
    "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var React139 = require_react();
      var shim = require_shim();
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      var useSyncExternalStore = shim.useSyncExternalStore;
      var useRef31 = React139.useRef;
      var useEffect29 = React139.useEffect;
      var useMemo17 = React139.useMemo;
      var useDebugValue2 = React139.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef31(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo17(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect29(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue2(value);
        return value;
      };
    }
  });

  // ../../node_modules/use-sync-external-store/shim/with-selector.js
  var require_with_selector = __commonJS({
    "../../node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      if (true) {
        module.exports = require_with_selector_production();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/uri-js/dist/es5/uri.all.js
  var require_uri_all = __commonJS({
    "../../node_modules/uri-js/dist/es5/uri.all.js"(exports, module) {
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
      })(exports, function(exports2) {
        "use strict";
        function merge() {
          for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
            sets[_key] = arguments[_key];
          }
          if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for (var x = 1; x < xl; ++x) {
              sets[x] = sets[x].slice(1, -1);
            }
            sets[xl] = sets[xl].slice(1);
            return sets.join("");
          } else {
            return sets[0];
          }
        }
        function subexp(str) {
          return "(?:" + str + ")";
        }
        function typeOf(o) {
          return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
        }
        function toUpperCase(str) {
          return str.toUpperCase();
        }
        function toArray(obj) {
          return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
        }
        function assign(target, source) {
          var obj = target;
          if (source) {
            for (var key in source) {
              obj[key] = source[key];
            }
          }
          return obj;
        }
        function buildExps(isIRI2) {
          var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
          return {
            NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
            OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
            //RFC 6874, with relaxed parsing rules
          };
        }
        var URI_PROTOCOL = buildExps(false);
        var IRI_PROTOCOL = buildExps(true);
        var slicedToArray = /* @__PURE__ */ function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var toConsumableArray = function(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
            return arr2;
          } else {
            return Array.from(arr);
          }
        };
        var maxInt = 2147483647;
        var base = 36;
        var tMin = 1;
        var tMax = 26;
        var skew = 38;
        var damp = 700;
        var initialBias = 72;
        var initialN = 128;
        var delimiter = "-";
        var regexPunycode = /^xn--/;
        var regexNonASCII = /[^\0-\x7E]/;
        var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
        var errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        };
        var baseMinusTMin = base - tMin;
        var floor = Math.floor;
        var stringFromCharCode = String.fromCharCode;
        function error$1(type) {
          throw new RangeError(errors[type]);
        }
        function map(array, fn) {
          var result = [];
          var length = array.length;
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [];
          var counter = 0;
          var length = string.length;
          while (counter < length) {
            var value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              var extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        var ucs2encode = function ucs2encode2(array) {
          return String.fromCodePoint.apply(String, toConsumableArray(array));
        };
        var basicToDigit = function basicToDigit2(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        };
        var digitToBasic = function digitToBasic2(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        };
        var adapt = function adapt2(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (
            ;
            /* no initialization */
            delta > baseMinusTMin * tMax >> 1;
            k += base
          ) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        };
        var decode = function decode2(input) {
          var output = [];
          var inputLength = input.length;
          var i = 0;
          var n = initialN;
          var bias = initialBias;
          var basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (var j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error$1("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            var oldi = i;
            for (
              var w = 1, k = base;
              ;
              /* no condition */
              k += base
            ) {
              if (index >= inputLength) {
                error$1("invalid-input");
              }
              var digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error$1("overflow");
              }
              i += digit * w;
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (digit < t) {
                break;
              }
              var baseMinusT = base - t;
              if (w > floor(maxInt / baseMinusT)) {
                error$1("overflow");
              }
              w *= baseMinusT;
            }
            var out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            if (floor(i / out) > maxInt - n) {
              error$1("overflow");
            }
            n += floor(i / out);
            i %= out;
            output.splice(i++, 0, n);
          }
          return String.fromCodePoint.apply(String, output);
        };
        var encode = function encode2(input) {
          var output = [];
          input = ucs2decode(input);
          var inputLength = input.length;
          var n = initialN;
          var delta = 0;
          var bias = initialBias;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _currentValue2 = _step.value;
              if (_currentValue2 < 128) {
                output.push(stringFromCharCode(_currentValue2));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          var basicLength = output.length;
          var handledCPCount = basicLength;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            var m = maxInt;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var currentValue = _step2.value;
                if (currentValue >= n && currentValue < m) {
                  m = currentValue;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error$1("overflow");
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = void 0;
            try {
              for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _currentValue = _step3.value;
                if (_currentValue < n && ++delta > maxInt) {
                  error$1("overflow");
                }
                if (_currentValue == n) {
                  var q = delta;
                  for (
                    var k = base;
                    ;
                    /* no condition */
                    k += base
                  ) {
                    var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q < t) {
                      break;
                    }
                    var qMinusT = q - t;
                    var baseMinusT = base - t;
                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = floor(qMinusT / baseMinusT);
                  }
                  output.push(stringFromCharCode(digitToBasic(q, 0)));
                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                  delta = 0;
                  ++handledCPCount;
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
            ++delta;
            ++n;
          }
          return output.join("");
        };
        var toUnicode = function toUnicode2(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        };
        var toASCII = function toASCII2(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
          });
        };
        var punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          "version": "2.1.0",
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode,
          "encode": encode,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        var SCHEMES = {};
        function pctEncChar(chr) {
          var c = chr.charCodeAt(0);
          var e = void 0;
          if (c < 16) e = "%0" + c.toString(16).toUpperCase();
          else if (c < 128) e = "%" + c.toString(16).toUpperCase();
          else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
          else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
          return e;
        }
        function pctDecChars(str) {
          var newStr = "";
          var i = 0;
          var il = str.length;
          while (i < il) {
            var c = parseInt(str.substr(i + 1, 2), 16);
            if (c < 128) {
              newStr += String.fromCharCode(c);
              i += 3;
            } else if (c >= 194 && c < 224) {
              if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
              } else {
                newStr += str.substr(i, 6);
              }
              i += 6;
            } else if (c >= 224) {
              if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
              } else {
                newStr += str.substr(i, 9);
              }
              i += 9;
            } else {
              newStr += str.substr(i, 3);
              i += 3;
            }
          }
          return newStr;
        }
        function _normalizeComponentEncoding(components, protocol) {
          function decodeUnreserved2(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(protocol.UNRESERVED) ? str : decStr;
          }
          if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
          if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          return components;
        }
        function _stripLeadingZeros(str) {
          return str.replace(/^0*(.*)/, "$1") || "0";
        }
        function _normalizeIPv4(host, protocol) {
          var matches = host.match(protocol.IPV4ADDRESS) || [];
          var _matches = slicedToArray(matches, 2), address = _matches[1];
          if (address) {
            return address.split(".").map(_stripLeadingZeros).join(".");
          } else {
            return host;
          }
        }
        function _normalizeIPv6(host, protocol) {
          var matches = host.match(protocol.IPV6ADDRESS) || [];
          var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
          if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for (var x = 0; x < fieldCount; ++x) {
              fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
            }
            if (isLastFieldIPv4Address) {
              fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            }
            var allZeroFields = fields.reduce(function(acc, field, index) {
              if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                  lastLongest.length++;
                } else {
                  acc.push({ index, length: 1 });
                }
              }
              return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function(a, b) {
              return b.length - a.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
              var newFirst = fields.slice(0, longestZeroFields.index);
              var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
              newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else {
              newHost = fields.join(":");
            }
            if (zone) {
              newHost += "%" + zone;
            }
            return newHost;
          } else {
            return host;
          }
        }
        var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
        var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
        function parse2(uriString) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var components = {};
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
          var matches = uriString.match(URI_PARSE);
          if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
              components.scheme = matches[1];
              components.userinfo = matches[3];
              components.host = matches[4];
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = matches[7];
              components.fragment = matches[8];
              if (isNaN(components.port)) {
                components.port = matches[5];
              }
            } else {
              components.scheme = matches[1] || void 0;
              components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
              components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
              components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
              if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
              }
            }
            if (components.host) {
              components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            }
            if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
              components.reference = "same-document";
            } else if (components.scheme === void 0) {
              components.reference = "relative";
            } else if (components.fragment === void 0) {
              components.reference = "absolute";
            } else {
              components.reference = "uri";
            }
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
              components.error = components.error || "URI is not a " + options.reference + " reference.";
            }
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
              if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                try {
                  components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                  components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
              }
              _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else {
              _normalizeComponentEncoding(components, protocol);
            }
            if (schemeHandler && schemeHandler.parse) {
              schemeHandler.parse(components, options);
            }
          } else {
            components.error = components.error || "URI can not be parsed.";
          }
          return components;
        }
        function _recomposeAuthority(components, options) {
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          if (components.userinfo !== void 0) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
          }
          if (components.host !== void 0) {
            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
              return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            }));
          }
          if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
          }
          return uriTokens.length ? uriTokens.join("") : void 0;
        }
        var RDS1 = /^\.\.?\//;
        var RDS2 = /^\/\.(\/|$)/;
        var RDS3 = /^\/\.\.(\/|$)/;
        var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
        function removeDotSegments(input) {
          var output = [];
          while (input.length) {
            if (input.match(RDS1)) {
              input = input.replace(RDS1, "");
            } else if (input.match(RDS2)) {
              input = input.replace(RDS2, "/");
            } else if (input.match(RDS3)) {
              input = input.replace(RDS3, "/");
              output.pop();
            } else if (input === "." || input === "..") {
              input = "";
            } else {
              var im = input.match(RDS5);
              if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
              } else {
                throw new Error("Unexpected dot segment condition");
              }
            }
          }
          return output.join("");
        }
        function serialize2(components) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
          if (components.host) {
            if (protocol.IPV6ADDRESS.test(components.host)) {
            } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
              try {
                components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
            }
          }
          _normalizeComponentEncoding(components, protocol);
          if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
          }
          var authority = _recomposeAuthority(components, options);
          if (authority !== void 0) {
            if (options.reference !== "suffix") {
              uriTokens.push("//");
            }
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") {
              uriTokens.push("/");
            }
          }
          if (components.path !== void 0) {
            var s = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
              s = removeDotSegments(s);
            }
            if (authority === void 0) {
              s = s.replace(/^\/\//, "/%2F");
            }
            uriTokens.push(s);
          }
          if (components.query !== void 0) {
            uriTokens.push("?");
            uriTokens.push(components.query);
          }
          if (components.fragment !== void 0) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
          }
          return uriTokens.join("");
        }
        function resolveComponents(base2, relative) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var skipNormalization = arguments[3];
          var target = {};
          if (!skipNormalization) {
            base2 = parse2(serialize2(base2, options), options);
            relative = parse2(serialize2(relative, options), options);
          }
          options = options || {};
          if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
              target.userinfo = relative.userinfo;
              target.host = relative.host;
              target.port = relative.port;
              target.path = removeDotSegments(relative.path || "");
              target.query = relative.query;
            } else {
              if (!relative.path) {
                target.path = base2.path;
                if (relative.query !== void 0) {
                  target.query = relative.query;
                } else {
                  target.query = base2.query;
                }
              } else {
                if (relative.path.charAt(0) === "/") {
                  target.path = removeDotSegments(relative.path);
                } else {
                  if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                    target.path = "/" + relative.path;
                  } else if (!base2.path) {
                    target.path = relative.path;
                  } else {
                    target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                  }
                  target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
              }
              target.userinfo = base2.userinfo;
              target.host = base2.host;
              target.port = base2.port;
            }
            target.scheme = base2.scheme;
          }
          target.fragment = relative.fragment;
          return target;
        }
        function resolve(baseURI, relativeURI, options) {
          var schemelessOptions = assign({ scheme: "null" }, options);
          return serialize2(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
        }
        function normalize(uri, options) {
          if (typeof uri === "string") {
            uri = serialize2(parse2(uri, options), options);
          } else if (typeOf(uri) === "object") {
            uri = parse2(serialize2(uri, options), options);
          }
          return uri;
        }
        function equal(uriA, uriB, options) {
          if (typeof uriA === "string") {
            uriA = serialize2(parse2(uriA, options), options);
          } else if (typeOf(uriA) === "object") {
            uriA = serialize2(uriA, options);
          }
          if (typeof uriB === "string") {
            uriB = serialize2(parse2(uriB, options), options);
          } else if (typeOf(uriB) === "object") {
            uriB = serialize2(uriB, options);
          }
          return uriA === uriB;
        }
        function escapeComponent(str, options) {
          return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
        }
        function unescapeComponent(str, options) {
          return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
        }
        var handler = {
          scheme: "http",
          domainHost: true,
          parse: function parse3(components, options) {
            if (!components.host) {
              components.error = components.error || "HTTP URIs must have a host.";
            }
            return components;
          },
          serialize: function serialize3(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            if (components.port === (secure ? 443 : 80) || components.port === "") {
              components.port = void 0;
            }
            if (!components.path) {
              components.path = "/";
            }
            return components;
          }
        };
        var handler$1 = {
          scheme: "https",
          domainHost: handler.domainHost,
          parse: handler.parse,
          serialize: handler.serialize
        };
        function isSecure(wsComponents) {
          return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
        }
        var handler$2 = {
          scheme: "ws",
          domainHost: true,
          parse: function parse3(components, options) {
            var wsComponents = components;
            wsComponents.secure = isSecure(wsComponents);
            wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
            wsComponents.path = void 0;
            wsComponents.query = void 0;
            return wsComponents;
          },
          serialize: function serialize3(wsComponents, options) {
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
              wsComponents.port = void 0;
            }
            if (typeof wsComponents.secure === "boolean") {
              wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
              wsComponents.secure = void 0;
            }
            if (wsComponents.resourceName) {
              var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
              wsComponents.path = path && path !== "/" ? path : void 0;
              wsComponents.query = query;
              wsComponents.resourceName = void 0;
            }
            wsComponents.fragment = void 0;
            return wsComponents;
          }
        };
        var handler$3 = {
          scheme: "wss",
          domainHost: handler$2.domainHost,
          parse: handler$2.parse,
          serialize: handler$2.serialize
        };
        var O = {};
        var isIRI = true;
        var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
        var HEXDIG$$ = "[0-9A-Fa-f]";
        var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
        var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
        var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
        var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
        var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
        var UNRESERVED = new RegExp(UNRESERVED$$, "g");
        var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
        var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
        var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
        var NOT_HFVALUE = NOT_HFNAME;
        function decodeUnreserved(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(UNRESERVED) ? str : decStr;
        }
        var handler$4 = {
          scheme: "mailto",
          parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = void 0;
            if (mailtoComponents.query) {
              var unknownHeaders = false;
              var headers = {};
              var hfields = mailtoComponents.query.split("&");
              for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                  case "to":
                    var toAddrs = hfield[1].split(",");
                    for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                      to.push(toAddrs[_x]);
                    }
                    break;
                  case "subject":
                    mailtoComponents.subject = unescapeComponent(hfield[1], options);
                    break;
                  case "body":
                    mailtoComponents.body = unescapeComponent(hfield[1], options);
                    break;
                  default:
                    unknownHeaders = true;
                    headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                    break;
                }
              }
              if (unknownHeaders) mailtoComponents.headers = headers;
            }
            mailtoComponents.query = void 0;
            for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
              var addr = to[_x2].split("@");
              addr[0] = unescapeComponent(addr[0]);
              if (!options.unicodeSupport) {
                try {
                  addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                  mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
              } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
              }
              to[_x2] = addr.join("@");
            }
            return mailtoComponents;
          },
          serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
              for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                try {
                  domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                  components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
              }
              components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
            var fields = [];
            for (var name in headers) {
              if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
              }
            }
            if (fields.length) {
              components.query = fields.join("&");
            }
            return components;
          }
        };
        var URN_PARSE = /^([^\:]+)\:(.*)/;
        var handler$5 = {
          scheme: "urn",
          parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
              var scheme = options.scheme || urnComponents.scheme || "urn";
              var nid = matches[1].toLowerCase();
              var nss = matches[2];
              var urnScheme = scheme + ":" + (options.nid || nid);
              var schemeHandler = SCHEMES[urnScheme];
              urnComponents.nid = nid;
              urnComponents.nss = nss;
              urnComponents.path = void 0;
              if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
              }
            } else {
              urnComponents.error = urnComponents.error || "URN can not be parsed.";
            }
            return urnComponents;
          },
          serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) {
              urnComponents = schemeHandler.serialize(urnComponents, options);
            }
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
          }
        };
        var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
        var handler$6 = {
          scheme: "urn:uuid",
          parse: function parse3(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = void 0;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
              uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            }
            return uuidComponents;
          },
          serialize: function serialize3(uuidComponents, options) {
            var urnComponents = uuidComponents;
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
          }
        };
        SCHEMES[handler.scheme] = handler;
        SCHEMES[handler$1.scheme] = handler$1;
        SCHEMES[handler$2.scheme] = handler$2;
        SCHEMES[handler$3.scheme] = handler$3;
        SCHEMES[handler$4.scheme] = handler$4;
        SCHEMES[handler$5.scheme] = handler$5;
        SCHEMES[handler$6.scheme] = handler$6;
        exports2.SCHEMES = SCHEMES;
        exports2.pctEncChar = pctEncChar;
        exports2.pctDecChars = pctDecChars;
        exports2.parse = parse2;
        exports2.removeDotSegments = removeDotSegments;
        exports2.serialize = serialize2;
        exports2.resolveComponents = resolveComponents;
        exports2.resolve = resolve;
        exports2.normalize = normalize;
        exports2.equal = equal;
        exports2.escapeComponent = escapeComponent;
        exports2.unescapeComponent = unescapeComponent;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../../node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "../../node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function equal(a, b) {
        if (a === b) return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor) return false;
          var length, i, keys;
          if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for (i = length; i-- !== 0; )
              if (!equal(a[i], b[i])) return false;
            return true;
          }
          if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
          keys = Object.keys(a);
          length = keys.length;
          if (length !== Object.keys(b).length) return false;
          for (i = length; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
          for (i = length; i-- !== 0; ) {
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
          }
          return true;
        }
        return a !== a && b !== b;
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/ucs2length.js
  var require_ucs2length = __commonJS({
    "../../node_modules/ajv/lib/compile/ucs2length.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function ucs2length(str) {
        var length = 0, len = str.length, pos = 0, value;
        while (pos < len) {
          length++;
          value = str.charCodeAt(pos++);
          if (value >= 55296 && value <= 56319 && pos < len) {
            value = str.charCodeAt(pos);
            if ((value & 64512) == 56320) pos++;
          }
        }
        return length;
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/util.js
  var require_util = __commonJS({
    "../../node_modules/ajv/lib/compile/util.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = {
        copy,
        checkDataType,
        checkDataTypes,
        coerceToTypes,
        toHash,
        getProperty,
        escapeQuotes,
        equal: require_fast_deep_equal(),
        ucs2length: require_ucs2length(),
        varOccurences,
        varReplace,
        schemaHasRules,
        schemaHasRulesExcept,
        schemaUnknownRules,
        toQuotedString,
        getPathExpr,
        getPath,
        getData,
        unescapeFragment,
        unescapeJsonPointer,
        escapeFragment,
        escapeJsonPointer
      };
      function copy(o, to) {
        to = to || {};
        for (var key in o) to[key] = o[key];
        return to;
      }
      function checkDataType(dataType, data2, strictNumbers, negate) {
        var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK2 = negate ? "!" : "", NOT = negate ? "" : "!";
        switch (dataType) {
          case "null":
            return data2 + EQUAL + "null";
          case "array":
            return OK2 + "Array.isArray(" + data2 + ")";
          case "object":
            return "(" + OK2 + data2 + AND + "typeof " + data2 + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data2 + "))";
          case "integer":
            return "(typeof " + data2 + EQUAL + '"number"' + AND + NOT + "(" + data2 + " % 1)" + AND + data2 + EQUAL + data2 + (strictNumbers ? AND + OK2 + "isFinite(" + data2 + ")" : "") + ")";
          case "number":
            return "(typeof " + data2 + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK2 + "isFinite(" + data2 + ")" : "") + ")";
          default:
            return "typeof " + data2 + EQUAL + '"' + dataType + '"';
        }
      }
      function checkDataTypes(dataTypes, data2, strictNumbers) {
        switch (dataTypes.length) {
          case 1:
            return checkDataType(dataTypes[0], data2, strictNumbers, true);
          default:
            var code = "";
            var types = toHash(dataTypes);
            if (types.array && types.object) {
              code = types.null ? "(" : "(!" + data2 + " || ";
              code += "typeof " + data2 + ' !== "object")';
              delete types.null;
              delete types.array;
              delete types.object;
            }
            if (types.number) delete types.integer;
            for (var t in types)
              code += (code ? " && " : "") + checkDataType(t, data2, strictNumbers, true);
            return code;
        }
      }
      var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
      function coerceToTypes(optionCoerceTypes, dataTypes) {
        if (Array.isArray(dataTypes)) {
          var types = [];
          for (var i = 0; i < dataTypes.length; i++) {
            var t = dataTypes[i];
            if (COERCE_TO_TYPES[t]) types[types.length] = t;
            else if (optionCoerceTypes === "array" && t === "array") types[types.length] = t;
          }
          if (types.length) return types;
        } else if (COERCE_TO_TYPES[dataTypes]) {
          return [dataTypes];
        } else if (optionCoerceTypes === "array" && dataTypes === "array") {
          return ["array"];
        }
      }
      function toHash(arr) {
        var hash = {};
        for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
        return hash;
      }
      var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      var SINGLE_QUOTE = /'|\\/g;
      function getProperty(key) {
        return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
      }
      function escapeQuotes(str) {
        return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
      }
      function varOccurences(str, dataVar) {
        dataVar += "[^0-9]";
        var matches = str.match(new RegExp(dataVar, "g"));
        return matches ? matches.length : 0;
      }
      function varReplace(str, dataVar, expr) {
        dataVar += "([^0-9])";
        expr = expr.replace(/\$/g, "$$$$");
        return str.replace(new RegExp(dataVar, "g"), expr + "$1");
      }
      function schemaHasRules(schema, rules) {
        if (typeof schema == "boolean") return !schema;
        for (var key in schema) if (rules[key]) return true;
      }
      function schemaHasRulesExcept(schema, rules, exceptKeyword) {
        if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
        for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
      }
      function schemaUnknownRules(schema, rules) {
        if (typeof schema == "boolean") return;
        for (var key in schema) if (!rules[key]) return key;
      }
      function toQuotedString(str) {
        return "'" + escapeQuotes(str) + "'";
      }
      function getPathExpr(currentPath, expr, jsonPointers, isNumber2) {
        var path = jsonPointers ? "'/' + " + expr + (isNumber2 ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber2 ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
        return joinPaths2(currentPath, path);
      }
      function getPath(currentPath, prop, jsonPointers) {
        var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
        return joinPaths2(currentPath, path);
      }
      var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
      var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function getData($data, lvl, paths) {
        var up, jsonPointer, data2, matches;
        if ($data === "") return "rootData";
        if ($data[0] == "/") {
          if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
          jsonPointer = $data;
          data2 = "rootData";
        } else {
          matches = $data.match(RELATIVE_JSON_POINTER);
          if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
          up = +matches[1];
          jsonPointer = matches[2];
          if (jsonPointer == "#") {
            if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
            return paths[lvl - up];
          }
          if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
          data2 = "data" + (lvl - up || "");
          if (!jsonPointer) return data2;
        }
        var expr = data2;
        var segments = jsonPointer.split("/");
        for (var i = 0; i < segments.length; i++) {
          var segment = segments[i];
          if (segment) {
            data2 += getProperty(unescapeJsonPointer(segment));
            expr += " && " + data2;
          }
        }
        return expr;
      }
      function joinPaths2(a, b) {
        if (a == '""') return b;
        return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
      }
      function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str));
      }
      function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str));
      }
      function escapeJsonPointer(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      function unescapeJsonPointer(str) {
        return str.replace(/~1/g, "/").replace(/~0/g, "~");
      }
    }
  });

  // ../../node_modules/ajv/lib/compile/schema_obj.js
  var require_schema_obj = __commonJS({
    "../../node_modules/ajv/lib/compile/schema_obj.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var util2 = require_util();
      module.exports = SchemaObject;
      function SchemaObject(obj) {
        util2.copy(obj, this);
      }
    }
  });

  // ../../node_modules/json-schema-traverse/index.js
  var require_json_schema_traverse = __commonJS({
    "../../node_modules/json-schema-traverse/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var traverse = module.exports = function(schema, opts, cb) {
        if (typeof opts == "function") {
          cb = opts;
          opts = {};
        }
        cb = opts.cb || cb;
        var pre = typeof cb == "function" ? cb : cb.pre || function() {
        };
        var post = cb.post || function() {
        };
        _traverse(opts, pre, post, schema, "", schema);
      };
      traverse.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true
      };
      traverse.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
      };
      traverse.propsKeywords = {
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
      };
      traverse.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
      };
      function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (schema && typeof schema == "object" && !Array.isArray(schema)) {
          pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
          for (var key in schema) {
            var sch = schema[key];
            if (Array.isArray(sch)) {
              if (key in traverse.arrayKeywords) {
                for (var i = 0; i < sch.length; i++)
                  _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
              }
            } else if (key in traverse.propsKeywords) {
              if (sch && typeof sch == "object") {
                for (var prop in sch)
                  _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
              }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
              _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
            }
          }
          post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        }
      }
      function escapeJsonPtr(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
    }
  });

  // ../../node_modules/ajv/lib/compile/resolve.js
  var require_resolve = __commonJS({
    "../../node_modules/ajv/lib/compile/resolve.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var URI = require_uri_all();
      var equal = require_fast_deep_equal();
      var util2 = require_util();
      var SchemaObject = require_schema_obj();
      var traverse = require_json_schema_traverse();
      module.exports = resolve;
      resolve.normalizeId = normalizeId;
      resolve.fullPath = getFullPath;
      resolve.url = resolveUrl;
      resolve.ids = resolveIds;
      resolve.inlineRef = inlineRef;
      resolve.schema = resolveSchema;
      function resolve(compile, root, ref) {
        var refVal = this._refs[ref];
        if (typeof refVal == "string") {
          if (this._refs[refVal]) refVal = this._refs[refVal];
          else return resolve.call(this, compile, root, refVal);
        }
        refVal = refVal || this._schemas[ref];
        if (refVal instanceof SchemaObject) {
          return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
        }
        var res = resolveSchema.call(this, root, ref);
        var schema, v, baseId;
        if (res) {
          schema = res.schema;
          root = res.root;
          baseId = res.baseId;
        }
        if (schema instanceof SchemaObject) {
          v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
        } else if (schema !== void 0) {
          v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
        }
        return v;
      }
      function resolveSchema(root, ref) {
        var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
        if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
          var id = normalizeId(refPath);
          var refVal = this._refs[id];
          if (typeof refVal == "string") {
            return resolveRecursive.call(this, root, refVal, p);
          } else if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            root = refVal;
          } else {
            refVal = this._schemas[id];
            if (refVal instanceof SchemaObject) {
              if (!refVal.validate) this._compile(refVal);
              if (id == normalizeId(ref))
                return { schema: refVal, root, baseId };
              root = refVal;
            } else {
              return;
            }
          }
          if (!root.schema) return;
          baseId = getFullPath(this._getId(root.schema));
        }
        return getJsonPointer.call(this, p, baseId, root.schema, root);
      }
      function resolveRecursive(root, ref, parsedRef) {
        var res = resolveSchema.call(this, root, ref);
        if (res) {
          var schema = res.schema;
          var baseId = res.baseId;
          root = res.root;
          var id = this._getId(schema);
          if (id) baseId = resolveUrl(baseId, id);
          return getJsonPointer.call(this, parsedRef, baseId, schema, root);
        }
      }
      var PREVENT_SCOPE_CHANGE = util2.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
      function getJsonPointer(parsedRef, baseId, schema, root) {
        parsedRef.fragment = parsedRef.fragment || "";
        if (parsedRef.fragment.slice(0, 1) != "/") return;
        var parts = parsedRef.fragment.split("/");
        for (var i = 1; i < parts.length; i++) {
          var part = parts[i];
          if (part) {
            part = util2.unescapeFragment(part);
            schema = schema[part];
            if (schema === void 0) break;
            var id;
            if (!PREVENT_SCOPE_CHANGE[part]) {
              id = this._getId(schema);
              if (id) baseId = resolveUrl(baseId, id);
              if (schema.$ref) {
                var $ref = resolveUrl(baseId, schema.$ref);
                var res = resolveSchema.call(this, root, $ref);
                if (res) {
                  schema = res.schema;
                  root = res.root;
                  baseId = res.baseId;
                }
              }
            }
          }
        }
        if (schema !== void 0 && schema !== root.schema)
          return { schema, root, baseId };
      }
      var SIMPLE_INLINED = util2.toHash([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum"
      ]);
      function inlineRef(schema, limit) {
        if (limit === false) return false;
        if (limit === void 0 || limit === true) return checkNoRef(schema);
        else if (limit) return countKeys(schema) <= limit;
      }
      function checkNoRef(schema) {
        var item;
        if (Array.isArray(schema)) {
          for (var i = 0; i < schema.length; i++) {
            item = schema[i];
            if (typeof item == "object" && !checkNoRef(item)) return false;
          }
        } else {
          for (var key in schema) {
            if (key == "$ref") return false;
            item = schema[key];
            if (typeof item == "object" && !checkNoRef(item)) return false;
          }
        }
        return true;
      }
      function countKeys(schema) {
        var count = 0, item;
        if (Array.isArray(schema)) {
          for (var i = 0; i < schema.length; i++) {
            item = schema[i];
            if (typeof item == "object") count += countKeys(item);
            if (count == Infinity) return Infinity;
          }
        } else {
          for (var key in schema) {
            if (key == "$ref") return Infinity;
            if (SIMPLE_INLINED[key]) {
              count++;
            } else {
              item = schema[key];
              if (typeof item == "object") count += countKeys(item) + 1;
              if (count == Infinity) return Infinity;
            }
          }
        }
        return count;
      }
      function getFullPath(id, normalize) {
        if (normalize !== false) id = normalizeId(id);
        var p = URI.parse(id);
        return _getFullPath(p);
      }
      function _getFullPath(p) {
        return URI.serialize(p).split("#")[0] + "#";
      }
      var TRAILING_SLASH_HASH = /#\/?$/;
      function normalizeId(id) {
        return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
      }
      function resolveUrl(baseId, id) {
        id = normalizeId(id);
        return URI.resolve(baseId, id);
      }
      function resolveIds(schema) {
        var schemaId = normalizeId(this._getId(schema));
        var baseIds = { "": schemaId };
        var fullPaths = { "": getFullPath(schemaId, false) };
        var localRefs = {};
        var self = this;
        traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
          if (jsonPtr === "") return;
          var id = self._getId(sch);
          var baseId = baseIds[parentJsonPtr];
          var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
          if (keyIndex !== void 0)
            fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util2.escapeFragment(keyIndex));
          if (typeof id == "string") {
            id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
            var refVal = self._refs[id];
            if (typeof refVal == "string") refVal = self._refs[refVal];
            if (refVal && refVal.schema) {
              if (!equal(sch, refVal.schema))
                throw new Error('id "' + id + '" resolves to more than one schema');
            } else if (id != normalizeId(fullPath)) {
              if (id[0] == "#") {
                if (localRefs[id] && !equal(sch, localRefs[id]))
                  throw new Error('id "' + id + '" resolves to more than one schema');
                localRefs[id] = sch;
              } else {
                self._refs[id] = fullPath;
              }
            }
          }
          baseIds[jsonPtr] = baseId;
          fullPaths[jsonPtr] = fullPath;
        });
        return localRefs;
      }
    }
  });

  // ../../node_modules/ajv/lib/compile/error_classes.js
  var require_error_classes = __commonJS({
    "../../node_modules/ajv/lib/compile/error_classes.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var resolve = require_resolve();
      module.exports = {
        Validation: errorSubclass(ValidationError),
        MissingRef: errorSubclass(MissingRefError)
      };
      function ValidationError(errors) {
        this.message = "validation failed";
        this.errors = errors;
        this.ajv = this.validation = true;
      }
      MissingRefError.message = function(baseId, ref) {
        return "can't resolve reference " + ref + " from id " + baseId;
      };
      function MissingRefError(baseId, ref, message) {
        this.message = message || MissingRefError.message(baseId, ref);
        this.missingRef = resolve.url(baseId, ref);
        this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
      }
      function errorSubclass(Subclass) {
        Subclass.prototype = Object.create(Error.prototype);
        Subclass.prototype.constructor = Subclass;
        return Subclass;
      }
    }
  });

  // ../../node_modules/fast-json-stable-stringify/index.js
  var require_fast_json_stable_stringify = __commonJS({
    "../../node_modules/fast-json-stable-stringify/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function(data2, opts) {
        if (!opts) opts = {};
        if (typeof opts === "function") opts = { cmp: opts };
        var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
        var cmp = opts.cmp && /* @__PURE__ */ function(f) {
          return function(node) {
            return function(a, b) {
              var aobj = { key: a, value: node[a] };
              var bobj = { key: b, value: node[b] };
              return f(aobj, bobj);
            };
          };
        }(opts.cmp);
        var seen = [];
        return function stringify(node) {
          if (node && node.toJSON && typeof node.toJSON === "function") {
            node = node.toJSON();
          }
          if (node === void 0) return;
          if (typeof node == "number") return isFinite(node) ? "" + node : "null";
          if (typeof node !== "object") return JSON.stringify(node);
          var i, out;
          if (Array.isArray(node)) {
            out = "[";
            for (i = 0; i < node.length; i++) {
              if (i) out += ",";
              out += stringify(node[i]) || "null";
            }
            return out + "]";
          }
          if (node === null) return "null";
          if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
          }
          var seenIndex = seen.push(node) - 1;
          var keys = Object.keys(node).sort(cmp && cmp(node));
          out = "";
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);
            if (!value) continue;
            if (out) out += ",";
            out += JSON.stringify(key) + ":" + value;
          }
          seen.splice(seenIndex, 1);
          return "{" + out + "}";
        }(data2);
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/validate.js
  var require_validate = __commonJS({
    "../../node_modules/ajv/lib/dotjs/validate.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_validate(it, $keyword, $ruleType) {
        var out = "";
        var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
        if (it.opts.strictKeywords) {
          var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
          if ($unknownKwd) {
            var $keywordsMsg = "unknown keyword: " + $unknownKwd;
            if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
            else throw new Error($keywordsMsg);
          }
        }
        if (it.isTop) {
          out += " var validate = ";
          if ($async) {
            it.async = true;
            out += "async ";
          }
          out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
          if ($id && (it.opts.sourceCode || it.opts.processCode)) {
            out += " " + ("/*# sourceURL=" + $id + " */") + " ";
          }
        }
        if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
          var $keyword = "false schema";
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
          var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = "data" + ($dataLvl || "");
          var $valid = "valid" + $lvl;
          if (it.schema === false) {
            if (it.isTop) {
              $breakOnError = true;
            } else {
              out += " var " + $valid + " = false; ";
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
              if (it.opts.messages !== false) {
                out += " , message: 'boolean schema is false' ";
              }
              if (it.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            if (it.isTop) {
              if ($async) {
                out += " return data; ";
              } else {
                out += " validate.errors = null; return true; ";
              }
            } else {
              out += " var " + $valid + " = true; ";
            }
          }
          if (it.isTop) {
            out += " }; return validate; ";
          }
          return out;
        }
        if (it.isTop) {
          var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
          it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
          it.baseId = it.baseId || it.rootId;
          delete it.isTop;
          it.dataPathArr = [""];
          if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
            var $defaultMsg = "default is ignored in the schema root";
            if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
            else throw new Error($defaultMsg);
          }
          out += " var vErrors = null; ";
          out += " var errors = 0;     ";
          out += " if (rootData === undefined) rootData = data; ";
        } else {
          var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
          if ($id) it.baseId = it.resolve.url(it.baseId, $id);
          if ($async && !it.async) throw new Error("async schema in sync schema");
          out += " var errs_" + $lvl + " = errors;";
        }
        var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
        var $errorKeyword;
        var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
        if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
          if ($typeIsArray) {
            if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
          } else if ($typeSchema != "null") {
            $typeSchema = [$typeSchema, "null"];
            $typeIsArray = true;
          }
        }
        if ($typeIsArray && $typeSchema.length == 1) {
          $typeSchema = $typeSchema[0];
          $typeIsArray = false;
        }
        if (it.schema.$ref && $refKeywords) {
          if (it.opts.extendRefs == "fail") {
            throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
          } else if (it.opts.extendRefs !== true) {
            $refKeywords = false;
            it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
          }
        }
        if (it.schema.$comment && it.opts.$comment) {
          out += " " + it.RULES.all.$comment.code(it, "$comment");
        }
        if ($typeSchema) {
          if (it.opts.coerceTypes) {
            var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
          }
          var $rulesGroup = it.RULES.types[$typeSchema];
          if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
            out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
            if ($coerceToTypes) {
              var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
              out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
              if (it.opts.coerceTypes == "array") {
                out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
              }
              out += " if (" + $coerced + " !== undefined) ; ";
              var arr1 = $coerceToTypes;
              if (arr1) {
                var $type, $i = -1, l1 = arr1.length - 1;
                while ($i < l1) {
                  $type = arr1[$i += 1];
                  if ($type == "string") {
                    out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                  } else if ($type == "number" || $type == "integer") {
                    out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                    if ($type == "integer") {
                      out += " && !(" + $data + " % 1)";
                    }
                    out += ")) " + $coerced + " = +" + $data + "; ";
                  } else if ($type == "boolean") {
                    out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                  } else if ($type == "null") {
                    out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                  } else if (it.opts.coerceTypes == "array" && $type == "array") {
                    out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                  }
                }
              }
              out += " else {   ";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should be ";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } if (" + $coerced + " !== undefined) {  ";
              var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
              out += " " + $data + " = " + $coerced + "; ";
              if (!$dataLvl) {
                out += "if (" + $parentData + " !== undefined)";
              }
              out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
            } else {
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should be ";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
            }
            out += " } ";
          }
        }
        if (it.schema.$ref && !$refKeywords) {
          out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
          if ($breakOnError) {
            out += " } if (errors === ";
            if ($top) {
              out += "0";
            } else {
              out += "errs_" + $lvl;
            }
            out += ") { ";
            $closingBraces2 += "}";
          }
        } else {
          var arr2 = it.RULES;
          if (arr2) {
            var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
            while (i2 < l2) {
              $rulesGroup = arr2[i2 += 1];
              if ($shouldUseGroup($rulesGroup)) {
                if ($rulesGroup.type) {
                  out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
                }
                if (it.opts.useDefaults) {
                  if ($rulesGroup.type == "object" && it.schema.properties) {
                    var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                    var arr3 = $schemaKeys;
                    if (arr3) {
                      var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                      while (i3 < l3) {
                        $propertyKey = arr3[i3 += 1];
                        var $sch = $schema[$propertyKey];
                        if ($sch.default !== void 0) {
                          var $passData = $data + it.util.getProperty($propertyKey);
                          if (it.compositeRule) {
                            if (it.opts.strictDefaults) {
                              var $defaultMsg = "default is ignored for: " + $passData;
                              if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                              else throw new Error($defaultMsg);
                            }
                          } else {
                            out += " if (" + $passData + " === undefined ";
                            if (it.opts.useDefaults == "empty") {
                              out += " || " + $passData + " === null || " + $passData + " === '' ";
                            }
                            out += " ) " + $passData + " = ";
                            if (it.opts.useDefaults == "shared") {
                              out += " " + it.useDefault($sch.default) + " ";
                            } else {
                              out += " " + JSON.stringify($sch.default) + " ";
                            }
                            out += "; ";
                          }
                        }
                      }
                    }
                  } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                    var arr4 = it.schema.items;
                    if (arr4) {
                      var $sch, $i = -1, l4 = arr4.length - 1;
                      while ($i < l4) {
                        $sch = arr4[$i += 1];
                        if ($sch.default !== void 0) {
                          var $passData = $data + "[" + $i + "]";
                          if (it.compositeRule) {
                            if (it.opts.strictDefaults) {
                              var $defaultMsg = "default is ignored for: " + $passData;
                              if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                              else throw new Error($defaultMsg);
                            }
                          } else {
                            out += " if (" + $passData + " === undefined ";
                            if (it.opts.useDefaults == "empty") {
                              out += " || " + $passData + " === null || " + $passData + " === '' ";
                            }
                            out += " ) " + $passData + " = ";
                            if (it.opts.useDefaults == "shared") {
                              out += " " + it.useDefault($sch.default) + " ";
                            } else {
                              out += " " + JSON.stringify($sch.default) + " ";
                            }
                            out += "; ";
                          }
                        }
                      }
                    }
                  }
                }
                var arr5 = $rulesGroup.rules;
                if (arr5) {
                  var $rule, i5 = -1, l5 = arr5.length - 1;
                  while (i5 < l5) {
                    $rule = arr5[i5 += 1];
                    if ($shouldUseRule($rule)) {
                      var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                      if ($code) {
                        out += " " + $code + " ";
                        if ($breakOnError) {
                          $closingBraces1 += "}";
                        }
                      }
                    }
                  }
                }
                if ($breakOnError) {
                  out += " " + $closingBraces1 + " ";
                  $closingBraces1 = "";
                }
                if ($rulesGroup.type) {
                  out += " } ";
                  if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                    out += " else { ";
                    var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = "";
                    if (it.createErrors !== false) {
                      out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' } ";
                      if (it.opts.messages !== false) {
                        out += " , message: 'should be ";
                        if ($typeIsArray) {
                          out += "" + $typeSchema.join(",");
                        } else {
                          out += "" + $typeSchema;
                        }
                        out += "' ";
                      }
                      if (it.opts.verbose) {
                        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                      }
                      out += " } ";
                    } else {
                      out += " {} ";
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                      if (it.async) {
                        out += " throw new ValidationError([" + __err + "]); ";
                      } else {
                        out += " validate.errors = [" + __err + "]; return false; ";
                      }
                    } else {
                      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    }
                    out += " } ";
                  }
                }
                if ($breakOnError) {
                  out += " if (errors === ";
                  if ($top) {
                    out += "0";
                  } else {
                    out += "errs_" + $lvl;
                  }
                  out += ") { ";
                  $closingBraces2 += "}";
                }
              }
            }
          }
        }
        if ($breakOnError) {
          out += " " + $closingBraces2 + " ";
        }
        if ($top) {
          if ($async) {
            out += " if (errors === 0) return data;           ";
            out += " else throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; ";
            out += " return errors === 0;       ";
          }
          out += " }; return validate;";
        } else {
          out += " var " + $valid + " = errors === errs_" + $lvl + ";";
        }
        function $shouldUseGroup($rulesGroup2) {
          var rules = $rulesGroup2.rules;
          for (var i = 0; i < rules.length; i++)
            if ($shouldUseRule(rules[i])) return true;
        }
        function $shouldUseRule($rule2) {
          return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
        }
        function $ruleImplementsSomeKeyword($rule2) {
          var impl = $rule2.implements;
          for (var i = 0; i < impl.length; i++)
            if (it.schema[impl[i]] !== void 0) return true;
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/index.js
  var require_compile = __commonJS({
    "../../node_modules/ajv/lib/compile/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var resolve = require_resolve();
      var util2 = require_util();
      var errorClasses = require_error_classes();
      var stableStringify = require_fast_json_stable_stringify();
      var validateGenerator = require_validate();
      var ucs2length = util2.ucs2length;
      var equal = require_fast_deep_equal();
      var ValidationError = errorClasses.Validation;
      module.exports = compile;
      function compile(schema, root, localRefs, baseId) {
        var self = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
        root = root || { schema, refVal, refs };
        var c = checkCompiling.call(this, schema, root, baseId);
        var compilation = this._compilations[c.index];
        if (c.compiling) return compilation.callValidate = callValidate;
        var formats = this._formats;
        var RULES = this.RULES;
        try {
          var v = localCompile(schema, root, localRefs, baseId);
          compilation.validate = v;
          var cv = compilation.callValidate;
          if (cv) {
            cv.schema = v.schema;
            cv.errors = null;
            cv.refs = v.refs;
            cv.refVal = v.refVal;
            cv.root = v.root;
            cv.$async = v.$async;
            if (opts.sourceCode) cv.source = v.source;
          }
          return v;
        } finally {
          endCompiling.call(this, schema, root, baseId);
        }
        function callValidate() {
          var validate = compilation.validate;
          var result = validate.apply(this, arguments);
          callValidate.errors = validate.errors;
          return result;
        }
        function localCompile(_schema, _root, localRefs2, baseId2) {
          var isRoot = !_root || _root && _root.schema == _schema;
          if (_root.schema != root.schema)
            return compile.call(self, _schema, _root, localRefs2, baseId2);
          var $async = _schema.$async === true;
          var sourceCode = validateGenerator({
            isTop: true,
            schema: _schema,
            isRoot,
            baseId: baseId2,
            root: _root,
            schemaPath: "",
            errSchemaPath: "#",
            errorPath: '""',
            MissingRefError: errorClasses.MissingRef,
            RULES,
            validate: validateGenerator,
            util: util2,
            resolve,
            resolveRef,
            usePattern,
            useDefault,
            useCustomRule,
            opts,
            formats,
            logger: self.logger,
            self
          });
          sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
          if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
          var validate;
          try {
            var makeValidate = new Function(
              "self",
              "RULES",
              "formats",
              "root",
              "refVal",
              "defaults",
              "customRules",
              "equal",
              "ucs2length",
              "ValidationError",
              sourceCode
            );
            validate = makeValidate(
              self,
              RULES,
              formats,
              root,
              refVal,
              defaults,
              customRules,
              equal,
              ucs2length,
              ValidationError
            );
            refVal[0] = validate;
          } catch (e) {
            self.logger.error("Error compiling schema, function code:", sourceCode);
            throw e;
          }
          validate.schema = _schema;
          validate.errors = null;
          validate.refs = refs;
          validate.refVal = refVal;
          validate.root = isRoot ? validate : _root;
          if ($async) validate.$async = true;
          if (opts.sourceCode === true) {
            validate.source = {
              code: sourceCode,
              patterns,
              defaults
            };
          }
          return validate;
        }
        function resolveRef(baseId2, ref, isRoot) {
          ref = resolve.url(baseId2, ref);
          var refIndex = refs[ref];
          var _refVal, refCode;
          if (refIndex !== void 0) {
            _refVal = refVal[refIndex];
            refCode = "refVal[" + refIndex + "]";
            return resolvedRef(_refVal, refCode);
          }
          if (!isRoot && root.refs) {
            var rootRefId = root.refs[ref];
            if (rootRefId !== void 0) {
              _refVal = root.refVal[rootRefId];
              refCode = addLocalRef(ref, _refVal);
              return resolvedRef(_refVal, refCode);
            }
          }
          refCode = addLocalRef(ref);
          var v2 = resolve.call(self, localCompile, root, ref);
          if (v2 === void 0) {
            var localSchema = localRefs && localRefs[ref];
            if (localSchema) {
              v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self, localSchema, root, localRefs, baseId2);
            }
          }
          if (v2 === void 0) {
            removeLocalRef(ref);
          } else {
            replaceLocalRef(ref, v2);
            return resolvedRef(v2, refCode);
          }
        }
        function addLocalRef(ref, v2) {
          var refId = refVal.length;
          refVal[refId] = v2;
          refs[ref] = refId;
          return "refVal" + refId;
        }
        function removeLocalRef(ref) {
          delete refs[ref];
        }
        function replaceLocalRef(ref, v2) {
          var refId = refs[ref];
          refVal[refId] = v2;
        }
        function resolvedRef(refVal2, code) {
          return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
        }
        function usePattern(regexStr) {
          var index = patternsHash[regexStr];
          if (index === void 0) {
            index = patternsHash[regexStr] = patterns.length;
            patterns[index] = regexStr;
          }
          return "pattern" + index;
        }
        function useDefault(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
              return "" + value;
            case "string":
              return util2.toQuotedString(value);
            case "object":
              if (value === null) return "null";
              var valueStr = stableStringify(value);
              var index = defaultsHash[valueStr];
              if (index === void 0) {
                index = defaultsHash[valueStr] = defaults.length;
                defaults[index] = value;
              }
              return "default" + index;
          }
        }
        function useCustomRule(rule, schema2, parentSchema, it) {
          if (self._opts.validateSchema !== false) {
            var deps = rule.definition.dependencies;
            if (deps && !deps.every(function(keyword) {
              return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
            }))
              throw new Error("parent schema must have all required keywords: " + deps.join(","));
            var validateSchema = rule.definition.validateSchema;
            if (validateSchema) {
              var valid = validateSchema(schema2);
              if (!valid) {
                var message = "keyword schema is invalid: " + self.errorsText(validateSchema.errors);
                if (self._opts.validateSchema == "log") self.logger.error(message);
                else throw new Error(message);
              }
            }
          }
          var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
          var validate;
          if (compile2) {
            validate = compile2.call(self, schema2, parentSchema, it);
          } else if (macro) {
            validate = macro.call(self, schema2, parentSchema, it);
            if (opts.validateSchema !== false) self.validateSchema(validate, true);
          } else if (inline) {
            validate = inline.call(self, it, rule.keyword, schema2, parentSchema);
          } else {
            validate = rule.definition.validate;
            if (!validate) return;
          }
          if (validate === void 0)
            throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
          var index = customRules.length;
          customRules[index] = validate;
          return {
            code: "customRule" + index,
            validate
          };
        }
      }
      function checkCompiling(schema, root, baseId) {
        var index = compIndex.call(this, schema, root, baseId);
        if (index >= 0) return { index, compiling: true };
        index = this._compilations.length;
        this._compilations[index] = {
          schema,
          root,
          baseId
        };
        return { index, compiling: false };
      }
      function endCompiling(schema, root, baseId) {
        var i = compIndex.call(this, schema, root, baseId);
        if (i >= 0) this._compilations.splice(i, 1);
      }
      function compIndex(schema, root, baseId) {
        for (var i = 0; i < this._compilations.length; i++) {
          var c = this._compilations[i];
          if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
        }
        return -1;
      }
      function patternCode(i, patterns) {
        return "var pattern" + i + " = new RegExp(" + util2.toQuotedString(patterns[i]) + ");";
      }
      function defaultCode(i) {
        return "var default" + i + " = defaults[" + i + "];";
      }
      function refValCode(i, refVal) {
        return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
      }
      function customRuleCode(i) {
        return "var customRule" + i + " = customRules[" + i + "];";
      }
      function vars(arr, statement) {
        if (!arr.length) return "";
        var code = "";
        for (var i = 0; i < arr.length; i++)
          code += statement(i, arr);
        return code;
      }
    }
  });

  // ../../node_modules/ajv/lib/cache.js
  var require_cache = __commonJS({
    "../../node_modules/ajv/lib/cache.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var Cache = module.exports = function Cache2() {
        this._cache = {};
      };
      Cache.prototype.put = function Cache_put(key, value) {
        this._cache[key] = value;
      };
      Cache.prototype.get = function Cache_get(key) {
        return this._cache[key];
      };
      Cache.prototype.del = function Cache_del(key) {
        delete this._cache[key];
      };
      Cache.prototype.clear = function Cache_clear() {
        this._cache = {};
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/formats.js
  var require_formats = __commonJS({
    "../../node_modules/ajv/lib/compile/formats.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var util2 = require_util();
      var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
      var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
      var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
      var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
      var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
      var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
      var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
      module.exports = formats;
      function formats(mode) {
        mode = mode == "full" ? "full" : "fast";
        return util2.copy(formats[mode]);
      }
      formats.fast = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
        "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        "uri-template": URITEMPLATE,
        url: URL2,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        hostname: HOSTNAME,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: UUID,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": JSON_POINTER,
        "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": RELATIVE_JSON_POINTER
      };
      formats.full = {
        date,
        time,
        "date-time": date_time,
        uri,
        "uri-reference": URIREF,
        "uri-template": URITEMPLATE,
        url: URL2,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: HOSTNAME,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex,
        uuid: UUID,
        "json-pointer": JSON_POINTER,
        "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
        "relative-json-pointer": RELATIVE_JSON_POINTER
      };
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      function date(str) {
        var matches = str.match(DATE);
        if (!matches) return false;
        var year = +matches[1];
        var month = +matches[2];
        var day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function time(str, full) {
        var matches = str.match(TIME);
        if (!matches) return false;
        var hour = matches[1];
        var minute = matches[2];
        var second = matches[3];
        var timeZone = matches[5];
        return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
      }
      var DATE_TIME_SEPARATOR = /t|\s/i;
      function date_time(str) {
        var dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
      }
      var NOT_URI_FRAGMENT = /\/|:/;
      function uri(str) {
        return NOT_URI_FRAGMENT.test(str) && URI.test(str);
      }
      var Z_ANCHOR = /[^\\]\\Z/;
      function regex(str) {
        if (Z_ANCHOR.test(str)) return false;
        try {
          new RegExp(str);
          return true;
        } catch (e) {
          return false;
        }
      }
    }
  });

  // ../../node_modules/ajv/lib/dotjs/ref.js
  var require_ref = __commonJS({
    "../../node_modules/ajv/lib/dotjs/ref.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_ref(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $async, $refCode;
        if ($schema == "#" || $schema == "#/") {
          if (it.isRoot) {
            $async = it.async;
            $refCode = "validate";
          } else {
            $async = it.root.schema.$async === true;
            $refCode = "root.refVal[0]";
          }
        } else {
          var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
          if ($refVal === void 0) {
            var $message = it.MissingRefError.message(it.baseId, $schema);
            if (it.opts.missingRefs == "fail") {
              it.logger.error($message);
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              if ($breakOnError) {
                out += " if (false) { ";
              }
            } else if (it.opts.missingRefs == "ignore") {
              it.logger.warn($message);
              if ($breakOnError) {
                out += " if (true) { ";
              }
            } else {
              throw new it.MissingRefError(it.baseId, $schema, $message);
            }
          } else if ($refVal.inline) {
            var $it = it.util.copy(it);
            $it.level++;
            var $nextValid = "valid" + $it.level;
            $it.schema = $refVal.schema;
            $it.schemaPath = "";
            $it.errSchemaPath = $schema;
            var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
            out += " " + $code + " ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
            }
          } else {
            $async = $refVal.$async === true || it.async && $refVal.$async !== false;
            $refCode = $refVal.code;
          }
        }
        if ($refCode) {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.opts.passContext) {
            out += " " + $refCode + ".call(this, ";
          } else {
            out += " " + $refCode + "( ";
          }
          out += " " + $data + ", (dataPath || '')";
          if (it.errorPath != '""') {
            out += " + " + it.errorPath;
          }
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
          var __callValidate = out;
          out = $$outStack.pop();
          if ($async) {
            if (!it.async) throw new Error("async schema referenced by sync schema");
            if ($breakOnError) {
              out += " var " + $valid + "; ";
            }
            out += " try { await " + __callValidate + "; ";
            if ($breakOnError) {
              out += " " + $valid + " = true; ";
            }
            out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
            if ($breakOnError) {
              out += " " + $valid + " = false; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " if (" + $valid + ") { ";
            }
          } else {
            out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
            if ($breakOnError) {
              out += " else { ";
            }
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/allOf.js
  var require_allOf = __commonJS({
    "../../node_modules/ajv/lib/dotjs/allOf.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_allOf(it, $keyword, $ruleType) {
        var out = " ";
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $allSchemasEmpty = false;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              out += "  " + it.validate($it) + " ";
              $it.baseId = $currentBaseId;
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if ($breakOnError) {
          if ($allSchemasEmpty) {
            out += " if (true) { ";
          } else {
            out += " " + $closingBraces.slice(0, -1) + " ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/anyOf.js
  var require_anyOf = __commonJS({
    "../../node_modules/ajv/lib/dotjs/anyOf.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_anyOf(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $noEmptySchema = $schema.every(function($sch2) {
          return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
        });
        if ($noEmptySchema) {
          var $currentBaseId = $it.baseId;
          out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          var arr1 = $schema;
          if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $sch = arr1[$i += 1];
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              out += "  " + it.validate($it) + " ";
              $it.baseId = $currentBaseId;
              out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
              $closingBraces += "}";
            }
          }
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'should match some schema in anyOf' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
          out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
          if (it.opts.allErrors) {
            out += " } ";
          }
        } else {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/comment.js
  var require_comment = __commonJS({
    "../../node_modules/ajv/lib/dotjs/comment.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_comment(it, $keyword, $ruleType) {
        var out = " ";
        var $schema = it.schema[$keyword];
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $comment = it.util.toQuotedString($schema);
        if (it.opts.$comment === true) {
          out += " console.log(" + $comment + ");";
        } else if (typeof it.opts.$comment == "function") {
          out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/const.js
  var require_const = __commonJS({
    "../../node_modules/ajv/lib/dotjs/const.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_const(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!$isData) {
          out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
        }
        out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be equal to constant' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " }";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/contains.js
  var require_contains = __commonJS({
    "../../node_modules/ajv/lib/dotjs/contains.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_contains(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
        out += "var " + $errs + " = errors;var " + $valid + ";";
        if ($nonEmptySchema) {
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          out += " if (" + $nextValid + ") break; }  ";
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " " + $closingBraces + " if (!" + $nextValid + ") {";
        } else {
          out += " if (" + $data + ".length == 0) {";
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should contain a valid item' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else { ";
        if ($nonEmptySchema) {
          out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        }
        if (it.opts.allErrors) {
          out += " } ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/dependencies.js
  var require_dependencies = __commonJS({
    "../../node_modules/ajv/lib/dotjs/dependencies.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_dependencies(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
        for ($property in $schema) {
          if ($property == "__proto__") continue;
          var $sch = $schema[$property];
          var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
          $deps[$property] = $sch;
        }
        out += "var " + $errs + " = errors;";
        var $currentErrorPath = it.errorPath;
        out += "var missing" + $lvl + ";";
        for (var $property in $propertyDeps) {
          $deps = $propertyDeps[$property];
          if ($deps.length) {
            out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) {
              out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
            }
            if ($breakOnError) {
              out += " && ( ";
              var arr1 = $deps;
              if (arr1) {
                var $propertyKey, $i = -1, l1 = arr1.length - 1;
                while ($i < l1) {
                  $propertyKey = arr1[$i += 1];
                  if ($i) {
                    out += " || ";
                  }
                  var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                  out += " ( ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                }
              }
              out += ")) {  ";
              var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
              }
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += "property " + it.util.escapeQuotes($deps[0]);
                  } else {
                    out += "properties " + it.util.escapeQuotes($deps.join(", "));
                  }
                  out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
            } else {
              out += " ) { ";
              var arr2 = $deps;
              if (arr2) {
                var $propertyKey, i2 = -1, l2 = arr2.length - 1;
                while (i2 < l2) {
                  $propertyKey = arr2[i2 += 1];
                  var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") {  var err =   ";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should have ";
                      if ($deps.length == 1) {
                        out += "property " + it.util.escapeQuotes($deps[0]);
                      } else {
                        out += "properties " + it.util.escapeQuotes($deps.join(", "));
                      }
                      out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
              }
            }
            out += " }   ";
            if ($breakOnError) {
              $closingBraces += "}";
              out += " else { ";
            }
          }
        }
        it.errorPath = $currentErrorPath;
        var $currentBaseId = $it.baseId;
        for (var $property in $schemaDeps) {
          var $sch = $schemaDeps[$property];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) {
              out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
            }
            out += ") { ";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + it.util.getProperty($property);
            $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
        if ($breakOnError) {
          out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/enum.js
  var require_enum = __commonJS({
    "../../node_modules/ajv/lib/dotjs/enum.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_enum(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
        if (!$isData) {
          out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
        }
        out += "var " + $valid + ";";
        if ($isData) {
          out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
        }
        out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be equal to one of the allowed values' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " }";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/format.js
  var require_format = __commonJS({
    "../../node_modules/ajv/lib/dotjs/format.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_format(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        if (it.opts.format === false) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
        if ($isData) {
          var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
          out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
          if (it.async) {
            out += " var async" + $lvl + " = " + $format + ".async; ";
          }
          out += " " + $format + " = " + $format + ".validate; } if (  ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
          }
          out += " (";
          if ($unknownFormats != "ignore") {
            out += " (" + $schemaValue + " && !" + $format + " ";
            if ($allowUnknown) {
              out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
            }
            out += ") || ";
          }
          out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
          if (it.async) {
            out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
          } else {
            out += " " + $format + "(" + $data + ") ";
          }
          out += " : " + $format + ".test(" + $data + "))))) {";
        } else {
          var $format = it.formats[$schema];
          if (!$format) {
            if ($unknownFormats == "ignore") {
              it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
              if ($breakOnError) {
                out += " if (true) { ";
              }
              return out;
            } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
              if ($breakOnError) {
                out += " if (true) { ";
              }
              return out;
            } else {
              throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
            }
          }
          var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
          var $formatType = $isObject && $format.type || "string";
          if ($isObject) {
            var $async = $format.async === true;
            $format = $format.validate;
          }
          if ($formatType != $ruleType) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          }
          if ($async) {
            if (!it.async) throw new Error("async format in sync schema");
            var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
            out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
          } else {
            out += " if (! ";
            var $formatRef = "formats" + it.util.getProperty($schema);
            if ($isObject) $formatRef += ".validate";
            if (typeof $format == "function") {
              out += " " + $formatRef + "(" + $data + ") ";
            } else {
              out += " " + $formatRef + ".test(" + $data + ") ";
            }
            out += ") { ";
          }
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
          if ($isData) {
            out += "" + $schemaValue;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "  } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match format "`;
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + it.util.escapeQuotes($schema);
            }
            out += `"' `;
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + it.util.toQuotedString($schema);
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/if.js
  var require_if = __commonJS({
    "../../node_modules/ajv/lib/dotjs/if.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_if(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
        if ($thenPresent || $elsePresent) {
          var $ifClause;
          $it.createErrors = false;
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          $it.createErrors = true;
          out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
          it.compositeRule = $it.compositeRule = $wasComposite;
          if ($thenPresent) {
            out += " if (" + $nextValid + ") {  ";
            $it.schema = it.schema["then"];
            $it.schemaPath = it.schemaPath + ".then";
            $it.errSchemaPath = it.errSchemaPath + "/then";
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
              $ifClause = "ifClause" + $lvl;
              out += " var " + $ifClause + " = 'then'; ";
            } else {
              $ifClause = "'then'";
            }
            out += " } ";
            if ($elsePresent) {
              out += " else { ";
            }
          } else {
            out += " if (!" + $nextValid + ") { ";
          }
          if ($elsePresent) {
            $it.schema = it.schema["else"];
            $it.schemaPath = it.schemaPath + ".else";
            $it.errSchemaPath = it.errSchemaPath + "/else";
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
              $ifClause = "ifClause" + $lvl;
              out += " var " + $ifClause + " = 'else'; ";
            } else {
              $ifClause = "'else'";
            }
            out += " } ";
          }
          out += " if (!" + $valid + ") {   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
          out += " }   ";
          if ($breakOnError) {
            out += " else { ";
          }
        } else {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/items.js
  var require_items = __commonJS({
    "../../node_modules/ajv/lib/dotjs/items.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_items(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
        out += "var " + $errs + " = errors;var " + $valid + ";";
        if (Array.isArray($schema)) {
          var $additionalItems = it.schema.additionalItems;
          if ($additionalItems === false) {
            out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it.errSchemaPath + "/additionalItems";
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should NOT have more than " + $schema.length + " items' ";
              }
              if (it.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } ";
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              $closingBraces += "}";
              out += " else { ";
            }
          }
          var arr1 = $schema;
          if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $sch = arr1[$i += 1];
              if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
                var $passData = $data + "[" + $i + "]";
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + "[" + $i + "]";
                $it.errSchemaPath = $errSchemaPath + "/" + $i;
                $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
                $it.dataPathArr[$dataNxt] = $i;
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                out += " }  ";
                if ($breakOnError) {
                  out += " if (" + $nextValid + ") { ";
                  $closingBraces += "}";
                }
              }
            }
          }
          if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
            $it.schema = $additionalItems;
            $it.schemaPath = it.schemaPath + ".additionalItems";
            $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
            $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
            var $passData = $data + "[" + $idx + "]";
            $it.dataPathArr[$dataNxt] = $idx;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
            out += " } }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " }";
        }
        if ($breakOnError) {
          out += " " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/_limit.js
  var require_limit = __commonJS({
    "../../node_modules/ajv/lib/dotjs/_limit.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate__limit(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
        if (!($isData || typeof $schema == "number" || $schema === void 0)) {
          throw new Error($keyword + " must be number");
        }
        if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
          throw new Error($exclusiveKeyword + " must be number or boolean");
        }
        if ($isDataExcl) {
          var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
          out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
          $schemaValueExcl = "schemaExcl" + $lvl;
          out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
          var $errorKeyword = $exclusiveKeyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
          if ($schema === void 0) {
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaValueExcl;
            $isData = $isDataExcl;
          }
        } else {
          var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
          if ($exclIsNumber && $isData) {
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) {
              out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            }
            out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
          } else {
            if ($exclIsNumber && $schema === void 0) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $schemaValue = $schemaExcl;
              $notOp += "=";
            } else {
              if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
              if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
                $exclusive = true;
                $errorKeyword = $exclusiveKeyword;
                $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
                $notOp += "=";
              } else {
                $exclusive = false;
                $opStr += "=";
              }
            }
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) {
              out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            }
            out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
          }
        }
        $errorKeyword = $errorKeyword || $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be " + $opStr + " ";
            if ($isData) {
              out += "' + " + $schemaValue;
            } else {
              out += "" + $schemaValue + "'";
            }
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/_limitItems.js
  var require_limitItems = __commonJS({
    "../../node_modules/ajv/lib/dotjs/_limitItems.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate__limitItems(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        var $op = $keyword == "maxItems" ? ">" : "<";
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
        var $errorKeyword = $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxItems") {
              out += "more";
            } else {
              out += "fewer";
            }
            out += " than ";
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + $schema;
            }
            out += " items' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/_limitLength.js
  var require_limitLength = __commonJS({
    "../../node_modules/ajv/lib/dotjs/_limitLength.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate__limitLength(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        var $op = $keyword == "maxLength" ? ">" : "<";
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        if (it.opts.unicode === false) {
          out += " " + $data + ".length ";
        } else {
          out += " ucs2length(" + $data + ") ";
        }
        out += " " + $op + " " + $schemaValue + ") { ";
        var $errorKeyword = $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be ";
            if ($keyword == "maxLength") {
              out += "longer";
            } else {
              out += "shorter";
            }
            out += " than ";
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + $schema;
            }
            out += " characters' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/_limitProperties.js
  var require_limitProperties = __commonJS({
    "../../node_modules/ajv/lib/dotjs/_limitProperties.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        var $op = $keyword == "maxProperties" ? ">" : "<";
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
        var $errorKeyword = $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxProperties") {
              out += "more";
            } else {
              out += "fewer";
            }
            out += " than ";
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + $schema;
            }
            out += " properties' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/multipleOf.js
  var require_multipleOf = __commonJS({
    "../../node_modules/ajv/lib/dotjs/multipleOf.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        out += "var division" + $lvl + ";if (";
        if ($isData) {
          out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
        }
        out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
        if (it.opts.multipleOfPrecision) {
          out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
        } else {
          out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
        }
        out += " ) ";
        if ($isData) {
          out += "  )  ";
        }
        out += " ) {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be multiple of ";
            if ($isData) {
              out += "' + " + $schemaValue;
            } else {
              out += "" + $schemaValue + "'";
            }
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/not.js
  var require_not = __commonJS({
    "../../node_modules/ajv/lib/dotjs/not.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_not(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += " var " + $errs + " = errors;  ";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.createErrors = false;
          var $allErrorsOption;
          if ($it.opts.allErrors) {
            $allErrorsOption = $it.opts.allErrors;
            $it.opts.allErrors = false;
          }
          out += " " + it.validate($it) + " ";
          $it.createErrors = true;
          if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " if (" + $nextValid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT be valid' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
          if (it.opts.allErrors) {
            out += " } ";
          }
        } else {
          out += "  var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT be valid' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if ($breakOnError) {
            out += " if (false) { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/oneOf.js
  var require_oneOf = __commonJS({
    "../../node_modules/ajv/lib/dotjs/oneOf.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_oneOf(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
        out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              out += "  " + it.validate($it) + " ";
              $it.baseId = $currentBaseId;
            } else {
              out += " var " + $nextValid + " = true; ";
            }
            if ($i) {
              out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
              $closingBraces += "}";
            }
            out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match exactly one schema in oneOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
        if (it.opts.allErrors) {
          out += " } ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/pattern.js
  var require_pattern = __commonJS({
    "../../node_modules/ajv/lib/dotjs/pattern.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_pattern(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " !" + $regexp + ".test(" + $data + ") ) {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
          if ($isData) {
            out += "" + $schemaValue;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "  } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match pattern "`;
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + it.util.escapeQuotes($schema);
            }
            out += `"' `;
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + it.util.toQuotedString($schema);
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/properties.js
  var require_properties = __commonJS({
    "../../node_modules/ajv/lib/dotjs/properties.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_properties(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
        var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        var $required = it.schema.required;
        if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
          var $requiredHash = it.util.toHash($required);
        }
        function notProto(p) {
          return p !== "__proto__";
        }
        out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined;";
        }
        if ($checkAdditional) {
          if ($ownProperties) {
            out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
          } else {
            out += " for (var " + $key + " in " + $data + ") { ";
          }
          if ($someProperties) {
            out += " var isAdditional" + $lvl + " = !(false ";
            if ($schemaKeys.length) {
              if ($schemaKeys.length > 8) {
                out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
              } else {
                var arr1 = $schemaKeys;
                if (arr1) {
                  var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                  while (i1 < l1) {
                    $propertyKey = arr1[i1 += 1];
                    out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                  }
                }
              }
            }
            if ($pPropertyKeys.length) {
              var arr2 = $pPropertyKeys;
              if (arr2) {
                var $pProperty, $i = -1, l2 = arr2.length - 1;
                while ($i < l2) {
                  $pProperty = arr2[$i += 1];
                  out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
                }
              }
            }
            out += " ); if (isAdditional" + $lvl + ") { ";
          }
          if ($removeAdditional == "all") {
            out += " delete " + $data + "[" + $key + "]; ";
          } else {
            var $currentErrorPath = it.errorPath;
            var $additionalProperty = "' + " + $key + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            }
            if ($noAdditional) {
              if ($removeAdditional) {
                out += " delete " + $data + "[" + $key + "]; ";
              } else {
                out += " " + $nextValid + " = false; ";
                var $currErrSchemaPath = $errSchemaPath;
                $errSchemaPath = it.errSchemaPath + "/additionalProperties";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is an invalid additional property";
                    } else {
                      out += "should NOT have additional properties";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                $errSchemaPath = $currErrSchemaPath;
                if ($breakOnError) {
                  out += " break; ";
                }
              }
            } else if ($additionalIsSchema) {
              if ($removeAdditional == "failing") {
                out += " var " + $errs + " = errors;  ";
                var $wasComposite = it.compositeRule;
                it.compositeRule = $it.compositeRule = true;
                $it.schema = $aProperties;
                $it.schemaPath = it.schemaPath + ".additionalProperties";
                $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
                $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                var $passData = $data + "[" + $key + "]";
                $it.dataPathArr[$dataNxt] = $key;
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
                it.compositeRule = $it.compositeRule = $wasComposite;
              } else {
                $it.schema = $aProperties;
                $it.schemaPath = it.schemaPath + ".additionalProperties";
                $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
                $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                var $passData = $data + "[" + $key + "]";
                $it.dataPathArr[$dataNxt] = $key;
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                if ($breakOnError) {
                  out += " if (!" + $nextValid + ") break; ";
                }
              }
            }
            it.errorPath = $currentErrorPath;
          }
          if ($someProperties) {
            out += " } ";
          }
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
        var $useDefaults = it.opts.useDefaults && !it.compositeRule;
        if ($schemaKeys.length) {
          var arr3 = $schemaKeys;
          if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[i3 += 1];
              var $sch = $schema[$propertyKey];
              if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + $prop;
                $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
                $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
                $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  $code = it.util.varReplace($code, $nextData, $passData);
                  var $useData = $passData;
                } else {
                  var $useData = $nextData;
                  out += " var " + $nextData + " = " + $passData + "; ";
                }
                if ($hasDefault) {
                  out += " " + $code + " ";
                } else {
                  if ($requiredHash && $requiredHash[$propertyKey]) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = false; ";
                    var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                    if (it.opts._errorDataPathProperty) {
                      it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                    }
                    $errSchemaPath = it.errSchemaPath + "/required";
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = "";
                    if (it.createErrors !== false) {
                      out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                      if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) {
                          out += "is a required property";
                        } else {
                          out += "should have required property \\'" + $missingProperty + "\\'";
                        }
                        out += "' ";
                      }
                      if (it.opts.verbose) {
                        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                      }
                      out += " } ";
                    } else {
                      out += " {} ";
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                      if (it.async) {
                        out += " throw new ValidationError([" + __err + "]); ";
                      } else {
                        out += " validate.errors = [" + __err + "]; return false; ";
                      }
                    } else {
                      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    }
                    $errSchemaPath = $currErrSchemaPath;
                    it.errorPath = $currentErrorPath;
                    out += " } else { ";
                  } else {
                    if ($breakOnError) {
                      out += " if ( " + $useData + " === undefined ";
                      if ($ownProperties) {
                        out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                      }
                      out += ") { " + $nextValid + " = true; } else { ";
                    } else {
                      out += " if (" + $useData + " !== undefined ";
                      if ($ownProperties) {
                        out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                      }
                      out += " ) { ";
                    }
                  }
                  out += " " + $code + " } ";
                }
              }
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr4 = $pPropertyKeys;
          if (arr4) {
            var $pProperty, i4 = -1, l4 = arr4.length - 1;
            while (i4 < l4) {
              $pProperty = arr4[i4 += 1];
              var $sch = $pProperties[$pProperty];
              if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                $it.schema = $sch;
                $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
                $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
                if ($ownProperties) {
                  out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
                } else {
                  out += " for (var " + $key + " in " + $data + ") { ";
                }
                out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
                $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                var $passData = $data + "[" + $key + "]";
                $it.dataPathArr[$dataNxt] = $key;
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                if ($breakOnError) {
                  out += " if (!" + $nextValid + ") break; ";
                }
                out += " } ";
                if ($breakOnError) {
                  out += " else " + $nextValid + " = true; ";
                }
                out += " }  ";
                if ($breakOnError) {
                  out += " if (" + $nextValid + ") { ";
                  $closingBraces += "}";
                }
              }
            }
          }
        }
        if ($breakOnError) {
          out += " " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/propertyNames.js
  var require_propertyNames = __commonJS({
    "../../node_modules/ajv/lib/dotjs/propertyNames.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        out += "var " + $errs + " = errors;";
        if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
          if ($ownProperties) {
            out += " var " + $dataProperties + " = undefined; ";
          }
          if ($ownProperties) {
            out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
          } else {
            out += " for (var " + $key + " in " + $data + ") { ";
          }
          out += " var startErrs" + $lvl + " = errors; ";
          var $passData = $key;
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
          if ($breakOnError) {
            out += " break; ";
          }
          out += " } }";
        }
        if ($breakOnError) {
          out += " " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/required.js
  var require_required = __commonJS({
    "../../node_modules/ajv/lib/dotjs/required.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_required(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $vSchema = "schema" + $lvl;
        if (!$isData) {
          if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
            var $required = [];
            var arr1 = $schema;
            if (arr1) {
              var $property, i1 = -1, l1 = arr1.length - 1;
              while (i1 < l1) {
                $property = arr1[i1 += 1];
                var $propertySch = it.schema.properties[$property];
                if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                  $required[$required.length] = $property;
                }
              }
            }
          } else {
            var $required = $schema;
          }
        }
        if ($isData || $required.length) {
          var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
          if ($breakOnError) {
            out += " var missing" + $lvl + "; ";
            if ($loopRequired) {
              if (!$isData) {
                out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
              }
              var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
              }
              out += " var " + $valid + " = true; ";
              if ($isData) {
                out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
              }
              out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
              if ($ownProperties) {
                out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
              }
              out += "; if (!" + $valid + ") break; } ";
              if ($isData) {
                out += "  }  ";
              }
              out += "  if (!" + $valid + ") {   ";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } else { ";
            } else {
              out += " if ( ";
              var arr2 = $required;
              if (arr2) {
                var $propertyKey, $i = -1, l2 = arr2.length - 1;
                while ($i < l2) {
                  $propertyKey = arr2[$i += 1];
                  if ($i) {
                    out += " || ";
                  }
                  var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                  out += " ( ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                }
              }
              out += ") {  ";
              var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
              }
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } else { ";
            }
          } else {
            if ($loopRequired) {
              if (!$isData) {
                out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
              }
              var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
              }
              if ($isData) {
                out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
              }
              out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
              if ($isData) {
                out += "  }  ";
              }
            } else {
              var arr3 = $required;
              if (arr3) {
                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") {  var err =   ";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
              }
            }
          }
          it.errorPath = $currentErrorPath;
        } else if ($breakOnError) {
          out += " if (true) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/uniqueItems.js
  var require_uniqueItems = __commonJS({
    "../../node_modules/ajv/lib/dotjs/uniqueItems.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (($schema || $isData) && it.opts.uniqueItems !== false) {
          if ($isData) {
            out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
          }
          out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
          var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
          if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
            out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
          } else {
            out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
            var $method = "checkDataType" + ($typeIsArray ? "s" : "");
            out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
            if ($typeIsArray) {
              out += ` if (typeof item == 'string') item = '"' + item; `;
            }
            out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
          }
          out += " } ";
          if ($isData) {
            out += "  }  ";
          }
          out += " if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
            }
            if (it.opts.verbose) {
              out += " , schema:  ";
              if ($isData) {
                out += "validate.schema" + $schemaPath;
              } else {
                out += "" + $schema;
              }
              out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " else { ";
          }
        } else {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/index.js
  var require_dotjs = __commonJS({
    "../../node_modules/ajv/lib/dotjs/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = {
        "$ref": require_ref(),
        allOf: require_allOf(),
        anyOf: require_anyOf(),
        "$comment": require_comment(),
        const: require_const(),
        contains: require_contains(),
        dependencies: require_dependencies(),
        "enum": require_enum(),
        format: require_format(),
        "if": require_if(),
        items: require_items(),
        maximum: require_limit(),
        minimum: require_limit(),
        maxItems: require_limitItems(),
        minItems: require_limitItems(),
        maxLength: require_limitLength(),
        minLength: require_limitLength(),
        maxProperties: require_limitProperties(),
        minProperties: require_limitProperties(),
        multipleOf: require_multipleOf(),
        not: require_not(),
        oneOf: require_oneOf(),
        pattern: require_pattern(),
        properties: require_properties(),
        propertyNames: require_propertyNames(),
        required: require_required(),
        uniqueItems: require_uniqueItems(),
        validate: require_validate()
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/rules.js
  var require_rules = __commonJS({
    "../../node_modules/ajv/lib/compile/rules.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var ruleModules = require_dotjs();
      var toHash = require_util().toHash;
      module.exports = function rules() {
        var RULES = [
          {
            type: "number",
            rules: [
              { "maximum": ["exclusiveMaximum"] },
              { "minimum": ["exclusiveMinimum"] },
              "multipleOf",
              "format"
            ]
          },
          {
            type: "string",
            rules: ["maxLength", "minLength", "pattern", "format"]
          },
          {
            type: "array",
            rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
          },
          {
            type: "object",
            rules: [
              "maxProperties",
              "minProperties",
              "required",
              "dependencies",
              "propertyNames",
              { "properties": ["additionalProperties", "patternProperties"] }
            ]
          },
          { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
        ];
        var ALL = ["type", "$comment"];
        var KEYWORDS = [
          "$schema",
          "$id",
          "id",
          "$data",
          "$async",
          "title",
          "description",
          "default",
          "definitions",
          "examples",
          "readOnly",
          "writeOnly",
          "contentMediaType",
          "contentEncoding",
          "additionalItems",
          "then",
          "else"
        ];
        var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
        RULES.all = toHash(ALL);
        RULES.types = toHash(TYPES);
        RULES.forEach(function(group) {
          group.rules = group.rules.map(function(keyword) {
            var implKeywords;
            if (typeof keyword == "object") {
              var key = Object.keys(keyword)[0];
              implKeywords = keyword[key];
              keyword = key;
              implKeywords.forEach(function(k) {
                ALL.push(k);
                RULES.all[k] = true;
              });
            }
            ALL.push(keyword);
            var rule = RULES.all[keyword] = {
              keyword,
              code: ruleModules[keyword],
              implements: implKeywords
            };
            return rule;
          });
          RULES.all.$comment = {
            keyword: "$comment",
            code: ruleModules.$comment
          };
          if (group.type) RULES.types[group.type] = group;
        });
        RULES.keywords = toHash(ALL.concat(KEYWORDS));
        RULES.custom = {};
        return RULES;
      };
    }
  });

  // ../../node_modules/ajv/lib/data.js
  var require_data = __commonJS({
    "../../node_modules/ajv/lib/data.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var KEYWORDS = [
        "multipleOf",
        "maximum",
        "exclusiveMaximum",
        "minimum",
        "exclusiveMinimum",
        "maxLength",
        "minLength",
        "pattern",
        "additionalItems",
        "maxItems",
        "minItems",
        "uniqueItems",
        "maxProperties",
        "minProperties",
        "required",
        "additionalProperties",
        "enum",
        "format",
        "const"
      ];
      module.exports = function(metaSchema, keywordsJsonPointers) {
        for (var i = 0; i < keywordsJsonPointers.length; i++) {
          metaSchema = JSON.parse(JSON.stringify(metaSchema));
          var segments = keywordsJsonPointers[i].split("/");
          var keywords = metaSchema;
          var j;
          for (j = 1; j < segments.length; j++)
            keywords = keywords[segments[j]];
          for (j = 0; j < KEYWORDS.length; j++) {
            var key = KEYWORDS[j];
            var schema = keywords[key];
            if (schema) {
              keywords[key] = {
                anyOf: [
                  schema,
                  { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
                ]
              };
            }
          }
        }
        return metaSchema;
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/async.js
  var require_async = __commonJS({
    "../../node_modules/ajv/lib/compile/async.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var MissingRefError = require_error_classes().MissingRef;
      module.exports = compileAsync;
      function compileAsync(schema, meta, callback) {
        var self = this;
        if (typeof this._opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        if (typeof meta == "function") {
          callback = meta;
          meta = void 0;
        }
        var p = loadMetaSchemaOf(schema).then(function() {
          var schemaObj = self._addSchema(schema, void 0, meta);
          return schemaObj.validate || _compileAsync(schemaObj);
        });
        if (callback) {
          p.then(
            function(v) {
              callback(null, v);
            },
            callback
          );
        }
        return p;
        function loadMetaSchemaOf(sch) {
          var $schema = sch.$schema;
          return $schema && !self.getSchema($schema) ? compileAsync.call(self, { $ref: $schema }, true) : Promise.resolve();
        }
        function _compileAsync(schemaObj) {
          try {
            return self._compile(schemaObj);
          } catch (e) {
            if (e instanceof MissingRefError) return loadMissingSchema(e);
            throw e;
          }
          function loadMissingSchema(e) {
            var ref = e.missingSchema;
            if (added(ref)) throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
            var schemaPromise = self._loadingSchemas[ref];
            if (!schemaPromise) {
              schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
              schemaPromise.then(removePromise, removePromise);
            }
            return schemaPromise.then(function(sch) {
              if (!added(ref)) {
                return loadMetaSchemaOf(sch).then(function() {
                  if (!added(ref)) self.addSchema(sch, ref, void 0, meta);
                });
              }
            }).then(function() {
              return _compileAsync(schemaObj);
            });
            function removePromise() {
              delete self._loadingSchemas[ref];
            }
            function added(ref2) {
              return self._refs[ref2] || self._schemas[ref2];
            }
          }
        }
      }
    }
  });

  // ../../node_modules/ajv/lib/dotjs/custom.js
  var require_custom = __commonJS({
    "../../node_modules/ajv/lib/dotjs/custom.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      module.exports = function generate_custom(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
        var $compile, $inline, $macro, $ruleValidate, $validateCode;
        if ($isData && $rDef.$data) {
          $validateCode = "keywordValidate" + $lvl;
          var $validateSchema = $rDef.validateSchema;
          out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
        } else {
          $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
          if (!$ruleValidate) return;
          $schemaValue = "validate.schema" + $schemaPath;
          $validateCode = $ruleValidate.code;
          $compile = $rDef.compile;
          $inline = $rDef.inline;
          $macro = $rDef.macro;
        }
        var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
        if ($asyncKeyword && !it.async) throw new Error("async keyword in sync schema");
        if (!($inline || $macro)) {
          out += "" + $ruleErrs + " = null;";
        }
        out += "var " + $errs + " = errors;var " + $valid + ";";
        if ($isData && $rDef.$data) {
          $closingBraces += "}";
          out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
          if ($validateSchema) {
            $closingBraces += "}";
            out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
          }
        }
        if ($inline) {
          if ($rDef.statements) {
            out += " " + $ruleValidate.validate + " ";
          } else {
            out += " " + $valid + " = " + $ruleValidate.validate + "; ";
          }
        } else if ($macro) {
          var $it = it.util.copy(it);
          var $closingBraces = "";
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $ruleValidate.validate;
          $it.schemaPath = "";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " " + $code;
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          out += "  " + $validateCode + ".call( ";
          if (it.opts.passContext) {
            out += "this";
          } else {
            out += "self";
          }
          if ($compile || $rDef.schema === false) {
            out += " , " + $data + " ";
          } else {
            out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
          }
          out += " , (dataPath || '')";
          if (it.errorPath != '""') {
            out += " + " + it.errorPath;
          }
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
          var def_callRuleValidate = out;
          out = $$outStack.pop();
          if ($rDef.errors === false) {
            out += " " + $valid + " = ";
            if ($asyncKeyword) {
              out += "await ";
            }
            out += "" + def_callRuleValidate + "; ";
          } else {
            if ($asyncKeyword) {
              $ruleErrs = "customErrors" + $lvl;
              out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
            } else {
              out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
            }
          }
        }
        if ($rDef.modifying) {
          out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
        }
        out += "" + $closingBraces;
        if ($rDef.valid) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        } else {
          out += " if ( ";
          if ($rDef.valid === void 0) {
            out += " !";
            if ($macro) {
              out += "" + $nextValid;
            } else {
              out += "" + $valid;
            }
          } else {
            out += " " + !$rDef.valid + " ";
          }
          out += ") { ";
          $errorKeyword = $rule.keyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          var def_customError = out;
          out = $$outStack.pop();
          if ($inline) {
            if ($rDef.errors) {
              if ($rDef.errors != "full") {
                out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                if (it.opts.verbose) {
                  out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                }
                out += " } ";
              }
            } else {
              if ($rDef.errors === false) {
                out += " " + def_customError + " ";
              } else {
                out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                if (it.opts.verbose) {
                  out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                }
                out += " } } ";
              }
            }
          } else if ($macro) {
            out += "   var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
              if (it.opts.messages !== false) {
                out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError(vErrors); ";
              } else {
                out += " validate.errors = vErrors; return false; ";
              }
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } else { " + def_customError + " } ";
            }
          }
          out += " } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/refs/json-schema-draft-07.json
  var require_json_schema_draft_07 = __commonJS({
    "../../node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports, module) {
      module.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "http://json-schema.org/draft-07/schema#",
        title: "Core schema meta-schema",
        definitions: {
          schemaArray: {
            type: "array",
            minItems: 1,
            items: { $ref: "#" }
          },
          nonNegativeInteger: {
            type: "integer",
            minimum: 0
          },
          nonNegativeIntegerDefault0: {
            allOf: [
              { $ref: "#/definitions/nonNegativeInteger" },
              { default: 0 }
            ]
          },
          simpleTypes: {
            enum: [
              "array",
              "boolean",
              "integer",
              "null",
              "number",
              "object",
              "string"
            ]
          },
          stringArray: {
            type: "array",
            items: { type: "string" },
            uniqueItems: true,
            default: []
          }
        },
        type: ["object", "boolean"],
        properties: {
          $id: {
            type: "string",
            format: "uri-reference"
          },
          $schema: {
            type: "string",
            format: "uri"
          },
          $ref: {
            type: "string",
            format: "uri-reference"
          },
          $comment: {
            type: "string"
          },
          title: {
            type: "string"
          },
          description: {
            type: "string"
          },
          default: true,
          readOnly: {
            type: "boolean",
            default: false
          },
          examples: {
            type: "array",
            items: true
          },
          multipleOf: {
            type: "number",
            exclusiveMinimum: 0
          },
          maximum: {
            type: "number"
          },
          exclusiveMaximum: {
            type: "number"
          },
          minimum: {
            type: "number"
          },
          exclusiveMinimum: {
            type: "number"
          },
          maxLength: { $ref: "#/definitions/nonNegativeInteger" },
          minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          pattern: {
            type: "string",
            format: "regex"
          },
          additionalItems: { $ref: "#" },
          items: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/schemaArray" }
            ],
            default: true
          },
          maxItems: { $ref: "#/definitions/nonNegativeInteger" },
          minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          uniqueItems: {
            type: "boolean",
            default: false
          },
          contains: { $ref: "#" },
          maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
          minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          required: { $ref: "#/definitions/stringArray" },
          additionalProperties: { $ref: "#" },
          definitions: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          properties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          patternProperties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            propertyNames: { format: "regex" },
            default: {}
          },
          dependencies: {
            type: "object",
            additionalProperties: {
              anyOf: [
                { $ref: "#" },
                { $ref: "#/definitions/stringArray" }
              ]
            }
          },
          propertyNames: { $ref: "#" },
          const: true,
          enum: {
            type: "array",
            items: true,
            minItems: 1,
            uniqueItems: true
          },
          type: {
            anyOf: [
              { $ref: "#/definitions/simpleTypes" },
              {
                type: "array",
                items: { $ref: "#/definitions/simpleTypes" },
                minItems: 1,
                uniqueItems: true
              }
            ]
          },
          format: { type: "string" },
          contentMediaType: { type: "string" },
          contentEncoding: { type: "string" },
          if: { $ref: "#" },
          then: { $ref: "#" },
          else: { $ref: "#" },
          allOf: { $ref: "#/definitions/schemaArray" },
          anyOf: { $ref: "#/definitions/schemaArray" },
          oneOf: { $ref: "#/definitions/schemaArray" },
          not: { $ref: "#" }
        },
        default: true
      };
    }
  });

  // ../../node_modules/ajv/lib/definition_schema.js
  var require_definition_schema = __commonJS({
    "../../node_modules/ajv/lib/definition_schema.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var metaSchema = require_json_schema_draft_07();
      module.exports = {
        $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
        definitions: {
          simpleTypes: metaSchema.definitions.simpleTypes
        },
        type: "object",
        dependencies: {
          schema: ["validate"],
          $data: ["validate"],
          statements: ["inline"],
          valid: { not: { required: ["macro"] } }
        },
        properties: {
          type: metaSchema.properties.type,
          schema: { type: "boolean" },
          statements: { type: "boolean" },
          dependencies: {
            type: "array",
            items: { type: "string" }
          },
          metaSchema: { type: "object" },
          modifying: { type: "boolean" },
          valid: { type: "boolean" },
          $data: { type: "boolean" },
          async: { type: "boolean" },
          errors: {
            anyOf: [
              { type: "boolean" },
              { const: "full" }
            ]
          }
        }
      };
    }
  });

  // ../../node_modules/ajv/lib/keyword.js
  var require_keyword = __commonJS({
    "../../node_modules/ajv/lib/keyword.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
      var customRuleCode = require_custom();
      var definitionSchema = require_definition_schema();
      module.exports = {
        add: addKeyword,
        get: getKeyword,
        remove: removeKeyword,
        validate: validateKeyword
      };
      function addKeyword(keyword, definition) {
        var RULES = this.RULES;
        if (RULES.keywords[keyword])
          throw new Error("Keyword " + keyword + " is already defined");
        if (!IDENTIFIER.test(keyword))
          throw new Error("Keyword " + keyword + " is not a valid identifier");
        if (definition) {
          this.validateKeyword(definition, true);
          var dataType = definition.type;
          if (Array.isArray(dataType)) {
            for (var i = 0; i < dataType.length; i++)
              _addRule(keyword, dataType[i], definition);
          } else {
            _addRule(keyword, dataType, definition);
          }
          var metaSchema = definition.metaSchema;
          if (metaSchema) {
            if (definition.$data && this._opts.$data) {
              metaSchema = {
                anyOf: [
                  metaSchema,
                  { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
                ]
              };
            }
            definition.validateSchema = this.compile(metaSchema, true);
          }
        }
        RULES.keywords[keyword] = RULES.all[keyword] = true;
        function _addRule(keyword2, dataType2, definition2) {
          var ruleGroup;
          for (var i2 = 0; i2 < RULES.length; i2++) {
            var rg = RULES[i2];
            if (rg.type == dataType2) {
              ruleGroup = rg;
              break;
            }
          }
          if (!ruleGroup) {
            ruleGroup = { type: dataType2, rules: [] };
            RULES.push(ruleGroup);
          }
          var rule = {
            keyword: keyword2,
            definition: definition2,
            custom: true,
            code: customRuleCode,
            implements: definition2.implements
          };
          ruleGroup.rules.push(rule);
          RULES.custom[keyword2] = rule;
        }
        return this;
      }
      function getKeyword(keyword) {
        var rule = this.RULES.custom[keyword];
        return rule ? rule.definition : this.RULES.keywords[keyword] || false;
      }
      function removeKeyword(keyword) {
        var RULES = this.RULES;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        delete RULES.custom[keyword];
        for (var i = 0; i < RULES.length; i++) {
          var rules = RULES[i].rules;
          for (var j = 0; j < rules.length; j++) {
            if (rules[j].keyword == keyword) {
              rules.splice(j, 1);
              break;
            }
          }
        }
        return this;
      }
      function validateKeyword(definition, throwError) {
        validateKeyword.errors = null;
        var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
        if (v(definition)) return true;
        validateKeyword.errors = v.errors;
        if (throwError)
          throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
        else
          return false;
      }
    }
  });

  // ../../node_modules/ajv/lib/refs/data.json
  var require_data2 = __commonJS({
    "../../node_modules/ajv/lib/refs/data.json"(exports, module) {
      module.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
        description: "Meta-schema for $data reference (JSON Schema extension proposal)",
        type: "object",
        required: ["$data"],
        properties: {
          $data: {
            type: "string",
            anyOf: [
              { format: "relative-json-pointer" },
              { format: "json-pointer" }
            ]
          }
        },
        additionalProperties: false
      };
    }
  });

  // ../../node_modules/ajv/lib/ajv.js
  var require_ajv = __commonJS({
    "../../node_modules/ajv/lib/ajv.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var compileSchema = require_compile();
      var resolve = require_resolve();
      var Cache = require_cache();
      var SchemaObject = require_schema_obj();
      var stableStringify = require_fast_json_stable_stringify();
      var formats = require_formats();
      var rules = require_rules();
      var $dataMetaSchema = require_data();
      var util2 = require_util();
      module.exports = Ajv2;
      Ajv2.prototype.validate = validate;
      Ajv2.prototype.compile = compile;
      Ajv2.prototype.addSchema = addSchema;
      Ajv2.prototype.addMetaSchema = addMetaSchema;
      Ajv2.prototype.validateSchema = validateSchema;
      Ajv2.prototype.getSchema = getSchema;
      Ajv2.prototype.removeSchema = removeSchema;
      Ajv2.prototype.addFormat = addFormat;
      Ajv2.prototype.errorsText = errorsText;
      Ajv2.prototype._addSchema = _addSchema;
      Ajv2.prototype._compile = _compile;
      Ajv2.prototype.compileAsync = require_async();
      var customKeyword = require_keyword();
      Ajv2.prototype.addKeyword = customKeyword.add;
      Ajv2.prototype.getKeyword = customKeyword.get;
      Ajv2.prototype.removeKeyword = customKeyword.remove;
      Ajv2.prototype.validateKeyword = customKeyword.validate;
      var errorClasses = require_error_classes();
      Ajv2.ValidationError = errorClasses.Validation;
      Ajv2.MissingRefError = errorClasses.MissingRef;
      Ajv2.$dataMetaSchema = $dataMetaSchema;
      var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
      var META_SUPPORT_DATA = ["/properties"];
      function Ajv2(opts) {
        if (!(this instanceof Ajv2)) return new Ajv2(opts);
        opts = this._opts = util2.copy(opts) || {};
        setLogger(this);
        this._schemas = {};
        this._refs = {};
        this._fragments = {};
        this._formats = formats(opts.format);
        this._cache = opts.cache || new Cache();
        this._loadingSchemas = {};
        this._compilations = [];
        this.RULES = rules();
        this._getId = chooseGetId(opts);
        opts.loopRequired = opts.loopRequired || Infinity;
        if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
        if (opts.serialize === void 0) opts.serialize = stableStringify;
        this._metaOpts = getMetaSchemaOptions(this);
        if (opts.formats) addInitialFormats(this);
        if (opts.keywords) addInitialKeywords(this);
        addDefaultMetaSchema(this);
        if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
        if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
        addInitialSchemas(this);
      }
      function validate(schemaKeyRef, data2) {
        var v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
        } else {
          var schemaObj = this._addSchema(schemaKeyRef);
          v = schemaObj.validate || this._compile(schemaObj);
        }
        var valid = v(data2);
        if (v.$async !== true) this.errors = v.errors;
        return valid;
      }
      function compile(schema, _meta) {
        var schemaObj = this._addSchema(schema, void 0, _meta);
        return schemaObj.validate || this._compile(schemaObj);
      }
      function addSchema(schema, key, _skipValidation, _meta) {
        if (Array.isArray(schema)) {
          for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], void 0, _skipValidation, _meta);
          return this;
        }
        var id = this._getId(schema);
        if (id !== void 0 && typeof id != "string")
          throw new Error("schema id must be string");
        key = resolve.normalizeId(key || id);
        checkUnique(this, key);
        this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
        return this;
      }
      function addMetaSchema(schema, key, skipValidation) {
        this.addSchema(schema, key, skipValidation, true);
        return this;
      }
      function validateSchema(schema, throwOrLogError) {
        var $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string")
          throw new Error("$schema must be a string");
        $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        var valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          var message = "schema is invalid: " + this.errorsText();
          if (this._opts.validateSchema == "log") this.logger.error(message);
          else throw new Error(message);
        }
        return valid;
      }
      function defaultMeta(self) {
        var meta = self._opts.meta;
        self._opts.defaultMeta = typeof meta == "object" ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
        return self._opts.defaultMeta;
      }
      function getSchema(keyRef) {
        var schemaObj = _getSchemaObj(this, keyRef);
        switch (typeof schemaObj) {
          case "object":
            return schemaObj.validate || this._compile(schemaObj);
          case "string":
            return this.getSchema(schemaObj);
          case "undefined":
            return _getSchemaFragment(this, keyRef);
        }
      }
      function _getSchemaFragment(self, ref) {
        var res = resolve.schema.call(self, { schema: {} }, ref);
        if (res) {
          var schema = res.schema, root = res.root, baseId = res.baseId;
          var v = compileSchema.call(self, schema, root, void 0, baseId);
          self._fragments[ref] = new SchemaObject({
            ref,
            fragment: true,
            schema,
            root,
            baseId,
            validate: v
          });
          return v;
        }
      }
      function _getSchemaObj(self, keyRef) {
        keyRef = resolve.normalizeId(keyRef);
        return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
      }
      function removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          _removeAllSchemas(this, this._schemas, schemaKeyRef);
          _removeAllSchemas(this, this._refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            _removeAllSchemas(this, this._schemas);
            _removeAllSchemas(this, this._refs);
            this._cache.clear();
            return this;
          case "string":
            var schemaObj = _getSchemaObj(this, schemaKeyRef);
            if (schemaObj) this._cache.del(schemaObj.cacheKey);
            delete this._schemas[schemaKeyRef];
            delete this._refs[schemaKeyRef];
            return this;
          case "object":
            var serialize2 = this._opts.serialize;
            var cacheKey = serialize2 ? serialize2(schemaKeyRef) : schemaKeyRef;
            this._cache.del(cacheKey);
            var id = this._getId(schemaKeyRef);
            if (id) {
              id = resolve.normalizeId(id);
              delete this._schemas[id];
              delete this._refs[id];
            }
        }
        return this;
      }
      function _removeAllSchemas(self, schemas, regex) {
        for (var keyRef in schemas) {
          var schemaObj = schemas[keyRef];
          if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
            self._cache.del(schemaObj.cacheKey);
            delete schemas[keyRef];
          }
        }
      }
      function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
        if (typeof schema != "object" && typeof schema != "boolean")
          throw new Error("schema should be object or boolean");
        var serialize2 = this._opts.serialize;
        var cacheKey = serialize2 ? serialize2(schema) : schema;
        var cached = this._cache.get(cacheKey);
        if (cached) return cached;
        shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
        var id = resolve.normalizeId(this._getId(schema));
        if (id && shouldAddSchema) checkUnique(this, id);
        var willValidate = this._opts.validateSchema !== false && !skipValidation;
        var recursiveMeta;
        if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
          this.validateSchema(schema, true);
        var localRefs = resolve.ids.call(this, schema);
        var schemaObj = new SchemaObject({
          id,
          schema,
          localRefs,
          cacheKey,
          meta
        });
        if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
        this._cache.put(cacheKey, schemaObj);
        if (willValidate && recursiveMeta) this.validateSchema(schema, true);
        return schemaObj;
      }
      function _compile(schemaObj, root) {
        if (schemaObj.compiling) {
          schemaObj.validate = callValidate;
          callValidate.schema = schemaObj.schema;
          callValidate.errors = null;
          callValidate.root = root ? root : callValidate;
          if (schemaObj.schema.$async === true)
            callValidate.$async = true;
          return callValidate;
        }
        schemaObj.compiling = true;
        var currentOpts;
        if (schemaObj.meta) {
          currentOpts = this._opts;
          this._opts = this._metaOpts;
        }
        var v;
        try {
          v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
        } catch (e) {
          delete schemaObj.validate;
          throw e;
        } finally {
          schemaObj.compiling = false;
          if (schemaObj.meta) this._opts = currentOpts;
        }
        schemaObj.validate = v;
        schemaObj.refs = v.refs;
        schemaObj.refVal = v.refVal;
        schemaObj.root = v.root;
        return v;
        function callValidate() {
          var _validate = schemaObj.validate;
          var result = _validate.apply(this, arguments);
          callValidate.errors = _validate.errors;
          return result;
        }
      }
      function chooseGetId(opts) {
        switch (opts.schemaId) {
          case "auto":
            return _get$IdOrId;
          case "id":
            return _getId;
          default:
            return _get$Id;
        }
      }
      function _getId(schema) {
        if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
        return schema.id;
      }
      function _get$Id(schema) {
        if (schema.id) this.logger.warn("schema id ignored", schema.id);
        return schema.$id;
      }
      function _get$IdOrId(schema) {
        if (schema.$id && schema.id && schema.$id != schema.id)
          throw new Error("schema $id is different from id");
        return schema.$id || schema.id;
      }
      function errorsText(errors, options) {
        errors = errors || this.errors;
        if (!errors) return "No errors";
        options = options || {};
        var separator = options.separator === void 0 ? ", " : options.separator;
        var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
        var text = "";
        for (var i = 0; i < errors.length; i++) {
          var e = errors[i];
          if (e) text += dataVar + e.dataPath + " " + e.message + separator;
        }
        return text.slice(0, -separator.length);
      }
      function addFormat(name, format) {
        if (typeof format == "string") format = new RegExp(format);
        this._formats[name] = format;
        return this;
      }
      function addDefaultMetaSchema(self) {
        var $dataSchema;
        if (self._opts.$data) {
          $dataSchema = require_data2();
          self.addMetaSchema($dataSchema, $dataSchema.$id, true);
        }
        if (self._opts.meta === false) return;
        var metaSchema = require_json_schema_draft_07();
        if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
        self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
        self._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      function addInitialSchemas(self) {
        var optsSchemas = self._opts.schemas;
        if (!optsSchemas) return;
        if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
        else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats(self) {
        for (var name in self._opts.formats) {
          var format = self._opts.formats[name];
          self.addFormat(name, format);
        }
      }
      function addInitialKeywords(self) {
        for (var name in self._opts.keywords) {
          var keyword = self._opts.keywords[name];
          self.addKeyword(name, keyword);
        }
      }
      function checkUnique(self, id) {
        if (self._schemas[id] || self._refs[id])
          throw new Error('schema with key or id "' + id + '" already exists');
      }
      function getMetaSchemaOptions(self) {
        var metaOpts = util2.copy(self._opts);
        for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
          delete metaOpts[META_IGNORE_OPTIONS[i]];
        return metaOpts;
      }
      function setLogger(self) {
        var logger = self._opts.logger;
        if (logger === false) {
          self.logger = { log: noop3, warn: noop3, error: noop3 };
        } else {
          if (logger === void 0) logger = console;
          if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
            throw new Error("logger must implement log, warn and error methods");
          self.logger = logger;
        }
      }
      function noop3() {
      }
    }
  });

  // ../../node_modules/react-is/cjs/react-is.production.min.js
  var require_react_is_production_min = __commonJS({
    "../../node_modules/react-is/cjs/react-is.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      var b = 60103;
      var c = 60106;
      var d = 60107;
      var e = 60108;
      var f = 60114;
      var g = 60109;
      var h = 60110;
      var k = 60112;
      var l = 60113;
      var m = 60120;
      var n = 60115;
      var p = 60116;
      var q = 60121;
      var r = 60122;
      var u = 60117;
      var v = 60129;
      var w = 60131;
      if ("function" === typeof Symbol && Symbol.for) {
        x = Symbol.for;
        b = x("react.element");
        c = x("react.portal");
        d = x("react.fragment");
        e = x("react.strict_mode");
        f = x("react.profiler");
        g = x("react.provider");
        h = x("react.context");
        k = x("react.forward_ref");
        l = x("react.suspense");
        m = x("react.suspense_list");
        n = x("react.memo");
        p = x("react.lazy");
        q = x("react.block");
        r = x("react.server.block");
        u = x("react.fundamental");
        v = x("react.debug_trace_mode");
        w = x("react.legacy_hidden");
      }
      var x;
      function y(a) {
        if ("object" === typeof a && null !== a) {
          var t = a.$$typeof;
          switch (t) {
            case b:
              switch (a = a.type, a) {
                case d:
                case f:
                case e:
                case l:
                case m:
                  return a;
                default:
                  switch (a = a && a.$$typeof, a) {
                    case h:
                    case k:
                    case p:
                    case n:
                    case g:
                      return a;
                    default:
                      return t;
                  }
              }
            case c:
              return t;
          }
        }
      }
      var z = g;
      var A = b;
      var B = k;
      var C = d;
      var D = p;
      var E = n;
      var F = c;
      var G = f;
      var H = e;
      var I = l;
      exports.ContextConsumer = h;
      exports.ContextProvider = z;
      exports.Element = A;
      exports.ForwardRef = B;
      exports.Fragment = C;
      exports.Lazy = D;
      exports.Memo = E;
      exports.Portal = F;
      exports.Profiler = G;
      exports.StrictMode = H;
      exports.Suspense = I;
      exports.isAsyncMode = function() {
        return false;
      };
      exports.isConcurrentMode = function() {
        return false;
      };
      exports.isContextConsumer = function(a) {
        return y(a) === h;
      };
      exports.isContextProvider = function(a) {
        return y(a) === g;
      };
      exports.isElement = function(a) {
        return "object" === typeof a && null !== a && a.$$typeof === b;
      };
      exports.isForwardRef = function(a) {
        return y(a) === k;
      };
      exports.isFragment = function(a) {
        return y(a) === d;
      };
      exports.isLazy = function(a) {
        return y(a) === p;
      };
      exports.isMemo = function(a) {
        return y(a) === n;
      };
      exports.isPortal = function(a) {
        return y(a) === c;
      };
      exports.isProfiler = function(a) {
        return y(a) === f;
      };
      exports.isStrictMode = function(a) {
        return y(a) === e;
      };
      exports.isSuspense = function(a) {
        return y(a) === l;
      };
      exports.isValidElementType = function(a) {
        return "string" === typeof a || "function" === typeof a || a === d || a === f || a === v || a === e || a === l || a === m || a === w || "object" === typeof a && null !== a && (a.$$typeof === p || a.$$typeof === n || a.$$typeof === g || a.$$typeof === h || a.$$typeof === k || a.$$typeof === u || a.$$typeof === q || a[0] === r) ? true : false;
      };
      exports.typeOf = y;
    }
  });

  // ../../node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "../../node_modules/react-is/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      if (true) {
        module.exports = require_react_is_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min2 = __commonJS({
    "../../node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a: for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
          else break a;
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length) return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
            else break a;
          }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l = performance;
        exports.unstable_now = function() {
          return l.now();
        };
      } else {
        p = Date, q = p.now();
        exports.unstable_now = function() {
          return p.now() - q;
        };
      }
      var l;
      var p;
      var q;
      var r = [];
      var t = [];
      var u = 1;
      var v = null;
      var y = 3;
      var z = false;
      var A = false;
      var B = false;
      var D = "function" === typeof setTimeout ? setTimeout : null;
      var E = "function" === typeof clearTimeout ? clearTimeout : null;
      var F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
          else break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A) if (null !== h(r)) A = true, I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L), L = -1);
        z = true;
        var c = y;
        try {
          G(b);
          for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r) && k(r);
              G(b);
            } else k(r);
            v = h(r);
          }
          if (null !== v) var w = true;
          else {
            var m = h(t);
            null !== m && K(H, m.startTime - b);
            w = false;
          }
          return w;
        } finally {
          v = null, y = c, z = false;
        }
      }
      var N = false;
      var O = null;
      var L = -1;
      var P = 5;
      var Q = -1;
      function M() {
        return exports.unstable_now() - Q < P ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports.unstable_now();
          Q = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else N = false;
      }
      var S;
      if ("function" === typeof F) S = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else S = function() {
        D(R, 0);
      };
      var T;
      var U;
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K(a, b) {
        L = D(function() {
          a(exports.unstable_now());
        }, b);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A || z || (A = true, I(J));
      };
      exports.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h(r);
      };
      exports.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports.unstable_scheduleCallback = function(a, b, c) {
        var d = exports.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
        return a;
      };
      exports.unstable_shouldYield = M;
      exports.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    }
  });

  // ../../node_modules/scheduler/index.js
  var require_scheduler2 = __commonJS({
    "../../node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      if (true) {
        module.exports = require_scheduler_production_min2();
      } else {
        module.exports = null;
      }
    }
  });

  // src/main.tsx
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_client2 = __toESM(require_client());

  // ../../node_modules/react-router/dist/development/index.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/react-router/dist/development/chunk-QMGIS6GS.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React3 = __toESM(require_react(), 1);
  var React = __toESM(require_react(), 1);
  var React2 = __toESM(require_react(), 1);
  var React10 = __toESM(require_react(), 1);
  var React9 = __toESM(require_react(), 1);
  var React4 = __toESM(require_react(), 1);
  var React8 = __toESM(require_react(), 1);
  var React7 = __toESM(require_react(), 1);
  var React5 = __toESM(require_react(), 1);
  var React6 = __toESM(require_react(), 1);
  var React11 = __toESM(require_react(), 1);
  var React12 = __toESM(require_react(), 1);
  var React13 = __toESM(require_react(), 1);
  var import_cookie = __toESM(require_dist(), 1);
  var import_meta = {};
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var PopStateEventType = "popstate";
  function createBrowserHistory(options = {}) {
    function createBrowserLocation(window2, globalHistory) {
      let { pathname, search, hash } = window2.location;
      return createLocation(
        "",
        { pathname, search, hash },
        // state defaults to `null` because `window.history.state` does
        globalHistory.state && globalHistory.state.usr || null,
        globalHistory.state && globalHistory.state.key || "default"
      );
    }
    function createBrowserHref(window2, to) {
      return typeof to === "string" ? to : createPath(to);
    }
    return getUrlBasedHistory(
      createBrowserLocation,
      createBrowserHref,
      null,
      options
    );
  }
  function invariant(value, message) {
    if (value === false || value === null || typeof value === "undefined") {
      throw new Error(message);
    }
  }
  function warning(cond, message) {
    if (!cond) {
      if (typeof console !== "undefined") console.warn(message);
      try {
        throw new Error(message);
      } catch (e) {
      }
    }
  }
  function createKey() {
    return Math.random().toString(36).substring(2, 10);
  }
  function getHistoryState(location, index) {
    return {
      usr: location.state,
      key: location.key,
      idx: index
    };
  }
  function createLocation(current, to, state = null, key) {
    let location = {
      pathname: typeof current === "string" ? current : current.pathname,
      search: "",
      hash: "",
      ...typeof to === "string" ? parsePath(to) : to,
      state,
      // TODO: This could be cleaned up.  push/replace should probably just take
      // full Locations now and avoid the need to run through this flow at all
      // But that's a pretty big refactor to the current test suite so going to
      // keep as is for the time being and just let any incoming keys take precedence
      key: to && to.key || key || createKey()
    };
    return location;
  }
  function createPath({
    pathname = "/",
    search = "",
    hash = ""
  }) {
    if (search && search !== "?")
      pathname += search.charAt(0) === "?" ? search : "?" + search;
    if (hash && hash !== "#")
      pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
    return pathname;
  }
  function parsePath(path) {
    let parsedPath = {};
    if (path) {
      let hashIndex = path.indexOf("#");
      if (hashIndex >= 0) {
        parsedPath.hash = path.substring(hashIndex);
        path = path.substring(0, hashIndex);
      }
      let searchIndex = path.indexOf("?");
      if (searchIndex >= 0) {
        parsedPath.search = path.substring(searchIndex);
        path = path.substring(0, searchIndex);
      }
      if (path) {
        parsedPath.pathname = path;
      }
    }
    return parsedPath;
  }
  function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
    let { window: window2 = document.defaultView, v5Compat = false } = options;
    let globalHistory = window2.history;
    let action = "POP";
    let listener = null;
    let index = getIndex();
    if (index == null) {
      index = 0;
      globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
    }
    function getIndex() {
      let state = globalHistory.state || { idx: null };
      return state.idx;
    }
    function handlePop() {
      action = "POP";
      let nextIndex = getIndex();
      let delta = nextIndex == null ? null : nextIndex - index;
      index = nextIndex;
      if (listener) {
        listener({ action, location: history.location, delta });
      }
    }
    function push(to, state) {
      action = "PUSH";
      let location = createLocation(history.location, to, state);
      if (validateLocation) validateLocation(location, to);
      index = getIndex() + 1;
      let historyState = getHistoryState(location, index);
      let url = history.createHref(location);
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        if (error instanceof DOMException && error.name === "DataCloneError") {
          throw error;
        }
        window2.location.assign(url);
      }
      if (v5Compat && listener) {
        listener({ action, location: history.location, delta: 1 });
      }
    }
    function replace2(to, state) {
      action = "REPLACE";
      let location = createLocation(history.location, to, state);
      if (validateLocation) validateLocation(location, to);
      index = getIndex();
      let historyState = getHistoryState(location, index);
      let url = history.createHref(location);
      globalHistory.replaceState(historyState, "", url);
      if (v5Compat && listener) {
        listener({ action, location: history.location, delta: 0 });
      }
    }
    function createURL(to) {
      return createBrowserURLImpl(to);
    }
    let history = {
      get action() {
        return action;
      },
      get location() {
        return getLocation(window2, globalHistory);
      },
      listen(fn) {
        if (listener) {
          throw new Error("A history only accepts one active listener");
        }
        window2.addEventListener(PopStateEventType, handlePop);
        listener = fn;
        return () => {
          window2.removeEventListener(PopStateEventType, handlePop);
          listener = null;
        };
      },
      createHref(to) {
        return createHref2(window2, to);
      },
      createURL,
      encodeLocation(to) {
        let url = createURL(to);
        return {
          pathname: url.pathname,
          search: url.search,
          hash: url.hash
        };
      },
      push,
      replace: replace2,
      go(n) {
        return globalHistory.go(n);
      }
    };
    return history;
  }
  function createBrowserURLImpl(to, isAbsolute = false) {
    let base = "http://localhost";
    if (typeof window !== "undefined") {
      base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    }
    invariant(base, "No window.location.(origin|href) available to create URL");
    let href2 = typeof to === "string" ? to : createPath(to);
    href2 = href2.replace(/ $/, "%20");
    if (!isAbsolute && href2.startsWith("//")) {
      href2 = base + href2;
    }
    return new URL(href2, base);
  }
  var _map;
  var unstable_RouterContextProvider = class {
    constructor(init) {
      __privateAdd(this, _map, /* @__PURE__ */ new Map());
      if (init) {
        for (let [context, value] of init) {
          this.set(context, value);
        }
      }
    }
    get(context) {
      if (__privateGet(this, _map).has(context)) {
        return __privateGet(this, _map).get(context);
      }
      if (context.defaultValue !== void 0) {
        return context.defaultValue;
      }
      throw new Error("No value found for context");
    }
    set(context, value) {
      __privateGet(this, _map).set(context, value);
    }
  };
  _map = /* @__PURE__ */ new WeakMap();
  var unsupportedLazyRouteObjectKeys = /* @__PURE__ */ new Set([
    "lazy",
    "caseSensitive",
    "path",
    "id",
    "index",
    "children"
  ]);
  function isUnsupportedLazyRouteObjectKey(key) {
    return unsupportedLazyRouteObjectKeys.has(
      key
    );
  }
  var unsupportedLazyRouteFunctionKeys = /* @__PURE__ */ new Set([
    "lazy",
    "caseSensitive",
    "path",
    "id",
    "index",
    "unstable_middleware",
    "children"
  ]);
  function isUnsupportedLazyRouteFunctionKey(key) {
    return unsupportedLazyRouteFunctionKeys.has(
      key
    );
  }
  function isIndexRoute(route) {
    return route.index === true;
  }
  function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {
    return routes.map((route, index) => {
      let treePath = [...parentPath, String(index)];
      let id = typeof route.id === "string" ? route.id : treePath.join("-");
      invariant(
        route.index !== true || !route.children,
        `Cannot specify children on an index route`
      );
      invariant(
        !manifest[id],
        `Found a route id collision on id "${id}".  Route id's must be globally unique within Data Router usages`
      );
      if (isIndexRoute(route)) {
        let indexRoute = {
          ...route,
          ...mapRouteProperties2(route),
          id
        };
        manifest[id] = indexRoute;
        return indexRoute;
      } else {
        let pathOrLayoutRoute = {
          ...route,
          ...mapRouteProperties2(route),
          id,
          children: void 0
        };
        manifest[id] = pathOrLayoutRoute;
        if (route.children) {
          pathOrLayoutRoute.children = convertRoutesToDataRoutes(
            route.children,
            mapRouteProperties2,
            treePath,
            manifest
          );
        }
        return pathOrLayoutRoute;
      }
    });
  }
  function matchRoutes(routes, locationArg, basename = "/") {
    return matchRoutesImpl(routes, locationArg, basename, false);
  }
  function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
    let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    let pathname = stripBasename(location.pathname || "/", basename);
    if (pathname == null) {
      return null;
    }
    let branches = flattenRoutes(routes);
    rankRouteBranches(branches);
    let matches = null;
    for (let i = 0; matches == null && i < branches.length; ++i) {
      let decoded = decodePath(pathname);
      matches = matchRouteBranch(
        branches[i],
        decoded,
        allowPartial
      );
    }
    return matches;
  }
  function convertRouteMatchToUiMatch(match, loaderData) {
    let { route, pathname, params } = match;
    return {
      id: route.id,
      pathname,
      params,
      data: loaderData[route.id],
      handle: route.handle
    };
  }
  function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
    let flattenRoute = (route, index, relativePath) => {
      let meta = {
        relativePath: relativePath === void 0 ? route.path || "" : relativePath,
        caseSensitive: route.caseSensitive === true,
        childrenIndex: index,
        route
      };
      if (meta.relativePath.startsWith("/")) {
        invariant(
          meta.relativePath.startsWith(parentPath),
          `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
        );
        meta.relativePath = meta.relativePath.slice(parentPath.length);
      }
      let path = joinPaths([parentPath, meta.relativePath]);
      let routesMeta = parentsMeta.concat(meta);
      if (route.children && route.children.length > 0) {
        invariant(
          // Our types know better, but runtime JS may not!
          // @ts-expect-error
          route.index !== true,
          `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
        );
        flattenRoutes(route.children, branches, routesMeta, path);
      }
      if (route.path == null && !route.index) {
        return;
      }
      branches.push({
        path,
        score: computeScore(path, route.index),
        routesMeta
      });
    };
    routes.forEach((route, index) => {
      if (route.path === "" || !route.path?.includes("?")) {
        flattenRoute(route, index);
      } else {
        for (let exploded of explodeOptionalSegments(route.path)) {
          flattenRoute(route, index, exploded);
        }
      }
    });
    return branches;
  }
  function explodeOptionalSegments(path) {
    let segments = path.split("/");
    if (segments.length === 0) return [];
    let [first, ...rest] = segments;
    let isOptional = first.endsWith("?");
    let required = first.replace(/\?$/, "");
    if (rest.length === 0) {
      return isOptional ? [required, ""] : [required];
    }
    let restExploded = explodeOptionalSegments(rest.join("/"));
    let result = [];
    result.push(
      ...restExploded.map(
        (subpath) => subpath === "" ? required : [required, subpath].join("/")
      )
    );
    if (isOptional) {
      result.push(...restExploded);
    }
    return result.map(
      (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
    );
  }
  function rankRouteBranches(branches) {
    branches.sort(
      (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
        a.routesMeta.map((meta) => meta.childrenIndex),
        b.routesMeta.map((meta) => meta.childrenIndex)
      )
    );
  }
  var paramRe = /^:[\w-]+$/;
  var dynamicSegmentValue = 3;
  var indexRouteValue = 2;
  var emptySegmentValue = 1;
  var staticSegmentValue = 10;
  var splatPenalty = -2;
  var isSplat = (s) => s === "*";
  function computeScore(path, index) {
    let segments = path.split("/");
    let initialScore = segments.length;
    if (segments.some(isSplat)) {
      initialScore += splatPenalty;
    }
    if (index) {
      initialScore += indexRouteValue;
    }
    return segments.filter((s) => !isSplat(s)).reduce(
      (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
      initialScore
    );
  }
  function compareIndexes(a, b) {
    let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
    return siblings ? (
      // If two routes are siblings, we should try to match the earlier sibling
      // first. This allows people to have fine-grained control over the matching
      // behavior by simply putting routes with identical paths in the order they
      // want them tried.
      a[a.length - 1] - b[b.length - 1]
    ) : (
      // Otherwise, it doesn't really make sense to rank non-siblings by index,
      // so they sort equally.
      0
    );
  }
  function matchRouteBranch(branch, pathname, allowPartial = false) {
    let { routesMeta } = branch;
    let matchedParams = {};
    let matchedPathname = "/";
    let matches = [];
    for (let i = 0; i < routesMeta.length; ++i) {
      let meta = routesMeta[i];
      let end = i === routesMeta.length - 1;
      let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
      let match = matchPath(
        { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
        remainingPathname
      );
      let route = meta.route;
      if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
        match = matchPath(
          {
            path: meta.relativePath,
            caseSensitive: meta.caseSensitive,
            end: false
          },
          remainingPathname
        );
      }
      if (!match) {
        return null;
      }
      Object.assign(matchedParams, match.params);
      matches.push({
        // TODO: Can this as be avoided?
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match.pathname]),
        pathnameBase: normalizePathname(
          joinPaths([matchedPathname, match.pathnameBase])
        ),
        route
      });
      if (match.pathnameBase !== "/") {
        matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
      }
    }
    return matches;
  }
  function matchPath(pattern, pathname) {
    if (typeof pattern === "string") {
      pattern = { path: pattern, caseSensitive: false, end: true };
    }
    let [matcher, compiledParams] = compilePath(
      pattern.path,
      pattern.caseSensitive,
      pattern.end
    );
    let match = pathname.match(matcher);
    if (!match) return null;
    let matchedPathname = match[0];
    let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
    let captureGroups = match.slice(1);
    let params = compiledParams.reduce(
      (memo22, { paramName, isOptional }, index) => {
        if (paramName === "*") {
          let splatValue = captureGroups[index] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        const value = captureGroups[index];
        if (isOptional && !value) {
          memo22[paramName] = void 0;
        } else {
          memo22[paramName] = (value || "").replace(/%2F/g, "/");
        }
        return memo22;
      },
      {}
    );
    return {
      params,
      pathname: matchedPathname,
      pathnameBase,
      pattern
    };
  }
  function compilePath(path, caseSensitive = false, end = true) {
    warning(
      path === "*" || !path.endsWith("*") || path.endsWith("/*"),
      `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
    );
    let params = [];
    let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
      /\/:([\w-]+)(\?)?/g,
      (_, paramName, isOptional) => {
        params.push({ paramName, isOptional: isOptional != null });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      }
    );
    if (path.endsWith("*")) {
      params.push({ paramName: "*" });
      regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
    } else if (end) {
      regexpSource += "\\/*$";
    } else if (path !== "" && path !== "/") {
      regexpSource += "(?:(?=\\/|$))";
    } else {
    }
    let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
    return [matcher, params];
  }
  function decodePath(value) {
    try {
      return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
    } catch (error) {
      warning(
        false,
        `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
      );
      return value;
    }
  }
  function stripBasename(pathname, basename) {
    if (basename === "/") return pathname;
    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
      return null;
    }
    let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
    let nextChar = pathname.charAt(startIndex);
    if (nextChar && nextChar !== "/") {
      return null;
    }
    return pathname.slice(startIndex) || "/";
  }
  function resolvePath(to, fromPathname = "/") {
    let {
      pathname: toPathname,
      search = "",
      hash = ""
    } = typeof to === "string" ? parsePath(to) : to;
    let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
    return {
      pathname,
      search: normalizeSearch(search),
      hash: normalizeHash(hash)
    };
  }
  function resolvePathname(relativePath, fromPathname) {
    let segments = fromPathname.replace(/\/+$/, "").split("/");
    let relativeSegments = relativePath.split("/");
    relativeSegments.forEach((segment) => {
      if (segment === "..") {
        if (segments.length > 1) segments.pop();
      } else if (segment !== ".") {
        segments.push(segment);
      }
    });
    return segments.length > 1 ? segments.join("/") : "/";
  }
  function getInvalidPathError(char, field, dest, path) {
    return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
      path
    )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
  }
  function getPathContributingMatches(matches) {
    return matches.filter(
      (match, index) => index === 0 || match.route.path && match.route.path.length > 0
    );
  }
  function getResolveToMatches(matches) {
    let pathMatches = getPathContributingMatches(matches);
    return pathMatches.map(
      (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
    );
  }
  function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
    let to;
    if (typeof toArg === "string") {
      to = parsePath(toArg);
    } else {
      to = { ...toArg };
      invariant(
        !to.pathname || !to.pathname.includes("?"),
        getInvalidPathError("?", "pathname", "search", to)
      );
      invariant(
        !to.pathname || !to.pathname.includes("#"),
        getInvalidPathError("#", "pathname", "hash", to)
      );
      invariant(
        !to.search || !to.search.includes("#"),
        getInvalidPathError("#", "search", "hash", to)
      );
    }
    let isEmptyPath = toArg === "" || to.pathname === "";
    let toPathname = isEmptyPath ? "/" : to.pathname;
    let from;
    if (toPathname == null) {
      from = locationPathname;
    } else {
      let routePathnameIndex = routePathnames.length - 1;
      if (!isPathRelative && toPathname.startsWith("..")) {
        let toSegments = toPathname.split("/");
        while (toSegments[0] === "..") {
          toSegments.shift();
          routePathnameIndex -= 1;
        }
        to.pathname = toSegments.join("/");
      }
      from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
    }
    let path = resolvePath(to, from);
    let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
    if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
      path.pathname += "/";
    }
    return path;
  }
  var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
  var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
  var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
  var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
  var ErrorResponseImpl = class {
    constructor(status, statusText, data2, internal = false) {
      this.status = status;
      this.statusText = statusText || "";
      this.internal = internal;
      if (data2 instanceof Error) {
        this.data = data2.toString();
        this.error = data2;
      } else {
        this.data = data2;
      }
    }
  };
  function isRouteErrorResponse(error) {
    return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
  }
  var validMutationMethodsArr = [
    "POST",
    "PUT",
    "PATCH",
    "DELETE"
  ];
  var validMutationMethods = new Set(
    validMutationMethodsArr
  );
  var validRequestMethodsArr = [
    "GET",
    ...validMutationMethodsArr
  ];
  var validRequestMethods = new Set(validRequestMethodsArr);
  var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
  var redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
  var IDLE_NAVIGATION = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
  var IDLE_FETCHER = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
  var IDLE_BLOCKER = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
  };
  var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
  var defaultMapRouteProperties = (route) => ({
    hasErrorBoundary: Boolean(route.hasErrorBoundary)
  });
  var TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
  var ResetLoaderDataSymbol = Symbol("ResetLoaderData");
  function createRouter(init) {
    const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
    const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
    invariant(
      init.routes.length > 0,
      "You must provide a non-empty routes array to createRouter"
    );
    let hydrationRouteProperties2 = init.hydrationRouteProperties || [];
    let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;
    let manifest = {};
    let dataRoutes = convertRoutesToDataRoutes(
      init.routes,
      mapRouteProperties2,
      void 0,
      manifest
    );
    let inFlightDataRoutes;
    let basename = init.basename || "/";
    let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;
    let future = {
      unstable_middleware: false,
      ...init.future
    };
    let unlistenHistory = null;
    let subscribers = /* @__PURE__ */ new Set();
    let savedScrollPositions2 = null;
    let getScrollRestorationKey2 = null;
    let getScrollPosition = null;
    let initialScrollRestored = init.hydrationData != null;
    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
    let initialMatchesIsFOW = false;
    let initialErrors = null;
    let initialized;
    if (initialMatches == null && !init.patchRoutesOnNavigation) {
      let error = getInternalRouterError(404, {
        pathname: init.history.location.pathname
      });
      let { matches, route } = getShortCircuitMatches(dataRoutes);
      initialized = true;
      initialMatches = matches;
      initialErrors = { [route.id]: error };
    } else {
      if (initialMatches && !init.hydrationData) {
        let fogOfWar = checkFogOfWar(
          initialMatches,
          dataRoutes,
          init.history.location.pathname
        );
        if (fogOfWar.active) {
          initialMatches = null;
        }
      }
      if (!initialMatches) {
        initialized = false;
        initialMatches = [];
        let fogOfWar = checkFogOfWar(
          null,
          dataRoutes,
          init.history.location.pathname
        );
        if (fogOfWar.active && fogOfWar.matches) {
          initialMatchesIsFOW = true;
          initialMatches = fogOfWar.matches;
        }
      } else if (initialMatches.some((m) => m.route.lazy)) {
        initialized = false;
      } else if (!initialMatches.some((m) => m.route.loader)) {
        initialized = true;
      } else {
        let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
        let errors = init.hydrationData ? init.hydrationData.errors : null;
        if (errors) {
          let idx = initialMatches.findIndex(
            (m) => errors[m.route.id] !== void 0
          );
          initialized = initialMatches.slice(0, idx + 1).every(
            (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)
          );
        } else {
          initialized = initialMatches.every(
            (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)
          );
        }
      }
    }
    let router2;
    let state = {
      historyAction: init.history.action,
      location: init.history.location,
      matches: initialMatches,
      initialized,
      navigation: IDLE_NAVIGATION,
      // Don't restore on initial updateState() if we were SSR'd
      restoreScrollPosition: init.hydrationData != null ? false : null,
      preventScrollReset: false,
      revalidation: "idle",
      loaderData: init.hydrationData && init.hydrationData.loaderData || {},
      actionData: init.hydrationData && init.hydrationData.actionData || null,
      errors: init.hydrationData && init.hydrationData.errors || initialErrors,
      fetchers: /* @__PURE__ */ new Map(),
      blockers: /* @__PURE__ */ new Map()
    };
    let pendingAction = "POP";
    let pendingPreventScrollReset = false;
    let pendingNavigationController;
    let pendingViewTransitionEnabled = false;
    let appliedViewTransitions = /* @__PURE__ */ new Map();
    let removePageHideEventListener = null;
    let isUninterruptedRevalidation = false;
    let isRevalidationRequired = false;
    let cancelledFetcherLoads = /* @__PURE__ */ new Set();
    let fetchControllers = /* @__PURE__ */ new Map();
    let incrementingLoadId = 0;
    let pendingNavigationLoadId = -1;
    let fetchReloadIds = /* @__PURE__ */ new Map();
    let fetchRedirectIds = /* @__PURE__ */ new Set();
    let fetchLoadMatches = /* @__PURE__ */ new Map();
    let activeFetchers = /* @__PURE__ */ new Map();
    let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();
    let blockerFunctions = /* @__PURE__ */ new Map();
    let unblockBlockerHistoryUpdate = void 0;
    let pendingRevalidationDfd = null;
    function initialize() {
      unlistenHistory = init.history.listen(
        ({ action: historyAction, location, delta }) => {
          if (unblockBlockerHistoryUpdate) {
            unblockBlockerHistoryUpdate();
            unblockBlockerHistoryUpdate = void 0;
            return;
          }
          warning(
            blockerFunctions.size === 0 || delta != null,
            "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
          );
          let blockerKey = shouldBlockNavigation({
            currentLocation: state.location,
            nextLocation: location,
            historyAction
          });
          if (blockerKey && delta != null) {
            let nextHistoryUpdatePromise = new Promise((resolve) => {
              unblockBlockerHistoryUpdate = resolve;
            });
            init.history.go(delta * -1);
            updateBlocker(blockerKey, {
              state: "blocked",
              location,
              proceed() {
                updateBlocker(blockerKey, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location
                });
                nextHistoryUpdatePromise.then(() => init.history.go(delta));
              },
              reset() {
                let blockers = new Map(state.blockers);
                blockers.set(blockerKey, IDLE_BLOCKER);
                updateState({ blockers });
              }
            });
            return;
          }
          return startNavigation(historyAction, location);
        }
      );
      if (isBrowser2) {
        restoreAppliedTransitions(routerWindow, appliedViewTransitions);
        let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
        routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
        removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
      }
      if (!state.initialized) {
        startNavigation("POP", state.location, {
          initialHydration: true
        });
      }
      return router2;
    }
    function dispose() {
      if (unlistenHistory) {
        unlistenHistory();
      }
      if (removePageHideEventListener) {
        removePageHideEventListener();
      }
      subscribers.clear();
      pendingNavigationController && pendingNavigationController.abort();
      state.fetchers.forEach((_, key) => deleteFetcher(key));
      state.blockers.forEach((_, key) => deleteBlocker(key));
    }
    function subscribe(fn) {
      subscribers.add(fn);
      return () => subscribers.delete(fn);
    }
    function updateState(newState, opts = {}) {
      state = {
        ...state,
        ...newState
      };
      let unmountedFetchers = [];
      let mountedFetchers = [];
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (fetchersQueuedForDeletion.has(key)) {
            unmountedFetchers.push(key);
          } else {
            mountedFetchers.push(key);
          }
        }
      });
      fetchersQueuedForDeletion.forEach((key) => {
        if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
          unmountedFetchers.push(key);
        }
      });
      [...subscribers].forEach(
        (subscriber) => subscriber(state, {
          deletedFetchers: unmountedFetchers,
          viewTransitionOpts: opts.viewTransitionOpts,
          flushSync: opts.flushSync === true
        })
      );
      unmountedFetchers.forEach((key) => deleteFetcher(key));
      mountedFetchers.forEach((key) => state.fetchers.delete(key));
    }
    function completeNavigation(location, newState, { flushSync } = {}) {
      let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && location.state?._isRedirect !== true;
      let actionData;
      if (newState.actionData) {
        if (Object.keys(newState.actionData).length > 0) {
          actionData = newState.actionData;
        } else {
          actionData = null;
        }
      } else if (isActionReload) {
        actionData = state.actionData;
      } else {
        actionData = null;
      }
      let loaderData = newState.loaderData ? mergeLoaderData(
        state.loaderData,
        newState.loaderData,
        newState.matches || [],
        newState.errors
      ) : state.loaderData;
      let blockers = state.blockers;
      if (blockers.size > 0) {
        blockers = new Map(blockers);
        blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
      }
      let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;
      if (inFlightDataRoutes) {
        dataRoutes = inFlightDataRoutes;
        inFlightDataRoutes = void 0;
      }
      if (isUninterruptedRevalidation) {
      } else if (pendingAction === "POP") {
      } else if (pendingAction === "PUSH") {
        init.history.push(location, location.state);
      } else if (pendingAction === "REPLACE") {
        init.history.replace(location, location.state);
      }
      let viewTransitionOpts;
      if (pendingAction === "POP") {
        let priorPaths = appliedViewTransitions.get(state.location.pathname);
        if (priorPaths && priorPaths.has(location.pathname)) {
          viewTransitionOpts = {
            currentLocation: state.location,
            nextLocation: location
          };
        } else if (appliedViewTransitions.has(location.pathname)) {
          viewTransitionOpts = {
            currentLocation: location,
            nextLocation: state.location
          };
        }
      } else if (pendingViewTransitionEnabled) {
        let toPaths = appliedViewTransitions.get(state.location.pathname);
        if (toPaths) {
          toPaths.add(location.pathname);
        } else {
          toPaths = /* @__PURE__ */ new Set([location.pathname]);
          appliedViewTransitions.set(state.location.pathname, toPaths);
        }
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      }
      updateState(
        {
          ...newState,
          // matches, errors, fetchers go through as-is
          actionData,
          loaderData,
          historyAction: pendingAction,
          location,
          initialized: true,
          navigation: IDLE_NAVIGATION,
          revalidation: "idle",
          restoreScrollPosition: getSavedScrollPosition(
            location,
            newState.matches || state.matches
          ),
          preventScrollReset,
          blockers
        },
        {
          viewTransitionOpts,
          flushSync: flushSync === true
        }
      );
      pendingAction = "POP";
      pendingPreventScrollReset = false;
      pendingViewTransitionEnabled = false;
      isUninterruptedRevalidation = false;
      isRevalidationRequired = false;
      pendingRevalidationDfd?.resolve();
      pendingRevalidationDfd = null;
    }
    async function navigate(to, opts) {
      if (typeof to === "number") {
        init.history.go(to);
        return;
      }
      let normalizedPath = normalizeTo(
        state.location,
        state.matches,
        basename,
        to,
        opts?.fromRouteId,
        opts?.relative
      );
      let { path, submission, error } = normalizeNavigateOptions(
        false,
        normalizedPath,
        opts
      );
      let currentLocation = state.location;
      let nextLocation = createLocation(state.location, path, opts && opts.state);
      nextLocation = {
        ...nextLocation,
        ...init.history.encodeLocation(nextLocation)
      };
      let userReplace = opts && opts.replace != null ? opts.replace : void 0;
      let historyAction = "PUSH";
      if (userReplace === true) {
        historyAction = "REPLACE";
      } else if (userReplace === false) {
      } else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
        historyAction = "REPLACE";
      }
      let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
      let flushSync = (opts && opts.flushSync) === true;
      let blockerKey = shouldBlockNavigation({
        currentLocation,
        nextLocation,
        historyAction
      });
      if (blockerKey) {
        updateBlocker(blockerKey, {
          state: "blocked",
          location: nextLocation,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: nextLocation
            });
            navigate(to, opts);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({ blockers });
          }
        });
        return;
      }
      await startNavigation(historyAction, nextLocation, {
        submission,
        // Send through the formData serialization error if we have one so we can
        // render at the right error boundary after we match routes
        pendingError: error,
        preventScrollReset,
        replace: opts && opts.replace,
        enableViewTransition: opts && opts.viewTransition,
        flushSync
      });
    }
    function revalidate() {
      if (!pendingRevalidationDfd) {
        pendingRevalidationDfd = createDeferred();
      }
      interruptActiveLoads();
      updateState({ revalidation: "loading" });
      let promise = pendingRevalidationDfd.promise;
      if (state.navigation.state === "submitting") {
        return promise;
      }
      if (state.navigation.state === "idle") {
        startNavigation(state.historyAction, state.location, {
          startUninterruptedRevalidation: true
        });
        return promise;
      }
      startNavigation(
        pendingAction || state.historyAction,
        state.navigation.location,
        {
          overrideNavigation: state.navigation,
          // Proxy through any rending view transition
          enableViewTransition: pendingViewTransitionEnabled === true
        }
      );
      return promise;
    }
    async function startNavigation(historyAction, location, opts) {
      pendingNavigationController && pendingNavigationController.abort();
      pendingNavigationController = null;
      pendingAction = historyAction;
      isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
      saveScrollPosition(state.location, state.matches);
      pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
      pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let loadingNavigation = opts && opts.overrideNavigation;
      let matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (
        // `matchRoutes()` has already been called if we're in here via `router.initialize()`
        state.matches
      ) : matchRoutes(routesToUse, location, basename);
      let flushSync = (opts && opts.flushSync) === true;
      if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
        completeNavigation(location, { matches }, { flushSync });
        return;
      }
      let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);
      if (fogOfWar.active && fogOfWar.matches) {
        matches = fogOfWar.matches;
      }
      if (!matches) {
        let { error, notFoundMatches, route } = handleNavigational404(
          location.pathname
        );
        completeNavigation(
          location,
          {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          },
          { flushSync }
        );
        return;
      }
      pendingNavigationController = new AbortController();
      let request = createClientSideRequest(
        init.history,
        location,
        pendingNavigationController.signal,
        opts && opts.submission
      );
      let scopedContext = new unstable_RouterContextProvider(
        init.unstable_getContext ? await init.unstable_getContext() : void 0
      );
      let pendingActionResult;
      if (opts && opts.pendingError) {
        pendingActionResult = [
          findNearestBoundary(matches).route.id,
          { type: "error", error: opts.pendingError }
        ];
      } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
        let actionResult = await handleAction(
          request,
          location,
          opts.submission,
          matches,
          scopedContext,
          fogOfWar.active,
          opts && opts.initialHydration === true,
          { replace: opts.replace, flushSync }
        );
        if (actionResult.shortCircuited) {
          return;
        }
        if (actionResult.pendingActionResult) {
          let [routeId, result] = actionResult.pendingActionResult;
          if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
            pendingNavigationController = null;
            completeNavigation(location, {
              matches: actionResult.matches,
              loaderData: {},
              errors: {
                [routeId]: result.error
              }
            });
            return;
          }
        }
        matches = actionResult.matches || matches;
        pendingActionResult = actionResult.pendingActionResult;
        loadingNavigation = getLoadingNavigation(location, opts.submission);
        flushSync = false;
        fogOfWar.active = false;
        request = createClientSideRequest(
          init.history,
          request.url,
          request.signal
        );
      }
      let {
        shortCircuited,
        matches: updatedMatches,
        loaderData,
        errors
      } = await handleLoaders(
        request,
        location,
        matches,
        scopedContext,
        fogOfWar.active,
        loadingNavigation,
        opts && opts.submission,
        opts && opts.fetcherSubmission,
        opts && opts.replace,
        opts && opts.initialHydration === true,
        flushSync,
        pendingActionResult
      );
      if (shortCircuited) {
        return;
      }
      pendingNavigationController = null;
      completeNavigation(location, {
        matches: updatedMatches || matches,
        ...getActionDataForCommit(pendingActionResult),
        loaderData,
        errors
      });
    }
    async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {
      interruptActiveLoads();
      let navigation = getSubmittingNavigation(location, submission);
      updateState({ navigation }, { flushSync: opts.flushSync === true });
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(
          matches,
          location.pathname,
          request.signal
        );
        if (discoverResult.type === "aborted") {
          return { shortCircuited: true };
        } else if (discoverResult.type === "error") {
          let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
          return {
            matches: discoverResult.partialMatches,
            pendingActionResult: [
              boundaryId,
              {
                type: "error",
                error: discoverResult.error
              }
            ]
          };
        } else if (!discoverResult.matches) {
          let { notFoundMatches, error, route } = handleNavigational404(
            location.pathname
          );
          return {
            matches: notFoundMatches,
            pendingActionResult: [
              route.id,
              {
                type: "error",
                error
              }
            ]
          };
        } else {
          matches = discoverResult.matches;
        }
      }
      let result;
      let actionMatch = getTargetMatch(matches, location);
      if (!actionMatch.route.action && !actionMatch.route.lazy) {
        result = {
          type: "error",
          error: getInternalRouterError(405, {
            method: request.method,
            pathname: location.pathname,
            routeId: actionMatch.route.id
          })
        };
      } else {
        let dsMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          request,
          matches,
          actionMatch,
          initialHydration ? [] : hydrationRouteProperties2,
          scopedContext
        );
        let results = await callDataStrategy(
          request,
          dsMatches,
          scopedContext,
          null
        );
        result = results[actionMatch.route.id];
        if (!result) {
          for (let match of matches) {
            if (results[match.route.id]) {
              result = results[match.route.id];
              break;
            }
          }
        }
        if (request.signal.aborted) {
          return { shortCircuited: true };
        }
      }
      if (isRedirectResult(result)) {
        let replace2;
        if (opts && opts.replace != null) {
          replace2 = opts.replace;
        } else {
          let location2 = normalizeRedirectLocation(
            result.response.headers.get("Location"),
            new URL(request.url),
            basename
          );
          replace2 = location2 === state.location.pathname + state.location.search;
        }
        await startRedirectNavigation(request, result, true, {
          submission,
          replace: replace2
        });
        return { shortCircuited: true };
      }
      if (isErrorResult(result)) {
        let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
        if ((opts && opts.replace) !== true) {
          pendingAction = "PUSH";
        }
        return {
          matches,
          pendingActionResult: [
            boundaryMatch.route.id,
            result,
            actionMatch.route.id
          ]
        };
      }
      return {
        matches,
        pendingActionResult: [actionMatch.route.id, result]
      };
    }
    async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {
      let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
      let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
      let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;
      if (isFogOfWar) {
        if (shouldUpdateNavigationState) {
          let actionData = getUpdatedActionData(pendingActionResult);
          updateState(
            {
              navigation: loadingNavigation,
              ...actionData !== void 0 ? { actionData } : {}
            },
            {
              flushSync
            }
          );
        }
        let discoverResult = await discoverRoutes(
          matches,
          location.pathname,
          request.signal
        );
        if (discoverResult.type === "aborted") {
          return { shortCircuited: true };
        } else if (discoverResult.type === "error") {
          let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
          return {
            matches: discoverResult.partialMatches,
            loaderData: {},
            errors: {
              [boundaryId]: discoverResult.error
            }
          };
        } else if (!discoverResult.matches) {
          let { error, notFoundMatches, route } = handleNavigational404(
            location.pathname
          );
          return {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          };
        } else {
          matches = discoverResult.matches;
        }
      }
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let { dsMatches, revalidatingFetchers } = getMatchesToLoad(
        request,
        scopedContext,
        mapRouteProperties2,
        manifest,
        init.history,
        state,
        matches,
        activeSubmission,
        location,
        initialHydration ? [] : hydrationRouteProperties2,
        initialHydration === true,
        isRevalidationRequired,
        cancelledFetcherLoads,
        fetchersQueuedForDeletion,
        fetchLoadMatches,
        fetchRedirectIds,
        routesToUse,
        basename,
        init.patchRoutesOnNavigation != null,
        pendingActionResult
      );
      pendingNavigationLoadId = ++incrementingLoadId;
      if (!init.dataStrategy && !dsMatches.some((m) => m.shouldLoad) && revalidatingFetchers.length === 0) {
        let updatedFetchers2 = markFetchRedirectsDone();
        completeNavigation(
          location,
          {
            matches,
            loaderData: {},
            // Commit pending error if we're short circuiting
            errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,
            ...getActionDataForCommit(pendingActionResult),
            ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}
          },
          { flushSync }
        );
        return { shortCircuited: true };
      }
      if (shouldUpdateNavigationState) {
        let updates = {};
        if (!isFogOfWar) {
          updates.navigation = loadingNavigation;
          let actionData = getUpdatedActionData(pendingActionResult);
          if (actionData !== void 0) {
            updates.actionData = actionData;
          }
        }
        if (revalidatingFetchers.length > 0) {
          updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
        }
        updateState(updates, { flushSync });
      }
      revalidatingFetchers.forEach((rf) => {
        abortFetcher(rf.key);
        if (rf.controller) {
          fetchControllers.set(rf.key, rf.controller);
        }
      });
      let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));
      if (pendingNavigationController) {
        pendingNavigationController.signal.addEventListener(
          "abort",
          abortPendingFetchRevalidations
        );
      }
      let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
        dsMatches,
        revalidatingFetchers,
        request,
        scopedContext
      );
      if (request.signal.aborted) {
        return { shortCircuited: true };
      }
      if (pendingNavigationController) {
        pendingNavigationController.signal.removeEventListener(
          "abort",
          abortPendingFetchRevalidations
        );
      }
      revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
      let redirect2 = findRedirect(loaderResults);
      if (redirect2) {
        await startRedirectNavigation(request, redirect2.result, true, {
          replace: replace2
        });
        return { shortCircuited: true };
      }
      redirect2 = findRedirect(fetcherResults);
      if (redirect2) {
        fetchRedirectIds.add(redirect2.key);
        await startRedirectNavigation(request, redirect2.result, true, {
          replace: replace2
        });
        return { shortCircuited: true };
      }
      let { loaderData, errors } = processLoaderData(
        state,
        matches,
        loaderResults,
        pendingActionResult,
        revalidatingFetchers,
        fetcherResults
      );
      if (initialHydration && state.errors) {
        errors = { ...state.errors, ...errors };
      }
      let updatedFetchers = markFetchRedirectsDone();
      let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
      let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
      return {
        matches,
        loaderData,
        errors,
        ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}
      };
    }
    function getUpdatedActionData(pendingActionResult) {
      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
        return {
          [pendingActionResult[0]]: pendingActionResult[1].data
        };
      } else if (state.actionData) {
        if (Object.keys(state.actionData).length === 0) {
          return null;
        } else {
          return state.actionData;
        }
      }
    }
    function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
      revalidatingFetchers.forEach((rf) => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = getLoadingFetcher(
          void 0,
          fetcher ? fetcher.data : void 0
        );
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      return new Map(state.fetchers);
    }
    async function fetch2(key, routeId, href2, opts) {
      abortFetcher(key);
      let flushSync = (opts && opts.flushSync) === true;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let normalizedPath = normalizeTo(
        state.location,
        state.matches,
        basename,
        href2,
        routeId,
        opts?.relative
      );
      let matches = matchRoutes(routesToUse, normalizedPath, basename);
      let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
      if (fogOfWar.active && fogOfWar.matches) {
        matches = fogOfWar.matches;
      }
      if (!matches) {
        setFetcherError(
          key,
          routeId,
          getInternalRouterError(404, { pathname: normalizedPath }),
          { flushSync }
        );
        return;
      }
      let { path, submission, error } = normalizeNavigateOptions(
        true,
        normalizedPath,
        opts
      );
      if (error) {
        setFetcherError(key, routeId, error, { flushSync });
        return;
      }
      let match = getTargetMatch(matches, path);
      let scopedContext = new unstable_RouterContextProvider(
        init.unstable_getContext ? await init.unstable_getContext() : void 0
      );
      let preventScrollReset = (opts && opts.preventScrollReset) === true;
      if (submission && isMutationMethod(submission.formMethod)) {
        await handleFetcherAction(
          key,
          routeId,
          path,
          match,
          matches,
          scopedContext,
          fogOfWar.active,
          flushSync,
          preventScrollReset,
          submission
        );
        return;
      }
      fetchLoadMatches.set(key, { routeId, path });
      await handleFetcherLoader(
        key,
        routeId,
        path,
        match,
        matches,
        scopedContext,
        fogOfWar.active,
        flushSync,
        preventScrollReset,
        submission
      );
    }
    async function handleFetcherAction(key, routeId, path, match, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
      interruptActiveLoads();
      fetchLoadMatches.delete(key);
      function detectAndHandle405Error(m) {
        if (!m.route.action && !m.route.lazy) {
          let error = getInternalRouterError(405, {
            method: submission.formMethod,
            pathname: path,
            routeId
          });
          setFetcherError(key, routeId, error, { flushSync });
          return true;
        }
        return false;
      }
      if (!isFogOfWar && detectAndHandle405Error(match)) {
        return;
      }
      let existingFetcher = state.fetchers.get(key);
      updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
        flushSync
      });
      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(
        init.history,
        path,
        abortController.signal,
        submission
      );
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(
          requestMatches,
          path,
          fetchRequest.signal,
          key
        );
        if (discoverResult.type === "aborted") {
          return;
        } else if (discoverResult.type === "error") {
          setFetcherError(key, routeId, discoverResult.error, { flushSync });
          return;
        } else if (!discoverResult.matches) {
          setFetcherError(
            key,
            routeId,
            getInternalRouterError(404, { pathname: path }),
            { flushSync }
          );
          return;
        } else {
          requestMatches = discoverResult.matches;
          match = getTargetMatch(requestMatches, path);
          if (detectAndHandle405Error(match)) {
            return;
          }
        }
      }
      fetchControllers.set(key, abortController);
      let originatingLoadId = incrementingLoadId;
      let fetchMatches = getTargetedDataStrategyMatches(
        mapRouteProperties2,
        manifest,
        fetchRequest,
        requestMatches,
        match,
        hydrationRouteProperties2,
        scopedContext
      );
      let actionResults = await callDataStrategy(
        fetchRequest,
        fetchMatches,
        scopedContext,
        key
      );
      let actionResult = actionResults[match.route.id];
      if (fetchRequest.signal.aborted) {
        if (fetchControllers.get(key) === abortController) {
          fetchControllers.delete(key);
        }
        return;
      }
      if (fetchersQueuedForDeletion.has(key)) {
        if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        }
      } else {
        if (isRedirectResult(actionResult)) {
          fetchControllers.delete(key);
          if (pendingNavigationLoadId > originatingLoadId) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          } else {
            fetchRedirectIds.add(key);
            updateFetcherState(key, getLoadingFetcher(submission));
            return startRedirectNavigation(fetchRequest, actionResult, false, {
              fetcherSubmission: submission,
              preventScrollReset
            });
          }
        }
        if (isErrorResult(actionResult)) {
          setFetcherError(key, routeId, actionResult.error);
          return;
        }
      }
      let nextLocation = state.navigation.location || state.location;
      let revalidationRequest = createClientSideRequest(
        init.history,
        nextLocation,
        abortController.signal
      );
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
      invariant(matches, "Didn't find any matches after fetcher action");
      let loadId = ++incrementingLoadId;
      fetchReloadIds.set(key, loadId);
      let loadFetcher = getLoadingFetcher(submission, actionResult.data);
      state.fetchers.set(key, loadFetcher);
      let { dsMatches, revalidatingFetchers } = getMatchesToLoad(
        revalidationRequest,
        scopedContext,
        mapRouteProperties2,
        manifest,
        init.history,
        state,
        matches,
        submission,
        nextLocation,
        hydrationRouteProperties2,
        false,
        isRevalidationRequired,
        cancelledFetcherLoads,
        fetchersQueuedForDeletion,
        fetchLoadMatches,
        fetchRedirectIds,
        routesToUse,
        basename,
        init.patchRoutesOnNavigation != null,
        [match.route.id, actionResult]
      );
      revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
        let staleKey = rf.key;
        let existingFetcher2 = state.fetchers.get(staleKey);
        let revalidatingFetcher = getLoadingFetcher(
          void 0,
          existingFetcher2 ? existingFetcher2.data : void 0
        );
        state.fetchers.set(staleKey, revalidatingFetcher);
        abortFetcher(staleKey);
        if (rf.controller) {
          fetchControllers.set(staleKey, rf.controller);
        }
      });
      updateState({ fetchers: new Map(state.fetchers) });
      let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
      abortController.signal.addEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
      let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
        dsMatches,
        revalidatingFetchers,
        revalidationRequest,
        scopedContext
      );
      if (abortController.signal.aborted) {
        return;
      }
      abortController.signal.removeEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
      fetchReloadIds.delete(key);
      fetchControllers.delete(key);
      revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));
      if (state.fetchers.has(key)) {
        let doneFetcher = getDoneFetcher(actionResult.data);
        state.fetchers.set(key, doneFetcher);
      }
      let redirect2 = findRedirect(loaderResults);
      if (redirect2) {
        return startRedirectNavigation(
          revalidationRequest,
          redirect2.result,
          false,
          { preventScrollReset }
        );
      }
      redirect2 = findRedirect(fetcherResults);
      if (redirect2) {
        fetchRedirectIds.add(redirect2.key);
        return startRedirectNavigation(
          revalidationRequest,
          redirect2.result,
          false,
          { preventScrollReset }
        );
      }
      let { loaderData, errors } = processLoaderData(
        state,
        matches,
        loaderResults,
        void 0,
        revalidatingFetchers,
        fetcherResults
      );
      abortStaleFetchLoads(loadId);
      if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
        invariant(pendingAction, "Expected pending action");
        pendingNavigationController && pendingNavigationController.abort();
        completeNavigation(state.navigation.location, {
          matches,
          loaderData,
          errors,
          fetchers: new Map(state.fetchers)
        });
      } else {
        updateState({
          errors,
          loaderData: mergeLoaderData(
            state.loaderData,
            loaderData,
            matches,
            errors
          ),
          fetchers: new Map(state.fetchers)
        });
        isRevalidationRequired = false;
      }
    }
    async function handleFetcherLoader(key, routeId, path, match, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
      let existingFetcher = state.fetchers.get(key);
      updateFetcherState(
        key,
        getLoadingFetcher(
          submission,
          existingFetcher ? existingFetcher.data : void 0
        ),
        { flushSync }
      );
      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(
        init.history,
        path,
        abortController.signal
      );
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(
          matches,
          path,
          fetchRequest.signal,
          key
        );
        if (discoverResult.type === "aborted") {
          return;
        } else if (discoverResult.type === "error") {
          setFetcherError(key, routeId, discoverResult.error, { flushSync });
          return;
        } else if (!discoverResult.matches) {
          setFetcherError(
            key,
            routeId,
            getInternalRouterError(404, { pathname: path }),
            { flushSync }
          );
          return;
        } else {
          matches = discoverResult.matches;
          match = getTargetMatch(matches, path);
        }
      }
      fetchControllers.set(key, abortController);
      let originatingLoadId = incrementingLoadId;
      let dsMatches = getTargetedDataStrategyMatches(
        mapRouteProperties2,
        manifest,
        fetchRequest,
        matches,
        match,
        hydrationRouteProperties2,
        scopedContext
      );
      let results = await callDataStrategy(
        fetchRequest,
        dsMatches,
        scopedContext,
        key
      );
      let result = results[match.route.id];
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      if (fetchRequest.signal.aborted) {
        return;
      }
      if (fetchersQueuedForDeletion.has(key)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
      if (isRedirectResult(result)) {
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          await startRedirectNavigation(fetchRequest, result, false, {
            preventScrollReset
          });
          return;
        }
      }
      if (isErrorResult(result)) {
        setFetcherError(key, routeId, result.error);
        return;
      }
      updateFetcherState(key, getDoneFetcher(result.data));
    }
    async function startRedirectNavigation(request, redirect2, isNavigation, {
      submission,
      fetcherSubmission,
      preventScrollReset,
      replace: replace2
    } = {}) {
      if (redirect2.response.headers.has("X-Remix-Revalidate")) {
        isRevalidationRequired = true;
      }
      let location = redirect2.response.headers.get("Location");
      invariant(location, "Expected a Location header on the redirect Response");
      location = normalizeRedirectLocation(
        location,
        new URL(request.url),
        basename
      );
      let redirectLocation = createLocation(state.location, location, {
        _isRedirect: true
      });
      if (isBrowser2) {
        let isDocumentReload = false;
        if (redirect2.response.headers.has("X-Remix-Reload-Document")) {
          isDocumentReload = true;
        } else if (ABSOLUTE_URL_REGEX.test(location)) {
          const url = createBrowserURLImpl(location, true);
          isDocumentReload = // Hard reload if it's an absolute URL to a new origin
          url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
          stripBasename(url.pathname, basename) == null;
        }
        if (isDocumentReload) {
          if (replace2) {
            routerWindow.location.replace(location);
          } else {
            routerWindow.location.assign(location);
          }
          return;
        }
      }
      pendingNavigationController = null;
      let redirectNavigationType = replace2 === true || redirect2.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH";
      let { formMethod, formAction, formEncType } = state.navigation;
      if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
        submission = getSubmissionFromNavigation(state.navigation);
      }
      let activeSubmission = submission || fetcherSubmission;
      if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
        await startNavigation(redirectNavigationType, redirectLocation, {
          submission: {
            ...activeSubmission,
            formAction: location
          },
          // Preserve these flags across redirects
          preventScrollReset: preventScrollReset || pendingPreventScrollReset,
          enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
        });
      } else {
        let overrideNavigation = getLoadingNavigation(
          redirectLocation,
          submission
        );
        await startNavigation(redirectNavigationType, redirectLocation, {
          overrideNavigation,
          // Send fetcher submissions through for shouldRevalidate
          fetcherSubmission,
          // Preserve these flags across redirects
          preventScrollReset: preventScrollReset || pendingPreventScrollReset,
          enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
        });
      }
    }
    async function callDataStrategy(request, matches, scopedContext, fetcherKey) {
      let results;
      let dataResults = {};
      try {
        results = await callDataStrategyImpl(
          dataStrategyImpl,
          request,
          matches,
          fetcherKey,
          scopedContext,
          false
        );
      } catch (e) {
        matches.filter((m) => m.shouldLoad).forEach((m) => {
          dataResults[m.route.id] = {
            type: "error",
            error: e
          };
        });
        return dataResults;
      }
      if (request.signal.aborted) {
        return dataResults;
      }
      for (let [routeId, result] of Object.entries(results)) {
        if (isRedirectDataStrategyResult(result)) {
          let response = result.result;
          dataResults[routeId] = {
            type: "redirect",
            response: normalizeRelativeRoutingRedirectResponse(
              response,
              request,
              routeId,
              matches,
              basename
            )
          };
        } else {
          dataResults[routeId] = await convertDataStrategyResultToDataResult(
            result
          );
        }
      }
      return dataResults;
    }
    async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {
      let loaderResultsPromise = callDataStrategy(
        request,
        matches,
        scopedContext,
        null
      );
      let fetcherResultsPromise = Promise.all(
        fetchersToLoad.map(async (f) => {
          if (f.matches && f.match && f.request && f.controller) {
            let results = await callDataStrategy(
              f.request,
              f.matches,
              scopedContext,
              f.key
            );
            let result = results[f.match.route.id];
            return { [f.key]: result };
          } else {
            return Promise.resolve({
              [f.key]: {
                type: "error",
                error: getInternalRouterError(404, {
                  pathname: f.path
                })
              }
            });
          }
        })
      );
      let loaderResults = await loaderResultsPromise;
      let fetcherResults = (await fetcherResultsPromise).reduce(
        (acc, r) => Object.assign(acc, r),
        {}
      );
      return {
        loaderResults,
        fetcherResults
      };
    }
    function interruptActiveLoads() {
      isRevalidationRequired = true;
      fetchLoadMatches.forEach((_, key) => {
        if (fetchControllers.has(key)) {
          cancelledFetcherLoads.add(key);
        }
        abortFetcher(key);
      });
    }
    function updateFetcherState(key, fetcher, opts = {}) {
      state.fetchers.set(key, fetcher);
      updateState(
        { fetchers: new Map(state.fetchers) },
        { flushSync: (opts && opts.flushSync) === true }
      );
    }
    function setFetcherError(key, routeId, error, opts = {}) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      deleteFetcher(key);
      updateState(
        {
          errors: {
            [boundaryMatch.route.id]: error
          },
          fetchers: new Map(state.fetchers)
        },
        { flushSync: (opts && opts.flushSync) === true }
      );
    }
    function getFetcher(key) {
      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
      if (fetchersQueuedForDeletion.has(key)) {
        fetchersQueuedForDeletion.delete(key);
      }
      return state.fetchers.get(key) || IDLE_FETCHER;
    }
    function deleteFetcher(key) {
      let fetcher = state.fetchers.get(key);
      if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
        abortFetcher(key);
      }
      fetchLoadMatches.delete(key);
      fetchReloadIds.delete(key);
      fetchRedirectIds.delete(key);
      fetchersQueuedForDeletion.delete(key);
      cancelledFetcherLoads.delete(key);
      state.fetchers.delete(key);
    }
    function queueFetcherForDeletion(key) {
      let count = (activeFetchers.get(key) || 0) - 1;
      if (count <= 0) {
        activeFetchers.delete(key);
        fetchersQueuedForDeletion.add(key);
      } else {
        activeFetchers.set(key, count);
      }
      updateState({ fetchers: new Map(state.fetchers) });
    }
    function abortFetcher(key) {
      let controller = fetchControllers.get(key);
      if (controller) {
        controller.abort();
        fetchControllers.delete(key);
      }
    }
    function markFetchersDone(keys) {
      for (let key of keys) {
        let fetcher = getFetcher(key);
        let doneFetcher = getDoneFetcher(fetcher.data);
        state.fetchers.set(key, doneFetcher);
      }
    }
    function markFetchRedirectsDone() {
      let doneKeys = [];
      let updatedFetchers = false;
      for (let key of fetchRedirectIds) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          fetchRedirectIds.delete(key);
          doneKeys.push(key);
          updatedFetchers = true;
        }
      }
      markFetchersDone(doneKeys);
      return updatedFetchers;
    }
    function abortStaleFetchLoads(landedId) {
      let yeetedKeys = [];
      for (let [key, id] of fetchReloadIds) {
        if (id < landedId) {
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, `Expected fetcher: ${key}`);
          if (fetcher.state === "loading") {
            abortFetcher(key);
            fetchReloadIds.delete(key);
            yeetedKeys.push(key);
          }
        }
      }
      markFetchersDone(yeetedKeys);
      return yeetedKeys.length > 0;
    }
    function getBlocker(key, fn) {
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;
      if (blockerFunctions.get(key) !== fn) {
        blockerFunctions.set(key, fn);
      }
      return blocker;
    }
    function deleteBlocker(key) {
      state.blockers.delete(key);
      blockerFunctions.delete(key);
    }
    function updateBlocker(key, newBlocker) {
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;
      invariant(
        blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked",
        `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`
      );
      let blockers = new Map(state.blockers);
      blockers.set(key, newBlocker);
      updateState({ blockers });
    }
    function shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    }) {
      if (blockerFunctions.size === 0) {
        return;
      }
      if (blockerFunctions.size > 1) {
        warning(false, "A router only supports one blocker at a time");
      }
      let entries = Array.from(blockerFunctions.entries());
      let [blockerKey, blockerFunction] = entries[entries.length - 1];
      let blocker = state.blockers.get(blockerKey);
      if (blocker && blocker.state === "proceeding") {
        return;
      }
      if (blockerFunction({ currentLocation, nextLocation, historyAction })) {
        return blockerKey;
      }
    }
    function handleNavigational404(pathname) {
      let error = getInternalRouterError(404, { pathname });
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let { matches, route } = getShortCircuitMatches(routesToUse);
      return { notFoundMatches: matches, route, error };
    }
    function enableScrollRestoration(positions, getPosition, getKey) {
      savedScrollPositions2 = positions;
      getScrollPosition = getPosition;
      getScrollRestorationKey2 = getKey || null;
      if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
        initialScrollRestored = true;
        let y = getSavedScrollPosition(state.location, state.matches);
        if (y != null) {
          updateState({ restoreScrollPosition: y });
        }
      }
      return () => {
        savedScrollPositions2 = null;
        getScrollPosition = null;
        getScrollRestorationKey2 = null;
      };
    }
    function getScrollKey(location, matches) {
      if (getScrollRestorationKey2) {
        let key = getScrollRestorationKey2(
          location,
          matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))
        );
        return key || location.key;
      }
      return location.key;
    }
    function saveScrollPosition(location, matches) {
      if (savedScrollPositions2 && getScrollPosition) {
        let key = getScrollKey(location, matches);
        savedScrollPositions2[key] = getScrollPosition();
      }
    }
    function getSavedScrollPosition(location, matches) {
      if (savedScrollPositions2) {
        let key = getScrollKey(location, matches);
        let y = savedScrollPositions2[key];
        if (typeof y === "number") {
          return y;
        }
      }
      return null;
    }
    function checkFogOfWar(matches, routesToUse, pathname) {
      if (init.patchRoutesOnNavigation) {
        if (!matches) {
          let fogMatches = matchRoutesImpl(
            routesToUse,
            pathname,
            basename,
            true
          );
          return { active: true, matches: fogMatches || [] };
        } else {
          if (Object.keys(matches[0].params).length > 0) {
            let partialMatches = matchRoutesImpl(
              routesToUse,
              pathname,
              basename,
              true
            );
            return { active: true, matches: partialMatches };
          }
        }
      }
      return { active: false, matches: null };
    }
    async function discoverRoutes(matches, pathname, signal, fetcherKey) {
      if (!init.patchRoutesOnNavigation) {
        return { type: "success", matches };
      }
      let partialMatches = matches;
      while (true) {
        let isNonHMR = inFlightDataRoutes == null;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let localManifest = manifest;
        try {
          await init.patchRoutesOnNavigation({
            signal,
            path: pathname,
            matches: partialMatches,
            fetcherKey,
            patch: (routeId, children) => {
              if (signal.aborted) return;
              patchRoutesImpl(
                routeId,
                children,
                routesToUse,
                localManifest,
                mapRouteProperties2
              );
            }
          });
        } catch (e) {
          return { type: "error", error: e, partialMatches };
        } finally {
          if (isNonHMR && !signal.aborted) {
            dataRoutes = [...dataRoutes];
          }
        }
        if (signal.aborted) {
          return { type: "aborted" };
        }
        let newMatches = matchRoutes(routesToUse, pathname, basename);
        if (newMatches) {
          return { type: "success", matches: newMatches };
        }
        let newPartialMatches = matchRoutesImpl(
          routesToUse,
          pathname,
          basename,
          true
        );
        if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every(
          (m, i) => m.route.id === newPartialMatches[i].route.id
        )) {
          return { type: "success", matches: null };
        }
        partialMatches = newPartialMatches;
      }
    }
    function _internalSetRoutes(newRoutes) {
      manifest = {};
      inFlightDataRoutes = convertRoutesToDataRoutes(
        newRoutes,
        mapRouteProperties2,
        void 0,
        manifest
      );
    }
    function patchRoutes(routeId, children) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      patchRoutesImpl(
        routeId,
        children,
        routesToUse,
        manifest,
        mapRouteProperties2
      );
      if (isNonHMR) {
        dataRoutes = [...dataRoutes];
        updateState({});
      }
    }
    router2 = {
      get basename() {
        return basename;
      },
      get future() {
        return future;
      },
      get state() {
        return state;
      },
      get routes() {
        return dataRoutes;
      },
      get window() {
        return routerWindow;
      },
      initialize,
      subscribe,
      enableScrollRestoration,
      navigate,
      fetch: fetch2,
      revalidate,
      // Passthrough to history-aware createHref used by useHref so we get proper
      // hash-aware URLs in DOM paths
      createHref: (to) => init.history.createHref(to),
      encodeLocation: (to) => init.history.encodeLocation(to),
      getFetcher,
      deleteFetcher: queueFetcherForDeletion,
      dispose,
      getBlocker,
      deleteBlocker,
      patchRoutes,
      _internalFetchControllers: fetchControllers,
      // TODO: Remove setRoutes, it's temporary to avoid dealing with
      // updating the tree while validating the update algorithm.
      _internalSetRoutes
    };
    return router2;
  }
  function isSubmissionNavigation(opts) {
    return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
  }
  function normalizeTo(location, matches, basename, to, fromRouteId, relative) {
    let contextualMatches;
    let activeRouteMatch;
    if (fromRouteId) {
      contextualMatches = [];
      for (let match of matches) {
        contextualMatches.push(match);
        if (match.route.id === fromRouteId) {
          activeRouteMatch = match;
          break;
        }
      }
    } else {
      contextualMatches = matches;
      activeRouteMatch = matches[matches.length - 1];
    }
    let path = resolveTo(
      to ? to : ".",
      getResolveToMatches(contextualMatches),
      stripBasename(location.pathname, basename) || location.pathname,
      relative === "path"
    );
    if (to == null) {
      path.search = location.search;
      path.hash = location.hash;
    }
    if ((to == null || to === "" || to === ".") && activeRouteMatch) {
      let nakedIndex = hasNakedIndexQuery(path.search);
      if (activeRouteMatch.route.index && !nakedIndex) {
        path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
      } else if (!activeRouteMatch.route.index && nakedIndex) {
        let params = new URLSearchParams(path.search);
        let indexValues = params.getAll("index");
        params.delete("index");
        indexValues.filter((v) => v).forEach((v) => params.append("index", v));
        let qs = params.toString();
        path.search = qs ? `?${qs}` : "";
      }
    }
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    return createPath(path);
  }
  function normalizeNavigateOptions(isFetcher, path, opts) {
    if (!opts || !isSubmissionNavigation(opts)) {
      return { path };
    }
    if (opts.formMethod && !isValidMethod(opts.formMethod)) {
      return {
        path,
        error: getInternalRouterError(405, { method: opts.formMethod })
      };
    }
    let getInvalidBodyError = () => ({
      path,
      error: getInternalRouterError(400, { type: "invalid-body" })
    });
    let rawFormMethod = opts.formMethod || "get";
    let formMethod = rawFormMethod.toUpperCase();
    let formAction = stripHashFromPath(path);
    if (opts.body !== void 0) {
      if (opts.formEncType === "text/plain") {
        if (!isMutationMethod(formMethod)) {
          return getInvalidBodyError();
        }
        let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
          // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
          Array.from(opts.body.entries()).reduce(
            (acc, [name, value]) => `${acc}${name}=${value}
`,
            ""
          )
        ) : String(opts.body);
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json: void 0,
            text
          }
        };
      } else if (opts.formEncType === "application/json") {
        if (!isMutationMethod(formMethod)) {
          return getInvalidBodyError();
        }
        try {
          let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
          return {
            path,
            submission: {
              formMethod,
              formAction,
              formEncType: opts.formEncType,
              formData: void 0,
              json,
              text: void 0
            }
          };
        } catch (e) {
          return getInvalidBodyError();
        }
      }
    }
    invariant(
      typeof FormData === "function",
      "FormData is not available in this environment"
    );
    let searchParams;
    let formData;
    if (opts.formData) {
      searchParams = convertFormDataToSearchParams(opts.formData);
      formData = opts.formData;
    } else if (opts.body instanceof FormData) {
      searchParams = convertFormDataToSearchParams(opts.body);
      formData = opts.body;
    } else if (opts.body instanceof URLSearchParams) {
      searchParams = opts.body;
      formData = convertSearchParamsToFormData(searchParams);
    } else if (opts.body == null) {
      searchParams = new URLSearchParams();
      formData = new FormData();
    } else {
      try {
        searchParams = new URLSearchParams(opts.body);
        formData = convertSearchParamsToFormData(searchParams);
      } catch (e) {
        return getInvalidBodyError();
      }
    }
    let submission = {
      formMethod,
      formAction,
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData,
      json: void 0,
      text: void 0
    };
    if (isMutationMethod(submission.formMethod)) {
      return { path, submission };
    }
    let parsedPath = parsePath(path);
    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
      searchParams.append("index", "");
    }
    parsedPath.search = `?${searchParams}`;
    return { path: createPath(parsedPath), submission };
  }
  function getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, hasPatchRoutesOnNavigation, pendingActionResult) {
    let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
    let currentUrl = history.createURL(state.location);
    let nextUrl = history.createURL(location);
    let maxIdx;
    if (initialHydration && state.errors) {
      let boundaryId = Object.keys(state.errors)[0];
      maxIdx = matches.findIndex((m) => m.route.id === boundaryId);
    } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
      let boundaryId = pendingActionResult[0];
      maxIdx = matches.findIndex((m) => m.route.id === boundaryId) - 1;
    }
    let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
    let shouldSkipRevalidation = actionStatus && actionStatus >= 400;
    let baseShouldRevalidateArgs = {
      currentUrl,
      currentParams: state.matches[0]?.params || {},
      nextUrl,
      nextParams: matches[0].params,
      ...submission,
      actionResult,
      actionStatus
    };
    let dsMatches = matches.map((match, index) => {
      let { route } = match;
      let forceShouldLoad = null;
      if (maxIdx != null && index > maxIdx) {
        forceShouldLoad = false;
      } else if (route.lazy) {
        forceShouldLoad = true;
      } else if (route.loader == null) {
        forceShouldLoad = false;
      } else if (initialHydration) {
        forceShouldLoad = shouldLoadRouteOnHydration(
          route,
          state.loaderData,
          state.errors
        );
      } else if (isNewLoader(state.loaderData, state.matches[index], match)) {
        forceShouldLoad = true;
      }
      if (forceShouldLoad !== null) {
        return getDataStrategyMatch(
          mapRouteProperties2,
          manifest,
          request,
          match,
          lazyRoutePropertiesToSkip,
          scopedContext,
          forceShouldLoad
        );
      }
      let defaultShouldRevalidate = shouldSkipRevalidation ? false : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index], match)
      );
      let shouldRevalidateArgs = {
        ...baseShouldRevalidateArgs,
        defaultShouldRevalidate
      };
      let shouldLoad = shouldRevalidateLoader(match, shouldRevalidateArgs);
      return getDataStrategyMatch(
        mapRouteProperties2,
        manifest,
        request,
        match,
        lazyRoutePropertiesToSkip,
        scopedContext,
        shouldLoad,
        shouldRevalidateArgs
      );
    });
    let revalidatingFetchers = [];
    fetchLoadMatches.forEach((f, key) => {
      if (initialHydration || !matches.some((m) => m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {
        return;
      }
      let fetcher = state.fetchers.get(key);
      let isMidInitialLoad = fetcher && fetcher.state !== "idle" && fetcher.data === void 0;
      let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
      if (!fetcherMatches) {
        if (hasPatchRoutesOnNavigation && isMidInitialLoad) {
          return;
        }
        revalidatingFetchers.push({
          key,
          routeId: f.routeId,
          path: f.path,
          matches: null,
          match: null,
          request: null,
          controller: null
        });
        return;
      }
      if (fetchRedirectIds.has(key)) {
        return;
      }
      let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
      let fetchController = new AbortController();
      let fetchRequest = createClientSideRequest(
        history,
        f.path,
        fetchController.signal
      );
      let fetcherDsMatches = null;
      if (cancelledFetcherLoads.has(key)) {
        cancelledFetcherLoads.delete(key);
        fetcherDsMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          fetchRequest,
          fetcherMatches,
          fetcherMatch,
          lazyRoutePropertiesToSkip,
          scopedContext
        );
      } else if (isMidInitialLoad) {
        if (isRevalidationRequired) {
          fetcherDsMatches = getTargetedDataStrategyMatches(
            mapRouteProperties2,
            manifest,
            fetchRequest,
            fetcherMatches,
            fetcherMatch,
            lazyRoutePropertiesToSkip,
            scopedContext
          );
        }
      } else {
        let shouldRevalidateArgs = {
          ...baseShouldRevalidateArgs,
          defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
        };
        if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {
          fetcherDsMatches = getTargetedDataStrategyMatches(
            mapRouteProperties2,
            manifest,
            fetchRequest,
            fetcherMatches,
            fetcherMatch,
            lazyRoutePropertiesToSkip,
            scopedContext,
            shouldRevalidateArgs
          );
        }
      }
      if (fetcherDsMatches) {
        revalidatingFetchers.push({
          key,
          routeId: f.routeId,
          path: f.path,
          matches: fetcherDsMatches,
          match: fetcherMatch,
          request: fetchRequest,
          controller: fetchController
        });
      }
    });
    return { dsMatches, revalidatingFetchers };
  }
  function shouldLoadRouteOnHydration(route, loaderData, errors) {
    if (route.lazy) {
      return true;
    }
    if (!route.loader) {
      return false;
    }
    let hasData = loaderData != null && route.id in loaderData;
    let hasError = errors != null && errors[route.id] !== void 0;
    if (!hasData && hasError) {
      return false;
    }
    if (typeof route.loader === "function" && route.loader.hydrate === true) {
      return true;
    }
    return !hasData && !hasError;
  }
  function isNewLoader(currentLoaderData, currentMatch, match) {
    let isNew = (
      // [a] -> [a, b]
      !currentMatch || // [a, b] -> [a, c]
      match.route.id !== currentMatch.route.id
    );
    let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);
    return isNew || isMissingData;
  }
  function isNewRouteInstance(currentMatch, match) {
    let currentPath = currentMatch.route.path;
    return (
      // param change for this match, /users/123 -> /users/456
      currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
    );
  }
  function shouldRevalidateLoader(loaderMatch, arg) {
    if (loaderMatch.route.shouldRevalidate) {
      let routeChoice = loaderMatch.route.shouldRevalidate(arg);
      if (typeof routeChoice === "boolean") {
        return routeChoice;
      }
    }
    return arg.defaultShouldRevalidate;
  }
  function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
    let childrenToPatch;
    if (routeId) {
      let route = manifest[routeId];
      invariant(
        route,
        `No route found to patch children into: routeId = ${routeId}`
      );
      if (!route.children) {
        route.children = [];
      }
      childrenToPatch = route.children;
    } else {
      childrenToPatch = routesToUse;
    }
    let uniqueChildren = children.filter(
      (newRoute) => !childrenToPatch.some(
        (existingRoute) => isSameRoute(newRoute, existingRoute)
      )
    );
    let newRoutes = convertRoutesToDataRoutes(
      uniqueChildren,
      mapRouteProperties2,
      [routeId || "_", "patch", String(childrenToPatch?.length || "0")],
      manifest
    );
    childrenToPatch.push(...newRoutes);
  }
  function isSameRoute(newRoute, existingRoute) {
    if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
      return true;
    }
    if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
      return false;
    }
    if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
      return true;
    }
    return newRoute.children.every(
      (aChild, i) => existingRoute.children?.some((bChild) => isSameRoute(aChild, bChild))
    );
  }
  var lazyRoutePropertyCache = /* @__PURE__ */ new WeakMap();
  var loadLazyRouteProperty = ({
    key,
    route,
    manifest,
    mapRouteProperties: mapRouteProperties2
  }) => {
    let routeToUpdate = manifest[route.id];
    invariant(routeToUpdate, "No route found in manifest");
    if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== "object") {
      return;
    }
    let lazyFn = routeToUpdate.lazy[key];
    if (!lazyFn) {
      return;
    }
    let cache = lazyRoutePropertyCache.get(routeToUpdate);
    if (!cache) {
      cache = {};
      lazyRoutePropertyCache.set(routeToUpdate, cache);
    }
    let cachedPromise = cache[key];
    if (cachedPromise) {
      return cachedPromise;
    }
    let propertyPromise = (async () => {
      let isUnsupported = isUnsupportedLazyRouteObjectKey(key);
      let staticRouteValue = routeToUpdate[key];
      let isStaticallyDefined = staticRouteValue !== void 0 && key !== "hasErrorBoundary";
      if (isUnsupported) {
        warning(
          !isUnsupported,
          "Route property " + key + " is not a supported lazy route property. This property will be ignored."
        );
        cache[key] = Promise.resolve();
      } else if (isStaticallyDefined) {
        warning(
          false,
          `Route "${routeToUpdate.id}" has a static property "${key}" defined. The lazy property will be ignored.`
        );
      } else {
        let value = await lazyFn();
        if (value != null) {
          Object.assign(routeToUpdate, { [key]: value });
          Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));
        }
      }
      if (typeof routeToUpdate.lazy === "object") {
        routeToUpdate.lazy[key] = void 0;
        if (Object.values(routeToUpdate.lazy).every((value) => value === void 0)) {
          routeToUpdate.lazy = void 0;
        }
      }
    })();
    cache[key] = propertyPromise;
    return propertyPromise;
  };
  var lazyRouteFunctionCache = /* @__PURE__ */ new WeakMap();
  function loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {
    let routeToUpdate = manifest[route.id];
    invariant(routeToUpdate, "No route found in manifest");
    if (!route.lazy) {
      return {
        lazyRoutePromise: void 0,
        lazyHandlerPromise: void 0
      };
    }
    if (typeof route.lazy === "function") {
      let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);
      if (cachedPromise) {
        return {
          lazyRoutePromise: cachedPromise,
          lazyHandlerPromise: cachedPromise
        };
      }
      let lazyRoutePromise2 = (async () => {
        invariant(
          typeof route.lazy === "function",
          "No lazy route function found"
        );
        let lazyRoute = await route.lazy();
        let routeUpdates = {};
        for (let lazyRouteProperty in lazyRoute) {
          let lazyValue = lazyRoute[lazyRouteProperty];
          if (lazyValue === void 0) {
            continue;
          }
          let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);
          let staticRouteValue = routeToUpdate[lazyRouteProperty];
          let isStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
          // on the route updates
          lazyRouteProperty !== "hasErrorBoundary";
          if (isUnsupported) {
            warning(
              !isUnsupported,
              "Route property " + lazyRouteProperty + " is not a supported property to be returned from a lazy route function. This property will be ignored."
            );
          } else if (isStaticallyDefined) {
            warning(
              !isStaticallyDefined,
              `Route "${routeToUpdate.id}" has a static property "${lazyRouteProperty}" defined but its lazy function is also returning a value for this property. The lazy route property "${lazyRouteProperty}" will be ignored.`
            );
          } else {
            routeUpdates[lazyRouteProperty] = lazyValue;
          }
        }
        Object.assign(routeToUpdate, routeUpdates);
        Object.assign(routeToUpdate, {
          // To keep things framework agnostic, we use the provided `mapRouteProperties`
          // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
          // since the logic will differ between frameworks.
          ...mapRouteProperties2(routeToUpdate),
          lazy: void 0
        });
      })();
      lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);
      lazyRoutePromise2.catch(() => {
      });
      return {
        lazyRoutePromise: lazyRoutePromise2,
        lazyHandlerPromise: lazyRoutePromise2
      };
    }
    let lazyKeys = Object.keys(route.lazy);
    let lazyPropertyPromises = [];
    let lazyHandlerPromise = void 0;
    for (let key of lazyKeys) {
      if (lazyRoutePropertiesToSkip && lazyRoutePropertiesToSkip.includes(key)) {
        continue;
      }
      let promise = loadLazyRouteProperty({
        key,
        route,
        manifest,
        mapRouteProperties: mapRouteProperties2
      });
      if (promise) {
        lazyPropertyPromises.push(promise);
        if (key === type) {
          lazyHandlerPromise = promise;
        }
      }
    }
    let lazyRoutePromise = lazyPropertyPromises.length > 0 ? Promise.all(lazyPropertyPromises).then(() => {
    }) : void 0;
    lazyRoutePromise?.catch(() => {
    });
    lazyHandlerPromise?.catch(() => {
    });
    return {
      lazyRoutePromise,
      lazyHandlerPromise
    };
  }
  async function defaultDataStrategy(args) {
    let matchesToLoad = args.matches.filter((m) => m.shouldLoad);
    let keyedResults = {};
    let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));
    results.forEach((result, i) => {
      keyedResults[matchesToLoad[i].route.id] = result;
    });
    return keyedResults;
  }
  async function defaultDataStrategyWithMiddleware(args) {
    if (!args.matches.some((m) => m.route.unstable_middleware)) {
      return defaultDataStrategy(args);
    }
    return runMiddlewarePipeline(
      args,
      false,
      () => defaultDataStrategy(args),
      (error, routeId) => ({ [routeId]: { type: "error", result: error } })
    );
  }
  async function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {
    let { matches, request, params, context } = args;
    let middlewareState = {
      handlerResult: void 0
    };
    try {
      let tuples = matches.flatMap(
        (m) => m.route.unstable_middleware ? m.route.unstable_middleware.map((fn) => [m.route.id, fn]) : []
      );
      let result = await callRouteMiddleware(
        { request, params, context },
        tuples,
        propagateResult,
        middlewareState,
        handler
      );
      return propagateResult ? result : middlewareState.handlerResult;
    } catch (e) {
      if (!middlewareState.middlewareError) {
        throw e;
      }
      let result = await errorHandler(
        middlewareState.middlewareError.error,
        middlewareState.middlewareError.routeId
      );
      if (propagateResult || !middlewareState.handlerResult) {
        return result;
      }
      return Object.assign(middlewareState.handlerResult, result);
    }
  }
  async function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {
    let { request } = args;
    if (request.signal.aborted) {
      if (request.signal.reason) {
        throw request.signal.reason;
      }
      throw new Error(
        `Request aborted without an \`AbortSignal.reason\`: ${request.method} ${request.url}`
      );
    }
    let tuple = middlewares[idx];
    if (!tuple) {
      middlewareState.handlerResult = await handler();
      return middlewareState.handlerResult;
    }
    let [routeId, middleware] = tuple;
    let nextCalled = false;
    let nextResult = void 0;
    let next = async () => {
      if (nextCalled) {
        throw new Error("You may only call `next()` once per middleware");
      }
      nextCalled = true;
      let result = await callRouteMiddleware(
        args,
        middlewares,
        propagateResult,
        middlewareState,
        handler,
        idx + 1
      );
      if (propagateResult) {
        nextResult = result;
        return nextResult;
      }
    };
    try {
      let result = await middleware(
        {
          request: args.request,
          params: args.params,
          context: args.context
        },
        next
      );
      if (nextCalled) {
        if (result === void 0) {
          return nextResult;
        } else {
          return result;
        }
      } else {
        return next();
      }
    } catch (error) {
      if (!middlewareState.middlewareError) {
        middlewareState.middlewareError = { routeId, error };
      } else if (middlewareState.middlewareError.error !== error) {
        middlewareState.middlewareError = { routeId, error };
      }
      throw error;
    }
  }
  function getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip) {
    let lazyMiddlewarePromise = loadLazyRouteProperty({
      key: "unstable_middleware",
      route: match.route,
      manifest,
      mapRouteProperties: mapRouteProperties2
    });
    let lazyRoutePromises = loadLazyRoute(
      match.route,
      isMutationMethod(request.method) ? "action" : "loader",
      manifest,
      mapRouteProperties2,
      lazyRoutePropertiesToSkip
    );
    return {
      middleware: lazyMiddlewarePromise,
      route: lazyRoutePromises.lazyRoutePromise,
      handler: lazyRoutePromises.lazyHandlerPromise
    };
  }
  function getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {
    let isUsingNewApi = false;
    let _lazyPromises = getDataStrategyMatchLazyPromises(
      mapRouteProperties2,
      manifest,
      request,
      match,
      lazyRoutePropertiesToSkip
    );
    return {
      ...match,
      _lazyPromises,
      shouldLoad,
      unstable_shouldRevalidateArgs,
      unstable_shouldCallHandler(defaultShouldRevalidate) {
        isUsingNewApi = true;
        if (!unstable_shouldRevalidateArgs) {
          return shouldLoad;
        }
        if (typeof defaultShouldRevalidate === "boolean") {
          return shouldRevalidateLoader(match, {
            ...unstable_shouldRevalidateArgs,
            defaultShouldRevalidate
          });
        }
        return shouldRevalidateLoader(match, unstable_shouldRevalidateArgs);
      },
      resolve(handlerOverride) {
        if (isUsingNewApi || shouldLoad || handlerOverride && request.method === "GET" && (match.route.lazy || match.route.loader)) {
          return callLoaderOrAction({
            request,
            match,
            lazyHandlerPromise: _lazyPromises?.handler,
            lazyRoutePromise: _lazyPromises?.route,
            handlerOverride,
            scopedContext
          });
        }
        return Promise.resolve({ type: "data", result: void 0 });
      }
    };
  }
  function getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {
    return matches.map((match) => {
      if (match.route.id !== targetMatch.route.id) {
        return {
          ...match,
          shouldLoad: false,
          unstable_shouldRevalidateArgs: shouldRevalidateArgs,
          unstable_shouldCallHandler: () => false,
          _lazyPromises: getDataStrategyMatchLazyPromises(
            mapRouteProperties2,
            manifest,
            request,
            match,
            lazyRoutePropertiesToSkip
          ),
          resolve: () => Promise.resolve({ type: "data", result: void 0 })
        };
      }
      return getDataStrategyMatch(
        mapRouteProperties2,
        manifest,
        request,
        match,
        lazyRoutePropertiesToSkip,
        scopedContext,
        true,
        shouldRevalidateArgs
      );
    });
  }
  async function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {
    if (matches.some((m) => m._lazyPromises?.middleware)) {
      await Promise.all(matches.map((m) => m._lazyPromises?.middleware));
    }
    let dataStrategyArgs = {
      request,
      params: matches[0].params,
      context: scopedContext,
      matches
    };
    let unstable_runClientMiddleware = isStaticHandler ? () => {
      throw new Error(
        "You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`"
      );
    } : (cb) => {
      let typedDataStrategyArgs = dataStrategyArgs;
      return runMiddlewarePipeline(
        typedDataStrategyArgs,
        false,
        () => cb({
          ...typedDataStrategyArgs,
          fetcherKey,
          unstable_runClientMiddleware: () => {
            throw new Error(
              "Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler"
            );
          }
        }),
        (error, routeId) => ({
          [routeId]: { type: "error", result: error }
        })
      );
    };
    let results = await dataStrategyImpl({
      ...dataStrategyArgs,
      fetcherKey,
      unstable_runClientMiddleware
    });
    try {
      await Promise.all(
        matches.flatMap((m) => [m._lazyPromises?.handler, m._lazyPromises?.route])
      );
    } catch (e) {
    }
    return results;
  }
  async function callLoaderOrAction({
    request,
    match,
    lazyHandlerPromise,
    lazyRoutePromise,
    handlerOverride,
    scopedContext
  }) {
    let result;
    let onReject;
    let isAction = isMutationMethod(request.method);
    let type = isAction ? "action" : "loader";
    let runHandler = (handler) => {
      let reject;
      let abortPromise = new Promise((_, r) => reject = r);
      onReject = () => reject();
      request.signal.addEventListener("abort", onReject);
      let actualHandler = (ctx) => {
        if (typeof handler !== "function") {
          return Promise.reject(
            new Error(
              `You cannot call the handler for a route which defines a boolean "${type}" [routeId: ${match.route.id}]`
            )
          );
        }
        return handler(
          {
            request,
            params: match.params,
            context: scopedContext
          },
          ...ctx !== void 0 ? [ctx] : []
        );
      };
      let handlerPromise = (async () => {
        try {
          let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
          return { type: "data", result: val };
        } catch (e) {
          return { type: "error", result: e };
        }
      })();
      return Promise.race([handlerPromise, abortPromise]);
    };
    try {
      let handler = isAction ? match.route.action : match.route.loader;
      if (lazyHandlerPromise || lazyRoutePromise) {
        if (handler) {
          let handlerError;
          let [value] = await Promise.all([
            // If the handler throws, don't let it immediately bubble out,
            // since we need to let the lazy() execution finish so we know if this
            // route has a boundary that can handle the error
            runHandler(handler).catch((e) => {
              handlerError = e;
            }),
            // Ensure all lazy route promises are resolved before continuing
            lazyHandlerPromise,
            lazyRoutePromise
          ]);
          if (handlerError !== void 0) {
            throw handlerError;
          }
          result = value;
        } else {
          await lazyHandlerPromise;
          let handler2 = isAction ? match.route.action : match.route.loader;
          if (handler2) {
            [result] = await Promise.all([runHandler(handler2), lazyRoutePromise]);
          } else if (type === "action") {
            let url = new URL(request.url);
            let pathname = url.pathname + url.search;
            throw getInternalRouterError(405, {
              method: request.method,
              pathname,
              routeId: match.route.id
            });
          } else {
            return { type: "data", result: void 0 };
          }
        }
      } else if (!handler) {
        let url = new URL(request.url);
        let pathname = url.pathname + url.search;
        throw getInternalRouterError(404, {
          pathname
        });
      } else {
        result = await runHandler(handler);
      }
    } catch (e) {
      return { type: "error", result: e };
    } finally {
      if (onReject) {
        request.signal.removeEventListener("abort", onReject);
      }
    }
    return result;
  }
  async function convertDataStrategyResultToDataResult(dataStrategyResult) {
    let { result, type } = dataStrategyResult;
    if (isResponse(result)) {
      let data2;
      try {
        let contentType = result.headers.get("Content-Type");
        if (contentType && /\bapplication\/json\b/.test(contentType)) {
          if (result.body == null) {
            data2 = null;
          } else {
            data2 = await result.json();
          }
        } else {
          data2 = await result.text();
        }
      } catch (e) {
        return { type: "error", error: e };
      }
      if (type === "error") {
        return {
          type: "error",
          error: new ErrorResponseImpl(result.status, result.statusText, data2),
          statusCode: result.status,
          headers: result.headers
        };
      }
      return {
        type: "data",
        data: data2,
        statusCode: result.status,
        headers: result.headers
      };
    }
    if (type === "error") {
      if (isDataWithResponseInit(result)) {
        if (result.data instanceof Error) {
          return {
            type: "error",
            error: result.data,
            statusCode: result.init?.status,
            headers: result.init?.headers ? new Headers(result.init.headers) : void 0
          };
        }
        return {
          type: "error",
          error: new ErrorResponseImpl(
            result.init?.status || 500,
            void 0,
            result.data
          ),
          statusCode: isRouteErrorResponse(result) ? result.status : void 0,
          headers: result.init?.headers ? new Headers(result.init.headers) : void 0
        };
      }
      return {
        type: "error",
        error: result,
        statusCode: isRouteErrorResponse(result) ? result.status : void 0
      };
    }
    if (isDataWithResponseInit(result)) {
      return {
        type: "data",
        data: result.data,
        statusCode: result.init?.status,
        headers: result.init?.headers ? new Headers(result.init.headers) : void 0
      };
    }
    return { type: "data", data: result };
  }
  function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {
    let location = response.headers.get("Location");
    invariant(
      location,
      "Redirects returned/thrown from loaders/actions must have a Location header"
    );
    if (!ABSOLUTE_URL_REGEX.test(location)) {
      let trimmedMatches = matches.slice(
        0,
        matches.findIndex((m) => m.route.id === routeId) + 1
      );
      location = normalizeTo(
        new URL(request.url),
        trimmedMatches,
        basename,
        location
      );
      response.headers.set("Location", location);
    }
    return response;
  }
  function normalizeRedirectLocation(location, currentUrl, basename) {
    if (ABSOLUTE_URL_REGEX.test(location)) {
      let normalizedLocation = location;
      let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
      let isSameBasename = stripBasename(url.pathname, basename) != null;
      if (url.origin === currentUrl.origin && isSameBasename) {
        return url.pathname + url.search + url.hash;
      }
    }
    return location;
  }
  function createClientSideRequest(history, location, signal, submission) {
    let url = history.createURL(stripHashFromPath(location)).toString();
    let init = { signal };
    if (submission && isMutationMethod(submission.formMethod)) {
      let { formMethod, formEncType } = submission;
      init.method = formMethod.toUpperCase();
      if (formEncType === "application/json") {
        init.headers = new Headers({ "Content-Type": formEncType });
        init.body = JSON.stringify(submission.json);
      } else if (formEncType === "text/plain") {
        init.body = submission.text;
      } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
        init.body = convertFormDataToSearchParams(submission.formData);
      } else {
        init.body = submission.formData;
      }
    }
    return new Request(url, init);
  }
  function convertFormDataToSearchParams(formData) {
    let searchParams = new URLSearchParams();
    for (let [key, value] of formData.entries()) {
      searchParams.append(key, typeof value === "string" ? value : value.name);
    }
    return searchParams;
  }
  function convertSearchParamsToFormData(searchParams) {
    let formData = new FormData();
    for (let [key, value] of searchParams.entries()) {
      formData.append(key, value);
    }
    return formData;
  }
  function processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {
    let loaderData = {};
    let errors = null;
    let statusCode;
    let foundError = false;
    let loaderHeaders = {};
    let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
    matches.forEach((match) => {
      if (!(match.route.id in results)) {
        return;
      }
      let id = match.route.id;
      let result = results[id];
      invariant(
        !isRedirectResult(result),
        "Cannot handle redirect results in processLoaderData"
      );
      if (isErrorResult(result)) {
        let error = result.error;
        if (pendingError !== void 0) {
          error = pendingError;
          pendingError = void 0;
        }
        errors = errors || {};
        if (skipLoaderErrorBubbling) {
          errors[id] = error;
        } else {
          let boundaryMatch = findNearestBoundary(matches, id);
          if (errors[boundaryMatch.route.id] == null) {
            errors[boundaryMatch.route.id] = error;
          }
        }
        if (!isStaticHandler) {
          loaderData[id] = ResetLoaderDataSymbol;
        }
        if (!foundError) {
          foundError = true;
          statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      } else {
        loaderData[id] = result.data;
        if (result.statusCode && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      }
    });
    if (pendingError !== void 0 && pendingActionResult) {
      errors = { [pendingActionResult[0]]: pendingError };
      if (pendingActionResult[2]) {
        loaderData[pendingActionResult[2]] = void 0;
      }
    }
    return {
      loaderData,
      errors,
      statusCode: statusCode || 200,
      loaderHeaders
    };
  }
  function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {
    let { loaderData, errors } = processRouteLoaderData(
      matches,
      results,
      pendingActionResult
    );
    revalidatingFetchers.filter((f) => !f.matches || f.matches.some((m) => m.shouldLoad)).forEach((rf) => {
      let { key, match, controller } = rf;
      let result = fetcherResults[key];
      invariant(result, "Did not find corresponding fetcher result");
      if (controller && controller.signal.aborted) {
        return;
      } else if (isErrorResult(result)) {
        let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);
        if (!(errors && errors[boundaryMatch.route.id])) {
          errors = {
            ...errors,
            [boundaryMatch.route.id]: result.error
          };
        }
        state.fetchers.delete(key);
      } else if (isRedirectResult(result)) {
        invariant(false, "Unhandled fetcher revalidation redirect");
      } else {
        let doneFetcher = getDoneFetcher(result.data);
        state.fetchers.set(key, doneFetcher);
      }
    });
    return { loaderData, errors };
  }
  function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
    let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {
      merged[k] = v;
      return merged;
    }, {});
    for (let match of matches) {
      let id = match.route.id;
      if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {
        mergedLoaderData[id] = loaderData[id];
      }
      if (errors && errors.hasOwnProperty(id)) {
        break;
      }
    }
    return mergedLoaderData;
  }
  function getActionDataForCommit(pendingActionResult) {
    if (!pendingActionResult) {
      return {};
    }
    return isErrorResult(pendingActionResult[1]) ? {
      // Clear out prior actionData on errors
      actionData: {}
    } : {
      actionData: {
        [pendingActionResult[0]]: pendingActionResult[1].data
      }
    };
  }
  function findNearestBoundary(matches, routeId) {
    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];
    return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];
  }
  function getShortCircuitMatches(routes) {
    let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === "/") || {
      id: `__shim-error-route__`
    };
    return {
      matches: [
        {
          params: {},
          pathname: "",
          pathnameBase: "",
          route
        }
      ],
      route
    };
  }
  function getInternalRouterError(status, {
    pathname,
    routeId,
    method,
    type,
    message
  } = {}) {
    let statusText = "Unknown Server Error";
    let errorMessage = "Unknown @remix-run/router error";
    if (status === 400) {
      statusText = "Bad Request";
      if (method && pathname && routeId) {
        errorMessage = `You made a ${method} request to "${pathname}" but did not provide a \`loader\` for route "${routeId}", so there is no way to handle the request.`;
      } else if (type === "invalid-body") {
        errorMessage = "Unable to encode submission body";
      }
    } else if (status === 403) {
      statusText = "Forbidden";
      errorMessage = `Route "${routeId}" does not match URL "${pathname}"`;
    } else if (status === 404) {
      statusText = "Not Found";
      errorMessage = `No route matches URL "${pathname}"`;
    } else if (status === 405) {
      statusText = "Method Not Allowed";
      if (method && pathname && routeId) {
        errorMessage = `You made a ${method.toUpperCase()} request to "${pathname}" but did not provide an \`action\` for route "${routeId}", so there is no way to handle the request.`;
      } else if (method) {
        errorMessage = `Invalid request method "${method.toUpperCase()}"`;
      }
    }
    return new ErrorResponseImpl(
      status || 500,
      statusText,
      new Error(errorMessage),
      true
    );
  }
  function findRedirect(results) {
    let entries = Object.entries(results);
    for (let i = entries.length - 1; i >= 0; i--) {
      let [key, result] = entries[i];
      if (isRedirectResult(result)) {
        return { key, result };
      }
    }
  }
  function stripHashFromPath(path) {
    let parsedPath = typeof path === "string" ? parsePath(path) : path;
    return createPath({ ...parsedPath, hash: "" });
  }
  function isHashChangeOnly(a, b) {
    if (a.pathname !== b.pathname || a.search !== b.search) {
      return false;
    }
    if (a.hash === "") {
      return b.hash !== "";
    } else if (a.hash === b.hash) {
      return true;
    } else if (b.hash !== "") {
      return true;
    }
    return false;
  }
  function isRedirectDataStrategyResult(result) {
    return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
  }
  function isErrorResult(result) {
    return result.type === "error";
  }
  function isRedirectResult(result) {
    return (result && result.type) === "redirect";
  }
  function isDataWithResponseInit(value) {
    return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
  }
  function isResponse(value) {
    return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
  }
  function isValidMethod(method) {
    return validRequestMethods.has(method.toUpperCase());
  }
  function isMutationMethod(method) {
    return validMutationMethods.has(method.toUpperCase());
  }
  function hasNakedIndexQuery(search) {
    return new URLSearchParams(search).getAll("index").some((v) => v === "");
  }
  function getTargetMatch(matches, location) {
    let search = typeof location === "string" ? parsePath(location).search : location.search;
    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
      return matches[matches.length - 1];
    }
    let pathMatches = getPathContributingMatches(matches);
    return pathMatches[pathMatches.length - 1];
  }
  function getSubmissionFromNavigation(navigation) {
    let { formMethod, formAction, formEncType, text, formData, json } = navigation;
    if (!formMethod || !formAction || !formEncType) {
      return;
    }
    if (text != null) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json: void 0,
        text
      };
    } else if (formData != null) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData,
        json: void 0,
        text: void 0
      };
    } else if (json !== void 0) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json,
        text: void 0
      };
    }
  }
  function getLoadingNavigation(location, submission) {
    if (submission) {
      let navigation = {
        state: "loading",
        location,
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text
      };
      return navigation;
    } else {
      let navigation = {
        state: "loading",
        location,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
      };
      return navigation;
    }
  }
  function getSubmittingNavigation(location, submission) {
    let navigation = {
      state: "submitting",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  }
  function getLoadingFetcher(submission, data2) {
    if (submission) {
      let fetcher = {
        state: "loading",
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text,
        data: data2
      };
      return fetcher;
    } else {
      let fetcher = {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: data2
      };
      return fetcher;
    }
  }
  function getSubmittingFetcher(submission, existingFetcher) {
    let fetcher = {
      state: "submitting",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data: existingFetcher ? existingFetcher.data : void 0
    };
    return fetcher;
  }
  function getDoneFetcher(data2) {
    let fetcher = {
      state: "idle",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data: data2
    };
    return fetcher;
  }
  function restoreAppliedTransitions(_window, transitions) {
    try {
      let sessionPositions = _window.sessionStorage.getItem(
        TRANSITIONS_STORAGE_KEY
      );
      if (sessionPositions) {
        let json = JSON.parse(sessionPositions);
        for (let [k, v] of Object.entries(json || {})) {
          if (v && Array.isArray(v)) {
            transitions.set(k, new Set(v || []));
          }
        }
      }
    } catch (e) {
    }
  }
  function persistAppliedTransitions(_window, transitions) {
    if (transitions.size > 0) {
      let json = {};
      for (let [k, v] of transitions) {
        json[k] = [...v];
      }
      try {
        _window.sessionStorage.setItem(
          TRANSITIONS_STORAGE_KEY,
          JSON.stringify(json)
        );
      } catch (error) {
        warning(
          false,
          `Failed to save applied view transitions in sessionStorage (${error}).`
        );
      }
    }
  }
  function createDeferred() {
    let resolve;
    let reject;
    let promise = new Promise((res, rej) => {
      resolve = async (val) => {
        res(val);
        try {
          await promise;
        } catch (e) {
        }
      };
      reject = async (error) => {
        rej(error);
        try {
          await promise;
        } catch (e) {
        }
      };
    });
    return {
      promise,
      //@ts-ignore
      resolve,
      //@ts-ignore
      reject
    };
  }
  var DataRouterContext = React.createContext(null);
  DataRouterContext.displayName = "DataRouter";
  var DataRouterStateContext = React.createContext(null);
  DataRouterStateContext.displayName = "DataRouterState";
  var ViewTransitionContext = React.createContext({
    isTransitioning: false
  });
  ViewTransitionContext.displayName = "ViewTransition";
  var FetchersContext = React.createContext(
    /* @__PURE__ */ new Map()
  );
  FetchersContext.displayName = "Fetchers";
  var AwaitContext = React.createContext(null);
  AwaitContext.displayName = "Await";
  var NavigationContext = React.createContext(
    null
  );
  NavigationContext.displayName = "Navigation";
  var LocationContext = React.createContext(
    null
  );
  LocationContext.displayName = "Location";
  var RouteContext = React.createContext({
    outlet: null,
    matches: [],
    isDataRoute: false
  });
  RouteContext.displayName = "Route";
  var RouteErrorContext = React.createContext(null);
  RouteErrorContext.displayName = "RouteError";
  var ENABLE_DEV_WARNINGS = true;
  function useHref(to, { relative } = {}) {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useHref() may be used only in the context of a <Router> component.`
    );
    let { basename, navigator: navigator2 } = React2.useContext(NavigationContext);
    let { hash, pathname, search } = useResolvedPath(to, { relative });
    let joinedPathname = pathname;
    if (basename !== "/") {
      joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
    }
    return navigator2.createHref({ pathname: joinedPathname, search, hash });
  }
  function useInRouterContext() {
    return React2.useContext(LocationContext) != null;
  }
  function useLocation() {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useLocation() may be used only in the context of a <Router> component.`
    );
    return React2.useContext(LocationContext).location;
  }
  var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
  function useIsomorphicLayoutEffect(cb) {
    let isStatic = React2.useContext(NavigationContext).static;
    if (!isStatic) {
      React2.useLayoutEffect(cb);
    }
  }
  function useNavigate() {
    let { isDataRoute } = React2.useContext(RouteContext);
    return isDataRoute ? useNavigateStable() : useNavigateUnstable();
  }
  function useNavigateUnstable() {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useNavigate() may be used only in the context of a <Router> component.`
    );
    let dataRouterContext = React2.useContext(DataRouterContext);
    let { basename, navigator: navigator2 } = React2.useContext(NavigationContext);
    let { matches } = React2.useContext(RouteContext);
    let { pathname: locationPathname } = useLocation();
    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
    let activeRef = React2.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React2.useCallback(
      (to, options = {}) => {
        warning(activeRef.current, navigateEffectWarning);
        if (!activeRef.current) return;
        if (typeof to === "number") {
          navigator2.go(to);
          return;
        }
        let path = resolveTo(
          to,
          JSON.parse(routePathnamesJson),
          locationPathname,
          options.relative === "path"
        );
        if (dataRouterContext == null && basename !== "/") {
          path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(
          path,
          options.state,
          options
        );
      },
      [
        basename,
        navigator2,
        routePathnamesJson,
        locationPathname,
        dataRouterContext
      ]
    );
    return navigate;
  }
  var OutletContext = React2.createContext(null);
  function useResolvedPath(to, { relative } = {}) {
    let { matches } = React2.useContext(RouteContext);
    let { pathname: locationPathname } = useLocation();
    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
    return React2.useMemo(
      () => resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        relative === "path"
      ),
      [to, routePathnamesJson, locationPathname, relative]
    );
  }
  function useRoutesImpl(routes, locationArg, dataRouterState, future) {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useRoutes() may be used only in the context of a <Router> component.`
    );
    let { navigator: navigator2 } = React2.useContext(NavigationContext);
    let { matches: parentMatches } = React2.useContext(RouteContext);
    let routeMatch = parentMatches[parentMatches.length - 1];
    let parentParams = routeMatch ? routeMatch.params : {};
    let parentPathname = routeMatch ? routeMatch.pathname : "/";
    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
    let parentRoute = routeMatch && routeMatch.route;
    if (ENABLE_DEV_WARNINGS) {
      let parentPath = parentRoute && parentRoute.path || "";
      warningOnce(
        parentPathname,
        !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
        `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
      );
    }
    let locationFromContext = useLocation();
    let location;
    if (locationArg) {
      let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      invariant(
        parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
        `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
      );
      location = parsedLocationArg;
    } else {
      location = locationFromContext;
    }
    let pathname = location.pathname || "/";
    let remainingPathname = pathname;
    if (parentPathnameBase !== "/") {
      let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
      let segments = pathname.replace(/^\//, "").split("/");
      remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
    }
    let matches = matchRoutes(routes, { pathname: remainingPathname });
    if (ENABLE_DEV_WARNINGS) {
      warning(
        parentRoute || matches != null,
        `No routes matched location "${location.pathname}${location.search}${location.hash}" `
      );
      warning(
        matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
        `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
      );
    }
    let renderedMatches = _renderMatches(
      matches && matches.map(
        (match) => Object.assign({}, match, {
          params: Object.assign({}, parentParams, match.params),
          pathname: joinPaths([
            parentPathnameBase,
            // Re-encode pathnames that were decoded inside matchRoutes
            navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
          ]),
          pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
            parentPathnameBase,
            // Re-encode pathnames that were decoded inside matchRoutes
            navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
          ])
        })
      ),
      parentMatches,
      dataRouterState,
      future
    );
    if (locationArg && renderedMatches) {
      return /* @__PURE__ */ React2.createElement(
        LocationContext.Provider,
        {
          value: {
            location: {
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default",
              ...location
            },
            navigationType: "POP"
            /* Pop */
          }
        },
        renderedMatches
      );
    }
    return renderedMatches;
  }
  function DefaultErrorComponent() {
    let error = useRouteError();
    let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
    let stack = error instanceof Error ? error.stack : null;
    let lightgrey = "rgba(200,200,200, 0.5)";
    let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
    let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
    let devInfo = null;
    if (ENABLE_DEV_WARNINGS) {
      console.error(
        "Error handled by React Router default ErrorBoundary:",
        error
      );
      devInfo = /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ React2.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ React2.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ React2.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
    }
    return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React2.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ React2.createElement("pre", { style: preStyles }, stack) : null, devInfo);
  }
  var defaultErrorElement = /* @__PURE__ */ React2.createElement(DefaultErrorComponent, null);
  var RenderErrorBoundary = class extends React2.Component {
    constructor(props) {
      super(props);
      this.state = {
        location: props.location,
        revalidation: props.revalidation,
        error: props.error
      };
    }
    static getDerivedStateFromError(error) {
      return { error };
    }
    static getDerivedStateFromProps(props, state) {
      if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
        return {
          error: props.error,
          location: props.location,
          revalidation: props.revalidation
        };
      }
      return {
        error: props.error !== void 0 ? props.error : state.error,
        location: state.location,
        revalidation: props.revalidation || state.revalidation
      };
    }
    componentDidCatch(error, errorInfo) {
      console.error(
        "React Router caught the following error during render",
        error,
        errorInfo
      );
    }
    render() {
      return this.state.error !== void 0 ? /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ React2.createElement(
        RouteErrorContext.Provider,
        {
          value: this.state.error,
          children: this.props.component
        }
      )) : this.props.children;
    }
  };
  function RenderedRoute({ routeContext, match, children }) {
    let dataRouterContext = React2.useContext(DataRouterContext);
    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
      dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
    }
    return /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: routeContext }, children);
  }
  function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
    if (matches == null) {
      if (!dataRouterState) {
        return null;
      }
      if (dataRouterState.errors) {
        matches = dataRouterState.matches;
      } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
        matches = dataRouterState.matches;
      } else {
        return null;
      }
    }
    let renderedMatches = matches;
    let errors = dataRouterState?.errors;
    if (errors != null) {
      let errorIndex = renderedMatches.findIndex(
        (m) => m.route.id && errors?.[m.route.id] !== void 0
      );
      invariant(
        errorIndex >= 0,
        `Could not find a matching route for errors on route IDs: ${Object.keys(
          errors
        ).join(",")}`
      );
      renderedMatches = renderedMatches.slice(
        0,
        Math.min(renderedMatches.length, errorIndex + 1)
      );
    }
    let renderFallback = false;
    let fallbackIndex = -1;
    if (dataRouterState) {
      for (let i = 0; i < renderedMatches.length; i++) {
        let match = renderedMatches[i];
        if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
          fallbackIndex = i;
        }
        if (match.route.id) {
          let { loaderData, errors: errors2 } = dataRouterState;
          let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
          if (match.route.lazy || needsToRunLoader) {
            renderFallback = true;
            if (fallbackIndex >= 0) {
              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
            } else {
              renderedMatches = [renderedMatches[0]];
            }
            break;
          }
        }
      }
    }
    return renderedMatches.reduceRight((outlet, match, index) => {
      let error;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error = errors && match.route.id ? errors[match.route.id] : void 0;
        errorElement = match.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index === 0) {
            warningOnce(
              "route-fallback",
              false,
              "No `HydrateFallback` element provided to render during initial hydration"
            );
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
      let getChildren = () => {
        let children;
        if (error) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match.route.Component) {
          children = /* @__PURE__ */ React2.createElement(match.route.Component, null);
        } else if (match.route.element) {
          children = match.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ React2.createElement(
          RenderedRoute,
          {
            match,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          }
        );
      };
      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React2.createElement(
        RenderErrorBoundary,
        {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: { outlet: null, matches: matches2, isDataRoute: true }
        }
      ) : getChildren();
    }, null);
  }
  function getDataRouterConsoleError(hookName) {
    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
  }
  function useDataRouterContext(hookName) {
    let ctx = React2.useContext(DataRouterContext);
    invariant(ctx, getDataRouterConsoleError(hookName));
    return ctx;
  }
  function useDataRouterState(hookName) {
    let state = React2.useContext(DataRouterStateContext);
    invariant(state, getDataRouterConsoleError(hookName));
    return state;
  }
  function useRouteContext(hookName) {
    let route = React2.useContext(RouteContext);
    invariant(route, getDataRouterConsoleError(hookName));
    return route;
  }
  function useCurrentRouteId(hookName) {
    let route = useRouteContext(hookName);
    let thisRoute = route.matches[route.matches.length - 1];
    invariant(
      thisRoute.route.id,
      `${hookName} can only be used on routes that contain a unique "id"`
    );
    return thisRoute.route.id;
  }
  function useRouteId() {
    return useCurrentRouteId(
      "useRouteId"
      /* UseRouteId */
    );
  }
  function useNavigation() {
    let state = useDataRouterState(
      "useNavigation"
      /* UseNavigation */
    );
    return state.navigation;
  }
  function useMatches() {
    let { matches, loaderData } = useDataRouterState(
      "useMatches"
      /* UseMatches */
    );
    return React2.useMemo(
      () => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)),
      [matches, loaderData]
    );
  }
  function useRouteError() {
    let error = React2.useContext(RouteErrorContext);
    let state = useDataRouterState(
      "useRouteError"
      /* UseRouteError */
    );
    let routeId = useCurrentRouteId(
      "useRouteError"
      /* UseRouteError */
    );
    if (error !== void 0) {
      return error;
    }
    return state.errors?.[routeId];
  }
  function useNavigateStable() {
    let { router: router2 } = useDataRouterContext(
      "useNavigate"
      /* UseNavigateStable */
    );
    let id = useCurrentRouteId(
      "useNavigate"
      /* UseNavigateStable */
    );
    let activeRef = React2.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React2.useCallback(
      async (to, options = {}) => {
        warning(activeRef.current, navigateEffectWarning);
        if (!activeRef.current) return;
        if (typeof to === "number") {
          router2.navigate(to);
        } else {
          await router2.navigate(to, { fromRouteId: id, ...options });
        }
      },
      [router2, id]
    );
    return navigate;
  }
  var alreadyWarned = {};
  function warningOnce(key, cond, message) {
    if (!cond && !alreadyWarned[key]) {
      alreadyWarned[key] = true;
      warning(false, message);
    }
  }
  var alreadyWarned2 = {};
  function warnOnce(condition, message) {
    if (!condition && !alreadyWarned2[message]) {
      alreadyWarned2[message] = true;
      console.warn(message);
    }
  }
  function mapRouteProperties(route) {
    let updates = {
      // Note: this check also occurs in createRoutesFromChildren so update
      // there if you change this -- please and thank you!
      hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null
    };
    if (route.Component) {
      if (ENABLE_DEV_WARNINGS) {
        if (route.element) {
          warning(
            false,
            "You should not include both `Component` and `element` on your route - `Component` will be used."
          );
        }
      }
      Object.assign(updates, {
        element: React3.createElement(route.Component),
        Component: void 0
      });
    }
    if (route.HydrateFallback) {
      if (ENABLE_DEV_WARNINGS) {
        if (route.hydrateFallbackElement) {
          warning(
            false,
            "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
          );
        }
      }
      Object.assign(updates, {
        hydrateFallbackElement: React3.createElement(route.HydrateFallback),
        HydrateFallback: void 0
      });
    }
    if (route.ErrorBoundary) {
      if (ENABLE_DEV_WARNINGS) {
        if (route.errorElement) {
          warning(
            false,
            "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
          );
        }
      }
      Object.assign(updates, {
        errorElement: React3.createElement(route.ErrorBoundary),
        ErrorBoundary: void 0
      });
    }
    return updates;
  }
  var hydrationRouteProperties = [
    "HydrateFallback",
    "hydrateFallbackElement"
  ];
  var Deferred = class {
    constructor() {
      this.status = "pending";
      this.promise = new Promise((resolve, reject) => {
        this.resolve = (value) => {
          if (this.status === "pending") {
            this.status = "resolved";
            resolve(value);
          }
        };
        this.reject = (reason) => {
          if (this.status === "pending") {
            this.status = "rejected";
            reject(reason);
          }
        };
      });
    }
  };
  function RouterProvider({
    router: router2,
    flushSync: reactDomFlushSyncImpl
  }) {
    let [state, setStateImpl] = React3.useState(router2.state);
    let [pendingState, setPendingState] = React3.useState();
    let [vtContext, setVtContext] = React3.useState({
      isTransitioning: false
    });
    let [renderDfd, setRenderDfd] = React3.useState();
    let [transition, setTransition] = React3.useState();
    let [interruption, setInterruption] = React3.useState();
    let fetcherData = React3.useRef(/* @__PURE__ */ new Map());
    let setState = React3.useCallback(
      (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {
        newState.fetchers.forEach((fetcher, key) => {
          if (fetcher.data !== void 0) {
            fetcherData.current.set(key, fetcher.data);
          }
        });
        deletedFetchers.forEach((key) => fetcherData.current.delete(key));
        warnOnce(
          flushSync === false || reactDomFlushSyncImpl != null,
          'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
        );
        let isViewTransitionAvailable = router2.window != null && router2.window.document != null && typeof router2.window.document.startViewTransition === "function";
        warnOnce(
          viewTransitionOpts == null || isViewTransitionAvailable,
          "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
        );
        if (!viewTransitionOpts || !isViewTransitionAvailable) {
          if (reactDomFlushSyncImpl && flushSync) {
            reactDomFlushSyncImpl(() => setStateImpl(newState));
          } else {
            React3.startTransition(() => setStateImpl(newState));
          }
          return;
        }
        if (reactDomFlushSyncImpl && flushSync) {
          reactDomFlushSyncImpl(() => {
            if (transition) {
              renderDfd && renderDfd.resolve();
              transition.skipTransition();
            }
            setVtContext({
              isTransitioning: true,
              flushSync: true,
              currentLocation: viewTransitionOpts.currentLocation,
              nextLocation: viewTransitionOpts.nextLocation
            });
          });
          let t = router2.window.document.startViewTransition(() => {
            reactDomFlushSyncImpl(() => setStateImpl(newState));
          });
          t.finished.finally(() => {
            reactDomFlushSyncImpl(() => {
              setRenderDfd(void 0);
              setTransition(void 0);
              setPendingState(void 0);
              setVtContext({ isTransitioning: false });
            });
          });
          reactDomFlushSyncImpl(() => setTransition(t));
          return;
        }
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
          setInterruption({
            state: newState,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        } else {
          setPendingState(newState);
          setVtContext({
            isTransitioning: true,
            flushSync: false,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        }
      },
      [router2.window, reactDomFlushSyncImpl, transition, renderDfd]
    );
    React3.useLayoutEffect(() => router2.subscribe(setState), [router2, setState]);
    React3.useEffect(() => {
      if (vtContext.isTransitioning && !vtContext.flushSync) {
        setRenderDfd(new Deferred());
      }
    }, [vtContext]);
    React3.useEffect(() => {
      if (renderDfd && pendingState && router2.window) {
        let newState = pendingState;
        let renderPromise = renderDfd.promise;
        let transition2 = router2.window.document.startViewTransition(async () => {
          React3.startTransition(() => setStateImpl(newState));
          await renderPromise;
        });
        transition2.finished.finally(() => {
          setRenderDfd(void 0);
          setTransition(void 0);
          setPendingState(void 0);
          setVtContext({ isTransitioning: false });
        });
        setTransition(transition2);
      }
    }, [pendingState, renderDfd, router2.window]);
    React3.useEffect(() => {
      if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
        renderDfd.resolve();
      }
    }, [renderDfd, transition, state.location, pendingState]);
    React3.useEffect(() => {
      if (!vtContext.isTransitioning && interruption) {
        setPendingState(interruption.state);
        setVtContext({
          isTransitioning: true,
          flushSync: false,
          currentLocation: interruption.currentLocation,
          nextLocation: interruption.nextLocation
        });
        setInterruption(void 0);
      }
    }, [vtContext.isTransitioning, interruption]);
    let navigator2 = React3.useMemo(() => {
      return {
        createHref: router2.createHref,
        encodeLocation: router2.encodeLocation,
        go: (n) => router2.navigate(n),
        push: (to, state2, opts) => router2.navigate(to, {
          state: state2,
          preventScrollReset: opts?.preventScrollReset
        }),
        replace: (to, state2, opts) => router2.navigate(to, {
          replace: true,
          state: state2,
          preventScrollReset: opts?.preventScrollReset
        })
      };
    }, [router2]);
    let basename = router2.basename || "/";
    let dataRouterContext = React3.useMemo(
      () => ({
        router: router2,
        navigator: navigator2,
        static: false,
        basename
      }),
      [router2, navigator2, basename]
    );
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ React3.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ React3.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ React3.createElement(ViewTransitionContext.Provider, { value: vtContext }, /* @__PURE__ */ React3.createElement(
      Router,
      {
        basename,
        location: state.location,
        navigationType: state.historyAction,
        navigator: navigator2
      },
      /* @__PURE__ */ React3.createElement(
        MemoizedDataRoutes,
        {
          routes: router2.routes,
          future: router2.future,
          state
        }
      )
    ))))), null);
  }
  var MemoizedDataRoutes = React3.memo(DataRoutes);
  function DataRoutes({
    routes,
    future,
    state
  }) {
    return useRoutesImpl(routes, void 0, state, future);
  }
  function Router({
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = "POP",
    navigator: navigator2,
    static: staticProp = false
  }) {
    invariant(
      !useInRouterContext(),
      `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
    );
    let basename = basenameProp.replace(/^\/*/, "/");
    let navigationContext = React3.useMemo(
      () => ({
        basename,
        navigator: navigator2,
        static: staticProp,
        future: {}
      }),
      [basename, navigator2, staticProp]
    );
    if (typeof locationProp === "string") {
      locationProp = parsePath(locationProp);
    }
    let {
      pathname = "/",
      search = "",
      hash = "",
      state = null,
      key = "default"
    } = locationProp;
    let locationContext = React3.useMemo(() => {
      let trailingPathname = stripBasename(pathname, basename);
      if (trailingPathname == null) {
        return null;
      }
      return {
        location: {
          pathname: trailingPathname,
          search,
          hash,
          state,
          key
        },
        navigationType
      };
    }, [basename, pathname, search, hash, state, key, navigationType]);
    warning(
      locationContext != null,
      `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
    );
    if (locationContext == null) {
      return null;
    }
    return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, { children, value: locationContext }));
  }
  var defaultMethod = "get";
  var defaultEncType = "application/x-www-form-urlencoded";
  function isHtmlElement(object) {
    return object != null && typeof object.tagName === "string";
  }
  function isButtonElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
  }
  function isFormElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
  }
  function isInputElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
  }
  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }
  function shouldProcessLinkClick(event, target) {
    return event.button === 0 && // Ignore everything but left clicks
    (!target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event);
  }
  var _formDataSupportsSubmitter = null;
  function isFormDataSubmitterSupported() {
    if (_formDataSupportsSubmitter === null) {
      try {
        new FormData(
          document.createElement("form"),
          // @ts-expect-error if FormData supports the submitter parameter, this will throw
          0
        );
        _formDataSupportsSubmitter = false;
      } catch (e) {
        _formDataSupportsSubmitter = true;
      }
    }
    return _formDataSupportsSubmitter;
  }
  var supportedFormEncTypes = /* @__PURE__ */ new Set([
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  ]);
  function getFormEncType(encType) {
    if (encType != null && !supportedFormEncTypes.has(encType)) {
      warning(
        false,
        `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
      );
      return null;
    }
    return encType;
  }
  function getFormSubmissionInfo(target, basename) {
    let method;
    let action;
    let encType;
    let formData;
    let body;
    if (isFormElement(target)) {
      let attr = target.getAttribute("action");
      action = attr ? stripBasename(attr, basename) : null;
      method = target.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(target);
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null) {
        throw new Error(
          `Cannot submit a <button> or <input type="submit"> without a <form>`
        );
      }
      let attr = target.getAttribute("formaction") || form.getAttribute("action");
      action = attr ? stripBasename(attr, basename) : null;
      method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(form, target);
      if (!isFormDataSubmitterSupported()) {
        let { name, type, value } = target;
        if (type === "image") {
          let prefix = name ? `${name}.` : "";
          formData.append(`${prefix}x`, "0");
          formData.append(`${prefix}y`, "0");
        } else if (name) {
          formData.append(name, value);
        }
      }
    } else if (isHtmlElement(target)) {
      throw new Error(
        `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
      );
    } else {
      method = defaultMethod;
      action = null;
      encType = defaultEncType;
      body = target;
    }
    if (formData && encType === "text/plain") {
      body = formData;
      formData = void 0;
    }
    return { action, method: method.toLowerCase(), encType, formData, body };
  }
  function invariant2(value, message) {
    if (value === false || value === null || typeof value === "undefined") {
      throw new Error(message);
    }
  }
  async function loadRouteModule(route, routeModulesCache) {
    if (route.id in routeModulesCache) {
      return routeModulesCache[route.id];
    }
    try {
      let routeModule = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        route.module
      );
      routeModulesCache[route.id] = routeModule;
      return routeModule;
    } catch (error) {
      console.error(
        `Error loading route module \`${route.module}\`, reloading page...`
      );
      console.error(error);
      if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
      import_meta.hot) {
        throw error;
      }
      window.location.reload();
      return new Promise(() => {
      });
    }
  }
  function isPageLinkDescriptor(object) {
    return object != null && typeof object.page === "string";
  }
  function isHtmlLinkDescriptor(object) {
    if (object == null) {
      return false;
    }
    if (object.href == null) {
      return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
    }
    return typeof object.rel === "string" && typeof object.href === "string";
  }
  async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
    let links = await Promise.all(
      matches.map(async (match) => {
        let route = manifest.routes[match.route.id];
        if (route) {
          let mod = await loadRouteModule(route, routeModules);
          return mod.links ? mod.links() : [];
        }
        return [];
      })
    );
    return dedupeLinkDescriptors(
      links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
        (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
      )
    );
  }
  function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
    let isNew = (match, index) => {
      if (!currentMatches[index]) return true;
      return match.route.id !== currentMatches[index].route.id;
    };
    let matchPathChanged = (match, index) => {
      return (
        // param change, /users/123 -> /users/456
        currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]
      );
    };
    if (mode === "assets") {
      return nextMatches.filter(
        (match, index) => isNew(match, index) || matchPathChanged(match, index)
      );
    }
    if (mode === "data") {
      return nextMatches.filter((match, index) => {
        let manifestRoute = manifest.routes[match.route.id];
        if (!manifestRoute || !manifestRoute.hasLoader) {
          return false;
        }
        if (isNew(match, index) || matchPathChanged(match, index)) {
          return true;
        }
        if (match.route.shouldRevalidate) {
          let routeChoice = match.route.shouldRevalidate({
            currentUrl: new URL(
              location.pathname + location.search + location.hash,
              window.origin
            ),
            currentParams: currentMatches[0]?.params || {},
            nextUrl: new URL(page, window.origin),
            nextParams: match.params,
            defaultShouldRevalidate: true
          });
          if (typeof routeChoice === "boolean") {
            return routeChoice;
          }
        }
        return true;
      });
    }
    return [];
  }
  function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
    return dedupeHrefs(
      matches.map((match) => {
        let route = manifest.routes[match.route.id];
        if (!route) return [];
        let hrefs = [route.module];
        if (route.clientActionModule) {
          hrefs = hrefs.concat(route.clientActionModule);
        }
        if (route.clientLoaderModule) {
          hrefs = hrefs.concat(route.clientLoaderModule);
        }
        if (includeHydrateFallback && route.hydrateFallbackModule) {
          hrefs = hrefs.concat(route.hydrateFallbackModule);
        }
        if (route.imports) {
          hrefs = hrefs.concat(route.imports);
        }
        return hrefs;
      }).flat(1)
    );
  }
  function dedupeHrefs(hrefs) {
    return [...new Set(hrefs)];
  }
  function sortKeys(obj) {
    let sorted = {};
    let keys = Object.keys(obj).sort();
    for (let key of keys) {
      sorted[key] = obj[key];
    }
    return sorted;
  }
  function dedupeLinkDescriptors(descriptors, preloads) {
    let set = /* @__PURE__ */ new Set();
    let preloadsSet = new Set(preloads);
    return descriptors.reduce((deduped, descriptor) => {
      let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
      if (alreadyModulePreload) {
        return deduped;
      }
      let key = JSON.stringify(sortKeys(descriptor));
      if (!set.has(key)) {
        set.add(key);
        deduped.push({ key, link: descriptor });
      }
      return deduped;
    }, []);
  }
  var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
  var SingleFetchRedirectSymbol = Symbol("SingleFetchRedirect");
  var NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([100, 101, 204, 205]);
  function singleFetchUrl(reqUrl, basename) {
    let url = typeof reqUrl === "string" ? new URL(
      reqUrl,
      // This can be called during the SSR flow via PrefetchPageLinksImpl so
      // don't assume window is available
      typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
    ) : reqUrl;
    if (url.pathname === "/") {
      url.pathname = "_root.data";
    } else if (basename && stripBasename(url.pathname, basename) === "/") {
      url.pathname = `${basename.replace(/\/$/, "")}/_root.data`;
    } else {
      url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
    }
    return url;
  }
  function useDataRouterContext2() {
    let context = React9.useContext(DataRouterContext);
    invariant2(
      context,
      "You must render this element inside a <DataRouterContext.Provider> element"
    );
    return context;
  }
  function useDataRouterStateContext() {
    let context = React9.useContext(DataRouterStateContext);
    invariant2(
      context,
      "You must render this element inside a <DataRouterStateContext.Provider> element"
    );
    return context;
  }
  var FrameworkContext = React9.createContext(void 0);
  FrameworkContext.displayName = "FrameworkContext";
  function useFrameworkContext() {
    let context = React9.useContext(FrameworkContext);
    invariant2(
      context,
      "You must render this element inside a <HydratedRouter> element"
    );
    return context;
  }
  function usePrefetchBehavior(prefetch, theirElementProps) {
    let frameworkContext = React9.useContext(FrameworkContext);
    let [maybePrefetch, setMaybePrefetch] = React9.useState(false);
    let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);
    let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
    let ref = React9.useRef(null);
    React9.useEffect(() => {
      if (prefetch === "render") {
        setShouldPrefetch(true);
      }
      if (prefetch === "viewport") {
        let callback = (entries) => {
          entries.forEach((entry) => {
            setShouldPrefetch(entry.isIntersecting);
          });
        };
        let observer = new IntersectionObserver(callback, { threshold: 0.5 });
        if (ref.current) observer.observe(ref.current);
        return () => {
          observer.disconnect();
        };
      }
    }, [prefetch]);
    React9.useEffect(() => {
      if (maybePrefetch) {
        let id = setTimeout(() => {
          setShouldPrefetch(true);
        }, 100);
        return () => {
          clearTimeout(id);
        };
      }
    }, [maybePrefetch]);
    let setIntent = () => {
      setMaybePrefetch(true);
    };
    let cancelIntent = () => {
      setMaybePrefetch(false);
      setShouldPrefetch(false);
    };
    if (!frameworkContext) {
      return [false, ref, {}];
    }
    if (prefetch !== "intent") {
      return [shouldPrefetch, ref, {}];
    }
    return [
      shouldPrefetch,
      ref,
      {
        onFocus: composeEventHandlers(onFocus, setIntent),
        onBlur: composeEventHandlers(onBlur, cancelIntent),
        onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
        onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
        onTouchStart: composeEventHandlers(onTouchStart, setIntent)
      }
    ];
  }
  function composeEventHandlers(theirHandler, ourHandler) {
    return (event) => {
      theirHandler && theirHandler(event);
      if (!event.defaultPrevented) {
        ourHandler(event);
      }
    };
  }
  function PrefetchPageLinks({
    page,
    ...dataLinkProps
  }) {
    let { router: router2 } = useDataRouterContext2();
    let matches = React9.useMemo(
      () => matchRoutes(router2.routes, page, router2.basename),
      [router2.routes, page, router2.basename]
    );
    if (!matches) {
      return null;
    }
    return /* @__PURE__ */ React9.createElement(PrefetchPageLinksImpl, { page, matches, ...dataLinkProps });
  }
  function useKeyedPrefetchLinks(matches) {
    let { manifest, routeModules } = useFrameworkContext();
    let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);
    React9.useEffect(() => {
      let interrupted = false;
      void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
        (links) => {
          if (!interrupted) {
            setKeyedPrefetchLinks(links);
          }
        }
      );
      return () => {
        interrupted = true;
      };
    }, [matches, manifest, routeModules]);
    return keyedPrefetchLinks;
  }
  function PrefetchPageLinksImpl({
    page,
    matches: nextMatches,
    ...linkProps
  }) {
    let location = useLocation();
    let { manifest, routeModules } = useFrameworkContext();
    let { basename } = useDataRouterContext2();
    let { loaderData, matches } = useDataRouterStateContext();
    let newMatchesForData = React9.useMemo(
      () => getNewMatchesForLinks(
        page,
        nextMatches,
        matches,
        manifest,
        location,
        "data"
      ),
      [page, nextMatches, matches, manifest, location]
    );
    let newMatchesForAssets = React9.useMemo(
      () => getNewMatchesForLinks(
        page,
        nextMatches,
        matches,
        manifest,
        location,
        "assets"
      ),
      [page, nextMatches, matches, manifest, location]
    );
    let dataHrefs = React9.useMemo(() => {
      if (page === location.pathname + location.search + location.hash) {
        return [];
      }
      let routesParams = /* @__PURE__ */ new Set();
      let foundOptOutRoute = false;
      nextMatches.forEach((m) => {
        let manifestRoute = manifest.routes[m.route.id];
        if (!manifestRoute || !manifestRoute.hasLoader) {
          return;
        }
        if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
          foundOptOutRoute = true;
        } else if (manifestRoute.hasClientLoader) {
          foundOptOutRoute = true;
        } else {
          routesParams.add(m.route.id);
        }
      });
      if (routesParams.size === 0) {
        return [];
      }
      let url = singleFetchUrl(page, basename);
      if (foundOptOutRoute && routesParams.size > 0) {
        url.searchParams.set(
          "_routes",
          nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
        );
      }
      return [url.pathname + url.search];
    }, [
      basename,
      loaderData,
      location,
      manifest,
      newMatchesForData,
      nextMatches,
      page,
      routeModules
    ]);
    let moduleHrefs = React9.useMemo(
      () => getModuleLinkHrefs(newMatchesForAssets, manifest),
      [newMatchesForAssets, manifest]
    );
    let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, dataHrefs.map((href2) => /* @__PURE__ */ React9.createElement("link", { key: href2, rel: "prefetch", as: "fetch", href: href2, ...linkProps })), moduleHrefs.map((href2) => /* @__PURE__ */ React9.createElement("link", { key: href2, rel: "modulepreload", href: href2, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
      // these don't spread `linkProps` because they are full link descriptors
      // already with their own props
      /* @__PURE__ */ React9.createElement("link", { key, ...link })
    )));
  }
  function mergeRefs(...refs) {
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  try {
    if (isBrowser) {
      window.__reactRouterVersion = "7.6.3";
    }
  } catch (e) {
  }
  function createBrowserRouter(routes, opts) {
    return createRouter({
      basename: opts?.basename,
      unstable_getContext: opts?.unstable_getContext,
      future: opts?.future,
      history: createBrowserHistory({ window: opts?.window }),
      hydrationData: opts?.hydrationData || parseHydrationData(),
      routes,
      mapRouteProperties,
      hydrationRouteProperties,
      dataStrategy: opts?.dataStrategy,
      patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
      window: opts?.window
    }).initialize();
  }
  function parseHydrationData() {
    let state = window?.__staticRouterHydrationData;
    if (state && state.errors) {
      state = {
        ...state,
        errors: deserializeErrors(state.errors)
      };
    }
    return state;
  }
  function deserializeErrors(errors) {
    if (!errors) return null;
    let entries = Object.entries(errors);
    let serialized = {};
    for (let [key, val] of entries) {
      if (val && val.__type === "RouteErrorResponse") {
        serialized[key] = new ErrorResponseImpl(
          val.status,
          val.statusText,
          val.data,
          val.internal === true
        );
      } else if (val && val.__type === "Error") {
        if (val.__subType) {
          let ErrorConstructor = window[val.__subType];
          if (typeof ErrorConstructor === "function") {
            try {
              let error = new ErrorConstructor(val.message);
              error.stack = "";
              serialized[key] = error;
            } catch (e) {
            }
          }
        }
        if (serialized[key] == null) {
          let error = new Error(val.message);
          error.stack = "";
          serialized[key] = error;
        }
      } else {
        serialized[key] = val;
      }
    }
    return serialized;
  }
  function HistoryRouter({
    basename,
    children,
    history
  }) {
    let [state, setStateImpl] = React10.useState({
      action: history.action,
      location: history.location
    });
    let setState = React10.useCallback(
      (newState) => {
        React10.startTransition(() => setStateImpl(newState));
      },
      [setStateImpl]
    );
    React10.useLayoutEffect(() => history.listen(setState), [history, setState]);
    return /* @__PURE__ */ React10.createElement(
      Router,
      {
        basename,
        children,
        location: state.location,
        navigationType: state.action,
        navigator: history
      }
    );
  }
  HistoryRouter.displayName = "unstable_HistoryRouter";
  var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
  var Link = React10.forwardRef(
    function LinkWithRef({
      onClick,
      discover = "render",
      prefetch = "none",
      relative,
      reloadDocument,
      replace: replace2,
      state,
      target,
      to,
      preventScrollReset,
      viewTransition,
      ...rest
    }, forwardedRef) {
      let { basename } = React10.useContext(NavigationContext);
      let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
      let absoluteHref;
      let isExternal = false;
      if (typeof to === "string" && isAbsolute) {
        absoluteHref = to;
        if (isBrowser) {
          try {
            let currentUrl = new URL(window.location.href);
            let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
            let path = stripBasename(targetUrl.pathname, basename);
            if (targetUrl.origin === currentUrl.origin && path != null) {
              to = path + targetUrl.search + targetUrl.hash;
            } else {
              isExternal = true;
            }
          } catch (e) {
            warning(
              false,
              `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
            );
          }
        }
      }
      let href2 = useHref(to, { relative });
      let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
        prefetch,
        rest
      );
      let internalOnClick = useLinkClickHandler(to, {
        replace: replace2,
        state,
        target,
        preventScrollReset,
        relative,
        viewTransition
      });
      function handleClick(event) {
        if (onClick) onClick(event);
        if (!event.defaultPrevented) {
          internalOnClick(event);
        }
      }
      let link = (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ React10.createElement(
          "a",
          {
            ...rest,
            ...prefetchHandlers,
            href: absoluteHref || href2,
            onClick: isExternal || reloadDocument ? onClick : handleClick,
            ref: mergeRefs(forwardedRef, prefetchRef),
            target,
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          }
        )
      );
      return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, { page: href2 })) : link;
    }
  );
  Link.displayName = "Link";
  var NavLink = React10.forwardRef(
    function NavLinkWithRef({
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end = false,
      style: styleProp,
      to,
      viewTransition,
      children,
      ...rest
    }, ref) {
      let path = useResolvedPath(to, { relative: rest.relative });
      let location = useLocation();
      let routerState = React10.useContext(DataRouterStateContext);
      let { navigator: navigator2, basename } = React10.useContext(NavigationContext);
      let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
      // eslint-disable-next-line react-hooks/rules-of-hooks
      useViewTransitionState(path) && viewTransition === true;
      let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
      let locationPathname = location.pathname;
      let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
      if (!caseSensitive) {
        locationPathname = locationPathname.toLowerCase();
        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
        toPathname = toPathname.toLowerCase();
      }
      if (nextLocationPathname && basename) {
        nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
      }
      const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
      let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
      let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
      let renderProps = {
        isActive,
        isPending,
        isTransitioning
      };
      let ariaCurrent = isActive ? ariaCurrentProp : void 0;
      let className;
      if (typeof classNameProp === "function") {
        className = classNameProp(renderProps);
      } else {
        className = [
          classNameProp,
          isActive ? "active" : null,
          isPending ? "pending" : null,
          isTransitioning ? "transitioning" : null
        ].filter(Boolean).join(" ");
      }
      let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
      return /* @__PURE__ */ React10.createElement(
        Link,
        {
          ...rest,
          "aria-current": ariaCurrent,
          className,
          ref,
          style,
          to,
          viewTransition
        },
        typeof children === "function" ? children(renderProps) : children
      );
    }
  );
  NavLink.displayName = "NavLink";
  var Form = React10.forwardRef(
    ({
      discover = "render",
      fetcherKey,
      navigate,
      reloadDocument,
      replace: replace2,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      viewTransition,
      ...props
    }, forwardedRef) => {
      let submit = useSubmit();
      let formAction = useFormAction(action, { relative });
      let formMethod = method.toLowerCase() === "get" ? "get" : "post";
      let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
      let submitHandler = (event) => {
        onSubmit && onSubmit(event);
        if (event.defaultPrevented) return;
        event.preventDefault();
        let submitter = event.nativeEvent.submitter;
        let submitMethod = submitter?.getAttribute("formmethod") || method;
        submit(submitter || event.currentTarget, {
          fetcherKey,
          method: submitMethod,
          navigate,
          replace: replace2,
          state,
          relative,
          preventScrollReset,
          viewTransition
        });
      };
      return /* @__PURE__ */ React10.createElement(
        "form",
        {
          ref: forwardedRef,
          method: formMethod,
          action: formAction,
          onSubmit: reloadDocument ? onSubmit : submitHandler,
          ...props,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }
      );
    }
  );
  Form.displayName = "Form";
  function ScrollRestoration({
    getKey,
    storageKey,
    ...props
  }) {
    let remixContext = React10.useContext(FrameworkContext);
    let { basename } = React10.useContext(NavigationContext);
    let location = useLocation();
    let matches = useMatches();
    useScrollRestoration({ getKey, storageKey });
    let ssrKey = React10.useMemo(
      () => {
        if (!remixContext || !getKey) return null;
        let userKey = getScrollRestorationKey(
          location,
          matches,
          basename,
          getKey
        );
        return userKey !== location.key ? userKey : null;
      },
      // Nah, we only need this the first time for the SSR render
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    if (!remixContext || remixContext.isSpaMode) {
      return null;
    }
    let restoreScroll = ((storageKey2, restoreKey) => {
      if (!window.history.state || !window.history.state.key) {
        let key = Math.random().toString(32).slice(2);
        window.history.replaceState({ key }, "");
      }
      try {
        let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
        let storedY = positions[restoreKey || window.history.state.key];
        if (typeof storedY === "number") {
          window.scrollTo(0, storedY);
        }
      } catch (error) {
        console.error(error);
        sessionStorage.removeItem(storageKey2);
      }
    }).toString();
    return /* @__PURE__ */ React10.createElement(
      "script",
      {
        ...props,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: {
          __html: `(${restoreScroll})(${JSON.stringify(
            storageKey || SCROLL_RESTORATION_STORAGE_KEY
          )}, ${JSON.stringify(ssrKey)})`
        }
      }
    );
  }
  ScrollRestoration.displayName = "ScrollRestoration";
  function getDataRouterConsoleError2(hookName) {
    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
  }
  function useDataRouterContext3(hookName) {
    let ctx = React10.useContext(DataRouterContext);
    invariant(ctx, getDataRouterConsoleError2(hookName));
    return ctx;
  }
  function useDataRouterState2(hookName) {
    let state = React10.useContext(DataRouterStateContext);
    invariant(state, getDataRouterConsoleError2(hookName));
    return state;
  }
  function useLinkClickHandler(to, {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = {}) {
    let navigate = useNavigate();
    let location = useLocation();
    let path = useResolvedPath(to, { relative });
    return React10.useCallback(
      (event) => {
        if (shouldProcessLinkClick(event, target)) {
          event.preventDefault();
          let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
          navigate(to, {
            replace: replace2,
            state,
            preventScrollReset,
            relative,
            viewTransition
          });
        }
      },
      [
        location,
        navigate,
        path,
        replaceProp,
        state,
        target,
        to,
        preventScrollReset,
        relative,
        viewTransition
      ]
    );
  }
  var fetcherId = 0;
  var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
  function useSubmit() {
    let { router: router2 } = useDataRouterContext3(
      "useSubmit"
      /* UseSubmit */
    );
    let { basename } = React10.useContext(NavigationContext);
    let currentRouteId = useRouteId();
    return React10.useCallback(
      async (target, options = {}) => {
        let { action, method, encType, formData, body } = getFormSubmissionInfo(
          target,
          basename
        );
        if (options.navigate === false) {
          let key = options.fetcherKey || getUniqueFetcherId();
          await router2.fetch(key, currentRouteId, options.action || action, {
            preventScrollReset: options.preventScrollReset,
            formData,
            body,
            formMethod: options.method || method,
            formEncType: options.encType || encType,
            flushSync: options.flushSync
          });
        } else {
          await router2.navigate(options.action || action, {
            preventScrollReset: options.preventScrollReset,
            formData,
            body,
            formMethod: options.method || method,
            formEncType: options.encType || encType,
            replace: options.replace,
            state: options.state,
            fromRouteId: currentRouteId,
            flushSync: options.flushSync,
            viewTransition: options.viewTransition
          });
        }
      },
      [router2, basename, currentRouteId]
    );
  }
  function useFormAction(action, { relative } = {}) {
    let { basename } = React10.useContext(NavigationContext);
    let routeContext = React10.useContext(RouteContext);
    invariant(routeContext, "useFormAction must be used inside a RouteContext");
    let [match] = routeContext.matches.slice(-1);
    let path = { ...useResolvedPath(action ? action : ".", { relative }) };
    let location = useLocation();
    if (action == null) {
      path.search = location.search;
      let params = new URLSearchParams(path.search);
      let indexValues = params.getAll("index");
      let hasNakedIndexParam = indexValues.some((v) => v === "");
      if (hasNakedIndexParam) {
        params.delete("index");
        indexValues.filter((v) => v).forEach((v) => params.append("index", v));
        let qs = params.toString();
        path.search = qs ? `?${qs}` : "";
      }
    }
    if ((!action || action === ".") && match.route.index) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    }
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    return createPath(path);
  }
  var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
  var savedScrollPositions = {};
  function getScrollRestorationKey(location, matches, basename, getKey) {
    let key = null;
    if (getKey) {
      if (basename !== "/") {
        key = getKey(
          {
            ...location,
            pathname: stripBasename(location.pathname, basename) || location.pathname
          },
          matches
        );
      } else {
        key = getKey(location, matches);
      }
    }
    if (key == null) {
      key = location.key;
    }
    return key;
  }
  function useScrollRestoration({
    getKey,
    storageKey
  } = {}) {
    let { router: router2 } = useDataRouterContext3(
      "useScrollRestoration"
      /* UseScrollRestoration */
    );
    let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(
      "useScrollRestoration"
      /* UseScrollRestoration */
    );
    let { basename } = React10.useContext(NavigationContext);
    let location = useLocation();
    let matches = useMatches();
    let navigation = useNavigation();
    React10.useEffect(() => {
      window.history.scrollRestoration = "manual";
      return () => {
        window.history.scrollRestoration = "auto";
      };
    }, []);
    usePageHide(
      React10.useCallback(() => {
        if (navigation.state === "idle") {
          let key = getScrollRestorationKey(location, matches, basename, getKey);
          savedScrollPositions[key] = window.scrollY;
        }
        try {
          sessionStorage.setItem(
            storageKey || SCROLL_RESTORATION_STORAGE_KEY,
            JSON.stringify(savedScrollPositions)
          );
        } catch (error) {
          warning(
            false,
            `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`
          );
        }
        window.history.scrollRestoration = "auto";
      }, [navigation.state, getKey, basename, location, matches, storageKey])
    );
    if (typeof document !== "undefined") {
      React10.useLayoutEffect(() => {
        try {
          let sessionPositions = sessionStorage.getItem(
            storageKey || SCROLL_RESTORATION_STORAGE_KEY
          );
          if (sessionPositions) {
            savedScrollPositions = JSON.parse(sessionPositions);
          }
        } catch (e) {
        }
      }, [storageKey]);
      React10.useLayoutEffect(() => {
        let disableScrollRestoration = router2?.enableScrollRestoration(
          savedScrollPositions,
          () => window.scrollY,
          getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0
        );
        return () => disableScrollRestoration && disableScrollRestoration();
      }, [router2, basename, getKey]);
      React10.useLayoutEffect(() => {
        if (restoreScrollPosition === false) {
          return;
        }
        if (typeof restoreScrollPosition === "number") {
          window.scrollTo(0, restoreScrollPosition);
          return;
        }
        if (location.hash) {
          let el = document.getElementById(
            decodeURIComponent(location.hash.slice(1))
          );
          if (el) {
            el.scrollIntoView();
            return;
          }
        }
        if (preventScrollReset === true) {
          return;
        }
        window.scrollTo(0, 0);
      }, [location, restoreScrollPosition, preventScrollReset]);
    }
  }
  function usePageHide(callback, options) {
    let { capture } = options || {};
    React10.useEffect(() => {
      let opts = capture != null ? { capture } : void 0;
      window.addEventListener("pagehide", callback, opts);
      return () => {
        window.removeEventListener("pagehide", callback, opts);
      };
    }, [callback, capture]);
  }
  function useViewTransitionState(to, opts = {}) {
    let vtContext = React10.useContext(ViewTransitionContext);
    invariant(
      vtContext != null,
      "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
    );
    let { basename } = useDataRouterContext3(
      "useViewTransitionState"
      /* useViewTransitionState */
    );
    let path = useResolvedPath(to, { relative: opts.relative });
    if (!vtContext.isTransitioning) {
      return false;
    }
    let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
    let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
    return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
  }
  var SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([
    ...NO_BODY_STATUS_CODES,
    304
  ]);

  // src/App.tsx
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-core/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-core/dist/ThemeContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_react = __toESM(require_react());
  var ThemeContext = (0, import_react.createContext)(void 0);
  var useTheme = () => {
    const ctx = (0, import_react.useContext)(ThemeContext);
    if (!ctx)
      throw new Error("No ThemeProvider found");
    return ctx;
  };

  // ../../packages/mcphappey-core/dist/CoreRoot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime18 = __toESM(require_jsx_runtime());
  var import_react18 = __toESM(require_react());

  // ../../packages/mcphappey-state/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-state/dist/store.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zustand/esm/index.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zustand/esm/vanilla.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_meta2 = {};
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace2) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState, getInitialState, subscribe, destroy };
    const initialState = state = createState(setState, getState, api);
    return api;
  };
  var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

  // ../../node_modules/zustand/esm/index.mjs
  var import_react2 = __toESM(require_react(), 1);
  var import_with_selector = __toESM(require_with_selector(), 1);
  var import_meta3 = {};
  var { useDebugValue } = import_react2.default;
  var { useSyncExternalStoreWithSelector } = import_with_selector.default;
  var didWarnAboutEqualityFn = false;
  var identity = (arg) => arg;
  function useStore(api, selector = identity, equalityFn) {
    if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
      console.warn(
        "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
      );
      didWarnAboutEqualityFn = true;
    }
    const slice = useSyncExternalStoreWithSelector(
      api.subscribe,
      api.getState,
      api.getServerState || api.getInitialState,
      selector,
      equalityFn
    );
    useDebugValue(slice);
    return slice;
  }
  var createImpl = (createState) => {
    if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && typeof createState !== "function") {
      console.warn(
        "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
      );
    }
    const api = typeof createState === "function" ? createStore(createState) : createState;
    const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  var create = (createState) => createState ? createImpl(createState) : createImpl;

  // ../../node_modules/zustand/esm/middleware.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_meta4 = {};
  function createJSONStorage(getStorage, options) {
    let storage;
    try {
      storage = getStorage();
    } catch (_e) {
      return;
    }
    const persistStorage = {
      getItem: (name) => {
        var _a;
        const parse2 = (str2) => {
          if (str2 === null) {
            return null;
          }
          return JSON.parse(str2, options == null ? void 0 : options.reviver);
        };
        const str = (_a = storage.getItem(name)) != null ? _a : null;
        if (str instanceof Promise) {
          return str.then(parse2);
        }
        return parse2(str);
      },
      setItem: (name, newValue) => storage.setItem(
        name,
        JSON.stringify(newValue, options == null ? void 0 : options.replacer)
      ),
      removeItem: (name) => storage.removeItem(name)
    };
    return persistStorage;
  }
  var toThenable = (fn) => (input) => {
    try {
      const result = fn(input);
      if (result instanceof Promise) {
        return result;
      }
      return {
        then(onFulfilled) {
          return toThenable(onFulfilled)(result);
        },
        catch(_onRejected) {
          return this;
        }
      };
    } catch (e) {
      return {
        then(_onFulfilled) {
          return this;
        },
        catch(onRejected) {
          return toThenable(onRejected)(e);
        }
      };
    }
  };
  var oldImpl = (config, baseOptions) => (set, get, api) => {
    let options = {
      getStorage: () => localStorage,
      serialize: JSON.stringify,
      deserialize: JSON.parse,
      partialize: (state) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState
      }),
      ...baseOptions
    };
    let hasHydrated = false;
    const hydrationListeners = /* @__PURE__ */ new Set();
    const finishHydrationListeners = /* @__PURE__ */ new Set();
    let storage;
    try {
      storage = options.getStorage();
    } catch (_e) {
    }
    if (!storage) {
      return config(
        (...args) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
          );
          set(...args);
        },
        get,
        api
      );
    }
    const thenableSerialize = toThenable(options.serialize);
    const setItem = () => {
      const state = options.partialize({ ...get() });
      let errorInSync;
      const thenable = thenableSerialize({ state, version: options.version }).then(
        (serializedValue) => storage.setItem(options.name, serializedValue)
      ).catch((e) => {
        errorInSync = e;
      });
      if (errorInSync) {
        throw errorInSync;
      }
      return thenable;
    };
    const savedSetState = api.setState;
    api.setState = (state, replace2) => {
      savedSetState(state, replace2);
      void setItem();
    };
    const configResult = config(
      (...args) => {
        set(...args);
        void setItem();
      },
      get,
      api
    );
    let stateFromStorage;
    const hydrate = () => {
      var _a;
      if (!storage) return;
      hasHydrated = false;
      hydrationListeners.forEach((cb) => cb(get()));
      const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
      return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
        if (storageValue) {
          return options.deserialize(storageValue);
        }
      }).then((deserializedStorageValue) => {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
            if (options.migrate) {
              return options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              );
            }
            console.error(
              `State loaded from storage couldn't be migrated since no migrate function was provided`
            );
          } else {
            return deserializedStorageValue.state;
          }
        }
      }).then((migratedState) => {
        var _a2;
        stateFromStorage = options.merge(
          migratedState,
          (_a2 = get()) != null ? _a2 : configResult
        );
        set(stateFromStorage, true);
        return setItem();
      }).then(() => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        hasHydrated = true;
        finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
      }).catch((e) => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
      });
    };
    api.persist = {
      setOptions: (newOptions) => {
        options = {
          ...options,
          ...newOptions
        };
        if (newOptions.getStorage) {
          storage = newOptions.getStorage();
        }
      },
      clearStorage: () => {
        storage == null ? void 0 : storage.removeItem(options.name);
      },
      getOptions: () => options,
      rehydrate: () => hydrate(),
      hasHydrated: () => hasHydrated,
      onHydrate: (cb) => {
        hydrationListeners.add(cb);
        return () => {
          hydrationListeners.delete(cb);
        };
      },
      onFinishHydration: (cb) => {
        finishHydrationListeners.add(cb);
        return () => {
          finishHydrationListeners.delete(cb);
        };
      }
    };
    hydrate();
    return stateFromStorage || configResult;
  };
  var newImpl = (config, baseOptions) => (set, get, api) => {
    let options = {
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState
      }),
      ...baseOptions
    };
    let hasHydrated = false;
    const hydrationListeners = /* @__PURE__ */ new Set();
    const finishHydrationListeners = /* @__PURE__ */ new Set();
    let storage = options.storage;
    if (!storage) {
      return config(
        (...args) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
          );
          set(...args);
        },
        get,
        api
      );
    }
    const setItem = () => {
      const state = options.partialize({ ...get() });
      return storage.setItem(options.name, {
        state,
        version: options.version
      });
    };
    const savedSetState = api.setState;
    api.setState = (state, replace2) => {
      savedSetState(state, replace2);
      void setItem();
    };
    const configResult = config(
      (...args) => {
        set(...args);
        void setItem();
      },
      get,
      api
    );
    api.getInitialState = () => configResult;
    let stateFromStorage;
    const hydrate = () => {
      var _a, _b;
      if (!storage) return;
      hasHydrated = false;
      hydrationListeners.forEach((cb) => {
        var _a2;
        return cb((_a2 = get()) != null ? _a2 : configResult);
      });
      const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
      return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
            if (options.migrate) {
              return [
                true,
                options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                )
              ];
            }
            console.error(
              `State loaded from storage couldn't be migrated since no migrate function was provided`
            );
          } else {
            return [false, deserializedStorageValue.state];
          }
        }
        return [false, void 0];
      }).then((migrationResult) => {
        var _a2;
        const [migrated, migratedState] = migrationResult;
        stateFromStorage = options.merge(
          migratedState,
          (_a2 = get()) != null ? _a2 : configResult
        );
        set(stateFromStorage, true);
        if (migrated) {
          return setItem();
        }
      }).then(() => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        stateFromStorage = get();
        hasHydrated = true;
        finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
      }).catch((e) => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
      });
    };
    api.persist = {
      setOptions: (newOptions) => {
        options = {
          ...options,
          ...newOptions
        };
        if (newOptions.storage) {
          storage = newOptions.storage;
        }
      },
      clearStorage: () => {
        storage == null ? void 0 : storage.removeItem(options.name);
      },
      getOptions: () => options,
      rehydrate: () => hydrate(),
      hasHydrated: () => hasHydrated,
      onHydrate: (cb) => {
        hydrationListeners.add(cb);
        return () => {
          hydrationListeners.delete(cb);
        };
      },
      onFinishHydration: (cb) => {
        finishHydrationListeners.add(cb);
        return () => {
          finishHydrationListeners.delete(cb);
        };
      }
    };
    if (!options.skipHydration) {
      hydrate();
    }
    return stateFromStorage || configResult;
  };
  var persistImpl = (config, baseOptions) => {
    if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
      if ((import_meta4.env ? import_meta4.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
        );
      }
      return oldImpl(config, baseOptions);
    }
    return newImpl(config, baseOptions);
  };
  var persist = persistImpl;

  // ../../packages/mcphappey-state/dist/unifiedServersSlice.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-http/index.ts
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-http/src/getJson.ts
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var getJson = async (url, init) => {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 1e4);
    try {
      const res = await fetch(url, { ...init, signal: controller.signal });
      clearTimeout(timeout);
      if (!res.ok) {
        return {
          ok: false,
          error: {
            url,
            status: res.status,
            message: `HTTP ${res.status} ${res.statusText}`
          }
        };
      }
      const data2 = await res.json();
      return { ok: true, data: data2 };
    } catch (err) {
      clearTimeout(timeout);
      let message = "Unknown error";
      if (err?.name === "AbortError") message = "Request timed out";
      else if (typeof err?.message === "string") message = err.message;
      return {
        ok: false,
        error: {
          url,
          message
        }
      };
    }
  };

  // ../../packages/mcphappey-http/src/fetchServerList.ts
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-http/src/schemas.ts
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zod/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zod/v3/index.js
  var v3_exports = {};
  __export(v3_exports, {
    BRAND: () => BRAND,
    DIRTY: () => DIRTY,
    EMPTY_PATH: () => EMPTY_PATH,
    INVALID: () => INVALID,
    NEVER: () => NEVER,
    OK: () => OK,
    ParseStatus: () => ParseStatus,
    Schema: () => ZodType,
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBigInt: () => ZodBigInt,
    ZodBoolean: () => ZodBoolean,
    ZodBranded: () => ZodBranded,
    ZodCatch: () => ZodCatch,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodEffects: () => ZodEffects,
    ZodEnum: () => ZodEnum,
    ZodError: () => ZodError,
    ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
    ZodFunction: () => ZodFunction,
    ZodIntersection: () => ZodIntersection,
    ZodIssueCode: () => ZodIssueCode,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNativeEnum: () => ZodNativeEnum,
    ZodNever: () => ZodNever,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodParsedType: () => ZodParsedType,
    ZodPipeline: () => ZodPipeline,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRecord: () => ZodRecord,
    ZodSchema: () => ZodType,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodSymbol: () => ZodSymbol,
    ZodTransformer: () => ZodEffects,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    addIssueToContext: () => addIssueToContext,
    any: () => anyType,
    array: () => arrayType,
    bigint: () => bigIntType,
    boolean: () => booleanType,
    coerce: () => coerce,
    custom: () => custom,
    date: () => dateType,
    datetimeRegex: () => datetimeRegex,
    default: () => v3_default,
    defaultErrorMap: () => en_default,
    discriminatedUnion: () => discriminatedUnionType,
    effect: () => effectsType,
    enum: () => enumType,
    function: () => functionType,
    getErrorMap: () => getErrorMap,
    getParsedType: () => getParsedType,
    instanceof: () => instanceOfType,
    intersection: () => intersectionType,
    isAborted: () => isAborted,
    isAsync: () => isAsync,
    isDirty: () => isDirty,
    isValid: () => isValid,
    late: () => late,
    lazy: () => lazyType,
    literal: () => literalType,
    makeIssue: () => makeIssue,
    map: () => mapType,
    nan: () => nanType,
    nativeEnum: () => nativeEnumType,
    never: () => neverType,
    null: () => nullType,
    nullable: () => nullableType,
    number: () => numberType,
    object: () => objectType,
    objectUtil: () => objectUtil,
    oboolean: () => oboolean,
    onumber: () => onumber,
    optional: () => optionalType,
    ostring: () => ostring,
    pipeline: () => pipelineType,
    preprocess: () => preprocessType,
    promise: () => promiseType,
    quotelessJson: () => quotelessJson,
    record: () => recordType,
    set: () => setType,
    setErrorMap: () => setErrorMap,
    strictObject: () => strictObjectType,
    string: () => stringType,
    symbol: () => symbolType,
    transformer: () => effectsType,
    tuple: () => tupleType,
    undefined: () => undefinedType,
    union: () => unionType,
    unknown: () => unknownType,
    util: () => util,
    void: () => voidType,
    z: () => external_exports
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zod/v3/external.js
  var external_exports = {};
  __export(external_exports, {
    BRAND: () => BRAND,
    DIRTY: () => DIRTY,
    EMPTY_PATH: () => EMPTY_PATH,
    INVALID: () => INVALID,
    NEVER: () => NEVER,
    OK: () => OK,
    ParseStatus: () => ParseStatus,
    Schema: () => ZodType,
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBigInt: () => ZodBigInt,
    ZodBoolean: () => ZodBoolean,
    ZodBranded: () => ZodBranded,
    ZodCatch: () => ZodCatch,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodEffects: () => ZodEffects,
    ZodEnum: () => ZodEnum,
    ZodError: () => ZodError,
    ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
    ZodFunction: () => ZodFunction,
    ZodIntersection: () => ZodIntersection,
    ZodIssueCode: () => ZodIssueCode,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNativeEnum: () => ZodNativeEnum,
    ZodNever: () => ZodNever,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodParsedType: () => ZodParsedType,
    ZodPipeline: () => ZodPipeline,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRecord: () => ZodRecord,
    ZodSchema: () => ZodType,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodSymbol: () => ZodSymbol,
    ZodTransformer: () => ZodEffects,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    addIssueToContext: () => addIssueToContext,
    any: () => anyType,
    array: () => arrayType,
    bigint: () => bigIntType,
    boolean: () => booleanType,
    coerce: () => coerce,
    custom: () => custom,
    date: () => dateType,
    datetimeRegex: () => datetimeRegex,
    defaultErrorMap: () => en_default,
    discriminatedUnion: () => discriminatedUnionType,
    effect: () => effectsType,
    enum: () => enumType,
    function: () => functionType,
    getErrorMap: () => getErrorMap,
    getParsedType: () => getParsedType,
    instanceof: () => instanceOfType,
    intersection: () => intersectionType,
    isAborted: () => isAborted,
    isAsync: () => isAsync,
    isDirty: () => isDirty,
    isValid: () => isValid,
    late: () => late,
    lazy: () => lazyType,
    literal: () => literalType,
    makeIssue: () => makeIssue,
    map: () => mapType,
    nan: () => nanType,
    nativeEnum: () => nativeEnumType,
    never: () => neverType,
    null: () => nullType,
    nullable: () => nullableType,
    number: () => numberType,
    object: () => objectType,
    objectUtil: () => objectUtil,
    oboolean: () => oboolean,
    onumber: () => onumber,
    optional: () => optionalType,
    ostring: () => ostring,
    pipeline: () => pipelineType,
    preprocess: () => preprocessType,
    promise: () => promiseType,
    quotelessJson: () => quotelessJson,
    record: () => recordType,
    set: () => setType,
    setErrorMap: () => setErrorMap,
    strictObject: () => strictObjectType,
    string: () => stringType,
    symbol: () => symbolType,
    transformer: () => effectsType,
    tuple: () => tupleType,
    undefined: () => undefinedType,
    union: () => unionType,
    unknown: () => unknownType,
    util: () => util,
    void: () => voidType
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zod/v3/errors.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zod/v3/locales/en.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zod/v3/ZodError.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zod/v3/helpers/util.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var util;
  (function(util2) {
    util2.assertEqual = (_) => {
    };
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data2) => {
    const t = typeof data2;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return Number.isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data2)) {
          return ZodParsedType.array;
        }
        if (data2 === null) {
          return ZodParsedType.null;
        }
        if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data2 instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data2 instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data2 instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };

  // ../../node_modules/zod/v3/ZodError.js
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class _ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof _ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };

  // ../../node_modules/zod/v3/locales/en.js
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "bigint")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var en_default = errorMap;

  // ../../node_modules/zod/v3/errors.js
  var overrideErrorMap = en_default;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }

  // ../../node_modules/zod/v3/helpers/parseUtil.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var makeIssue = (params) => {
    const { data: data2, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data: data2, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === en_default ? void 0 : en_default
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x) => x.status === "aborted";
  var isDirty = (x) => x.status === "dirty";
  var isValid = (x) => x.status === "valid";
  var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

  // ../../node_modules/zod/v3/types.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/zod/v3/helpers/errorUtil.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));

  // ../../node_modules/zod/v3/types.js
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data2, params) {
      const result = this.safeParse(data2, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data2, params) {
      const ctx = {
        common: {
          issues: [],
          async: params?.async ?? false,
          contextualErrorMap: params?.errorMap
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data2,
        parsedType: getParsedType(data2)
      };
      const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data2) {
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data2,
        parsedType: getParsedType(data2)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data: data2, path: [], parent: ctx });
          return isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if (err?.message?.toLowerCase()?.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data: data2, path: [], parent: ctx }).then((result) => isValid(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data2, params) {
      const result = await this.safeParseAsync(data2, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data2, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params?.errorMap,
          async: true
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data2,
        parsedType: getParsedType(data2)
      };
      const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data2) => {
            if (!data2) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data2) => this["~validate"](data2)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[0-9a-z]+$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var nanoidRegex = /^[a-z0-9_-]{21}$/i;
  var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  var dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      if (!header)
        return false;
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class _ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data2) => regex.test(data2), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  var ZodNumber = class _ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class _ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class _ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new _ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class _ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new _ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new _ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class _ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {
        } else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new _ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new _ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class _ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class _ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new _ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class _ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new _ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class _ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new _ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class _ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return _ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data2) => {
        return this._def.type.parseAsync(data2, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data2 = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data2 = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data: data2,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data2 = ctx.data;
      return this._def.type._parse({
        data: data2,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new _ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var ZodReadonly = class extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data2) => {
        if (isValid(data2)) {
          data2.value = Object.freeze(data2.value);
        }
        return data2;
      };
      return isAsync(result) ? result.then((data2) => freeze(data2)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function cleanParams(params, data2) {
    const p = typeof params === "function" ? params(data2) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data2, ctx) => {
        const r = check(data2);
        if (r instanceof Promise) {
          return r.then((r2) => {
            if (!r2) {
              const params = cleanParams(_params, data2);
              const _fatal = params.fatal ?? fatal ?? true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data2);
          const _fatal = params.fatal ?? fatal ?? true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data2) => data2 instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  var NEVER = INVALID;

  // ../../node_modules/zod/v3/index.js
  var v3_default = external_exports;

  // ../../packages/mcphappey-http/src/schemas.ts
  var mcpServerSchema = v3_exports.object({
    type: v3_exports.string(),
    url: v3_exports.string().url(),
    headers: v3_exports.record(v3_exports.string(), v3_exports.string()).optional()
  }).passthrough();
  var mcpServerListResponseSchema = v3_exports.object({
    servers: v3_exports.record(v3_exports.string(), mcpServerSchema)
  });

  // ../../packages/mcphappey-http/src/fetchServerList.ts
  var fetchServerList = async (url) => {
    const res = await getJson(url);
    if (!res.ok) return res;
    const parsed = mcpServerListResponseSchema.safeParse(res.data);
    if (!parsed.success) {
      return {
        ok: false,
        error: {
          url,
          message: "Invalid MCP server list format"
        }
      };
    }
    const serversObj = parsed.data.servers;
    const servers = Object.entries(serversObj).map(
      ([name, details]) => ({
        name,
        ...details
      })
    );
    return { ok: true, data: servers };
  };

  // ../../packages/mcphappey-state/dist/unifiedServersSlice.js
  var uniqBy = (arr, key) => {
    const seen = /* @__PURE__ */ new Set();
    return arr.filter((item) => {
      const k = key(item);
      if (seen.has(k))
        return false;
      seen.add(k);
      return true;
    });
  };
  var createUnifiedServersSlice = (set, get) => ({
    servers: [],
    loading: false,
    error: null,
    importList: async (url) => {
      set({ loading: true, error: null });
      try {
        const data2 = await fetchServerList(url);
        if (data2.ok == false) {
          throw new Error(data2.error.message);
        }
        const merged = uniqBy([...get().servers, ...data2.data], (s) => s.name + "|" + s.url);
        set({ servers: merged, loading: false });
      } catch (e) {
        set({ error: e?.message || "Failed to import server list", loading: false });
      }
    },
    clearAll: () => set({ servers: [] })
  });

  // ../../packages/mcphappey-state/dist/store.js
  var useAppStore = create()(persist((...a) => createUnifiedServersSlice(...a), {
    name: "mcp_servers",
    // localStorage key
    partialize: (state) => ({ servers: state.servers })
  }));

  // ../../packages/mcphappey-state/dist/selectors.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-state/dist/mcpStore.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-mcp/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-mcp/dist/createClient.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var LATEST_PROTOCOL_VERSION = "2025-06-18";
  var SUPPORTED_PROTOCOL_VERSIONS = [
    LATEST_PROTOCOL_VERSION,
    "2025-03-26",
    "2024-11-05",
    "2024-10-07"
  ];
  var JSONRPC_VERSION = "2.0";
  var ProgressTokenSchema = v3_exports.union([v3_exports.string(), v3_exports.number().int()]);
  var CursorSchema = v3_exports.string();
  var RequestMetaSchema = v3_exports.object({
    /**
     * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
     */
    progressToken: v3_exports.optional(ProgressTokenSchema)
  }).passthrough();
  var BaseRequestParamsSchema = v3_exports.object({
    _meta: v3_exports.optional(RequestMetaSchema)
  }).passthrough();
  var RequestSchema = v3_exports.object({
    method: v3_exports.string(),
    params: v3_exports.optional(BaseRequestParamsSchema)
  });
  var BaseNotificationParamsSchema = v3_exports.object({
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  }).passthrough();
  var NotificationSchema = v3_exports.object({
    method: v3_exports.string(),
    params: v3_exports.optional(BaseNotificationParamsSchema)
  });
  var ResultSchema = v3_exports.object({
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  }).passthrough();
  var RequestIdSchema = v3_exports.union([v3_exports.string(), v3_exports.number().int()]);
  var JSONRPCRequestSchema = v3_exports.object({
    jsonrpc: v3_exports.literal(JSONRPC_VERSION),
    id: RequestIdSchema
  }).merge(RequestSchema).strict();
  var isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
  var JSONRPCNotificationSchema = v3_exports.object({
    jsonrpc: v3_exports.literal(JSONRPC_VERSION)
  }).merge(NotificationSchema).strict();
  var isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
  var JSONRPCResponseSchema = v3_exports.object({
    jsonrpc: v3_exports.literal(JSONRPC_VERSION),
    id: RequestIdSchema,
    result: ResultSchema
  }).strict();
  var isJSONRPCResponse = (value) => JSONRPCResponseSchema.safeParse(value).success;
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
    ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
    ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
    ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
    ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
    ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
    ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  })(ErrorCode || (ErrorCode = {}));
  var JSONRPCErrorSchema = v3_exports.object({
    jsonrpc: v3_exports.literal(JSONRPC_VERSION),
    id: RequestIdSchema,
    error: v3_exports.object({
      /**
       * The error type that occurred.
       */
      code: v3_exports.number().int(),
      /**
       * A short description of the error. The message SHOULD be limited to a concise single sentence.
       */
      message: v3_exports.string(),
      /**
       * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
       */
      data: v3_exports.optional(v3_exports.unknown())
    })
  }).strict();
  var isJSONRPCError = (value) => JSONRPCErrorSchema.safeParse(value).success;
  var JSONRPCMessageSchema = v3_exports.union([
    JSONRPCRequestSchema,
    JSONRPCNotificationSchema,
    JSONRPCResponseSchema,
    JSONRPCErrorSchema
  ]);
  var EmptyResultSchema = ResultSchema.strict();
  var CancelledNotificationSchema = NotificationSchema.extend({
    method: v3_exports.literal("notifications/cancelled"),
    params: BaseNotificationParamsSchema.extend({
      /**
       * The ID of the request to cancel.
       *
       * This MUST correspond to the ID of a request previously issued in the same direction.
       */
      requestId: RequestIdSchema,
      /**
       * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
       */
      reason: v3_exports.string().optional()
    })
  });
  var BaseMetadataSchema = v3_exports.object({
    /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
    name: v3_exports.string(),
    /**
    * Intended for UI and end-user contexts — optimized to be human-readable and easily understood,
    * even by those unfamiliar with domain-specific terminology.
    *
    * If not provided, the name should be used for display (except for Tool,
    * where `annotations.title` should be given precedence over using `name`,
    * if present).
    */
    title: v3_exports.optional(v3_exports.string())
  }).passthrough();
  var ImplementationSchema = BaseMetadataSchema.extend({
    version: v3_exports.string()
  });
  var ClientCapabilitiesSchema = v3_exports.object({
    /**
     * Experimental, non-standard capabilities that the client supports.
     */
    experimental: v3_exports.optional(v3_exports.object({}).passthrough()),
    /**
     * Present if the client supports sampling from an LLM.
     */
    sampling: v3_exports.optional(v3_exports.object({}).passthrough()),
    /**
     * Present if the client supports eliciting user input.
     */
    elicitation: v3_exports.optional(v3_exports.object({}).passthrough()),
    /**
     * Present if the client supports listing roots.
     */
    roots: v3_exports.optional(v3_exports.object({
      /**
       * Whether the client supports issuing notifications for changes to the roots list.
       */
      listChanged: v3_exports.optional(v3_exports.boolean())
    }).passthrough())
  }).passthrough();
  var InitializeRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("initialize"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
       */
      protocolVersion: v3_exports.string(),
      capabilities: ClientCapabilitiesSchema,
      clientInfo: ImplementationSchema
    })
  });
  var ServerCapabilitiesSchema = v3_exports.object({
    /**
     * Experimental, non-standard capabilities that the server supports.
     */
    experimental: v3_exports.optional(v3_exports.object({}).passthrough()),
    /**
     * Present if the server supports sending log messages to the client.
     */
    logging: v3_exports.optional(v3_exports.object({}).passthrough()),
    /**
     * Present if the server supports sending completions to the client.
     */
    completions: v3_exports.optional(v3_exports.object({}).passthrough()),
    /**
     * Present if the server offers any prompt templates.
     */
    prompts: v3_exports.optional(v3_exports.object({
      /**
       * Whether this server supports issuing notifications for changes to the prompt list.
       */
      listChanged: v3_exports.optional(v3_exports.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any resources to read.
     */
    resources: v3_exports.optional(v3_exports.object({
      /**
       * Whether this server supports clients subscribing to resource updates.
       */
      subscribe: v3_exports.optional(v3_exports.boolean()),
      /**
       * Whether this server supports issuing notifications for changes to the resource list.
       */
      listChanged: v3_exports.optional(v3_exports.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any tools to call.
     */
    tools: v3_exports.optional(v3_exports.object({
      /**
       * Whether this server supports issuing notifications for changes to the tool list.
       */
      listChanged: v3_exports.optional(v3_exports.boolean())
    }).passthrough())
  }).passthrough();
  var InitializeResultSchema = ResultSchema.extend({
    /**
     * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
     */
    protocolVersion: v3_exports.string(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ImplementationSchema,
    /**
     * Instructions describing how to use the server and its features.
     *
     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
     */
    instructions: v3_exports.optional(v3_exports.string())
  });
  var InitializedNotificationSchema = NotificationSchema.extend({
    method: v3_exports.literal("notifications/initialized")
  });
  var isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
  var PingRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("ping")
  });
  var ProgressSchema = v3_exports.object({
    /**
     * The progress thus far. This should increase every time progress is made, even if the total is unknown.
     */
    progress: v3_exports.number(),
    /**
     * Total number of items to process (or total progress required), if known.
     */
    total: v3_exports.optional(v3_exports.number()),
    /**
     * An optional message describing the current progress.
     */
    message: v3_exports.optional(v3_exports.string())
  }).passthrough();
  var ProgressNotificationSchema = NotificationSchema.extend({
    method: v3_exports.literal("notifications/progress"),
    params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({
      /**
       * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
       */
      progressToken: ProgressTokenSchema
    })
  });
  var PaginatedRequestSchema = RequestSchema.extend({
    params: BaseRequestParamsSchema.extend({
      /**
       * An opaque token representing the current pagination position.
       * If provided, the server should return results starting after this cursor.
       */
      cursor: v3_exports.optional(CursorSchema)
    }).optional()
  });
  var PaginatedResultSchema = ResultSchema.extend({
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: v3_exports.optional(CursorSchema)
  });
  var ResourceContentsSchema = v3_exports.object({
    /**
     * The URI of this resource.
     */
    uri: v3_exports.string(),
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: v3_exports.optional(v3_exports.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  }).passthrough();
  var TextResourceContentsSchema = ResourceContentsSchema.extend({
    /**
     * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
     */
    text: v3_exports.string()
  });
  var BlobResourceContentsSchema = ResourceContentsSchema.extend({
    /**
     * A base64-encoded string representing the binary data of the item.
     */
    blob: v3_exports.string().base64()
  });
  var ResourceSchema = BaseMetadataSchema.extend({
    /**
     * The URI of this resource.
     */
    uri: v3_exports.string(),
    /**
     * A description of what this resource represents.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */
    description: v3_exports.optional(v3_exports.string()),
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: v3_exports.optional(v3_exports.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  });
  var ResourceTemplateSchema = BaseMetadataSchema.extend({
    /**
     * A URI template (according to RFC 6570) that can be used to construct resource URIs.
     */
    uriTemplate: v3_exports.string(),
    /**
     * A description of what this template is for.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */
    description: v3_exports.optional(v3_exports.string()),
    /**
     * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
     */
    mimeType: v3_exports.optional(v3_exports.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  });
  var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
    method: v3_exports.literal("resources/list")
  });
  var ListResourcesResultSchema = PaginatedResultSchema.extend({
    resources: v3_exports.array(ResourceSchema)
  });
  var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
    method: v3_exports.literal("resources/templates/list")
  });
  var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
    resourceTemplates: v3_exports.array(ResourceTemplateSchema)
  });
  var ReadResourceRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("resources/read"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
       */
      uri: v3_exports.string()
    })
  });
  var ReadResourceResultSchema = ResultSchema.extend({
    contents: v3_exports.array(v3_exports.union([TextResourceContentsSchema, BlobResourceContentsSchema]))
  });
  var ResourceListChangedNotificationSchema = NotificationSchema.extend({
    method: v3_exports.literal("notifications/resources/list_changed")
  });
  var SubscribeRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("resources/subscribe"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.
       */
      uri: v3_exports.string()
    })
  });
  var UnsubscribeRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("resources/unsubscribe"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The URI of the resource to unsubscribe from.
       */
      uri: v3_exports.string()
    })
  });
  var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
    method: v3_exports.literal("notifications/resources/updated"),
    params: BaseNotificationParamsSchema.extend({
      /**
       * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
       */
      uri: v3_exports.string()
    })
  });
  var PromptArgumentSchema = v3_exports.object({
    /**
     * The name of the argument.
     */
    name: v3_exports.string(),
    /**
     * A human-readable description of the argument.
     */
    description: v3_exports.optional(v3_exports.string()),
    /**
     * Whether this argument must be provided.
     */
    required: v3_exports.optional(v3_exports.boolean())
  }).passthrough();
  var PromptSchema = BaseMetadataSchema.extend({
    /**
     * An optional description of what this prompt provides
     */
    description: v3_exports.optional(v3_exports.string()),
    /**
     * A list of arguments to use for templating the prompt.
     */
    arguments: v3_exports.optional(v3_exports.array(PromptArgumentSchema)),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  });
  var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
    method: v3_exports.literal("prompts/list")
  });
  var ListPromptsResultSchema = PaginatedResultSchema.extend({
    prompts: v3_exports.array(PromptSchema)
  });
  var GetPromptRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("prompts/get"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The name of the prompt or prompt template.
       */
      name: v3_exports.string(),
      /**
       * Arguments to use for templating the prompt.
       */
      arguments: v3_exports.optional(v3_exports.record(v3_exports.string()))
    })
  });
  var TextContentSchema = v3_exports.object({
    type: v3_exports.literal("text"),
    /**
     * The text content of the message.
     */
    text: v3_exports.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  }).passthrough();
  var ImageContentSchema = v3_exports.object({
    type: v3_exports.literal("image"),
    /**
     * The base64-encoded image data.
     */
    data: v3_exports.string().base64(),
    /**
     * The MIME type of the image. Different providers may support different image types.
     */
    mimeType: v3_exports.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  }).passthrough();
  var AudioContentSchema = v3_exports.object({
    type: v3_exports.literal("audio"),
    /**
     * The base64-encoded audio data.
     */
    data: v3_exports.string().base64(),
    /**
     * The MIME type of the audio. Different providers may support different audio types.
     */
    mimeType: v3_exports.string(),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  }).passthrough();
  var EmbeddedResourceSchema = v3_exports.object({
    type: v3_exports.literal("resource"),
    resource: v3_exports.union([TextResourceContentsSchema, BlobResourceContentsSchema]),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  }).passthrough();
  var ResourceLinkSchema = ResourceSchema.extend({
    type: v3_exports.literal("resource_link")
  });
  var ContentBlockSchema = v3_exports.union([
    TextContentSchema,
    ImageContentSchema,
    AudioContentSchema,
    ResourceLinkSchema,
    EmbeddedResourceSchema
  ]);
  var PromptMessageSchema = v3_exports.object({
    role: v3_exports.enum(["user", "assistant"]),
    content: ContentBlockSchema
  }).passthrough();
  var GetPromptResultSchema = ResultSchema.extend({
    /**
     * An optional description for the prompt.
     */
    description: v3_exports.optional(v3_exports.string()),
    messages: v3_exports.array(PromptMessageSchema)
  });
  var PromptListChangedNotificationSchema = NotificationSchema.extend({
    method: v3_exports.literal("notifications/prompts/list_changed")
  });
  var ToolAnnotationsSchema = v3_exports.object({
    /**
     * A human-readable title for the tool.
     */
    title: v3_exports.optional(v3_exports.string()),
    /**
     * If true, the tool does not modify its environment.
     *
     * Default: false
     */
    readOnlyHint: v3_exports.optional(v3_exports.boolean()),
    /**
     * If true, the tool may perform destructive updates to its environment.
     * If false, the tool performs only additive updates.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: true
     */
    destructiveHint: v3_exports.optional(v3_exports.boolean()),
    /**
     * If true, calling the tool repeatedly with the same arguments
     * will have no additional effect on the its environment.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: false
     */
    idempotentHint: v3_exports.optional(v3_exports.boolean()),
    /**
     * If true, this tool may interact with an "open world" of external
     * entities. If false, the tool's domain of interaction is closed.
     * For example, the world of a web search tool is open, whereas that
     * of a memory tool is not.
     *
     * Default: true
     */
    openWorldHint: v3_exports.optional(v3_exports.boolean())
  }).passthrough();
  var ToolSchema = BaseMetadataSchema.extend({
    /**
     * A human-readable description of the tool.
     */
    description: v3_exports.optional(v3_exports.string()),
    /**
     * A JSON Schema object defining the expected parameters for the tool.
     */
    inputSchema: v3_exports.object({
      type: v3_exports.literal("object"),
      properties: v3_exports.optional(v3_exports.object({}).passthrough()),
      required: v3_exports.optional(v3_exports.array(v3_exports.string()))
    }).passthrough(),
    /**
     * An optional JSON Schema object defining the structure of the tool's output returned in
     * the structuredContent field of a CallToolResult.
     */
    outputSchema: v3_exports.optional(v3_exports.object({
      type: v3_exports.literal("object"),
      properties: v3_exports.optional(v3_exports.object({}).passthrough()),
      required: v3_exports.optional(v3_exports.array(v3_exports.string()))
    }).passthrough()),
    /**
     * Optional additional tool information.
     */
    annotations: v3_exports.optional(ToolAnnotationsSchema),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  });
  var ListToolsRequestSchema = PaginatedRequestSchema.extend({
    method: v3_exports.literal("tools/list")
  });
  var ListToolsResultSchema = PaginatedResultSchema.extend({
    tools: v3_exports.array(ToolSchema)
  });
  var CallToolResultSchema = ResultSchema.extend({
    /**
     * A list of content objects that represent the result of the tool call.
     *
     * If the Tool does not define an outputSchema, this field MUST be present in the result.
     * For backwards compatibility, this field is always present, but it may be empty.
     */
    content: v3_exports.array(ContentBlockSchema).default([]),
    /**
     * An object containing structured tool output.
     *
     * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
     */
    structuredContent: v3_exports.object({}).passthrough().optional(),
    /**
     * Whether the tool call ended in an error.
     *
     * If not set, this is assumed to be false (the call was successful).
     *
     * Any errors that originate from the tool SHOULD be reported inside the result
     * object, with `isError` set to true, _not_ as an MCP protocol-level error
     * response. Otherwise, the LLM would not be able to see that an error occurred
     * and self-correct.
     *
     * However, any errors in _finding_ the tool, an error indicating that the
     * server does not support tool calls, or any other exceptional conditions,
     * should be reported as an MCP error response.
     */
    isError: v3_exports.optional(v3_exports.boolean())
  });
  var CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
    toolResult: v3_exports.unknown()
  }));
  var CallToolRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("tools/call"),
    params: BaseRequestParamsSchema.extend({
      name: v3_exports.string(),
      arguments: v3_exports.optional(v3_exports.record(v3_exports.unknown()))
    })
  });
  var ToolListChangedNotificationSchema = NotificationSchema.extend({
    method: v3_exports.literal("notifications/tools/list_changed")
  });
  var LoggingLevelSchema = v3_exports.enum([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency"
  ]);
  var SetLevelRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("logging/setLevel"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
       */
      level: LoggingLevelSchema
    })
  });
  var LoggingMessageNotificationSchema = NotificationSchema.extend({
    method: v3_exports.literal("notifications/message"),
    params: BaseNotificationParamsSchema.extend({
      /**
       * The severity of this log message.
       */
      level: LoggingLevelSchema,
      /**
       * An optional name of the logger issuing this message.
       */
      logger: v3_exports.optional(v3_exports.string()),
      /**
       * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
       */
      data: v3_exports.unknown()
    })
  });
  var ModelHintSchema = v3_exports.object({
    /**
     * A hint for a model name.
     */
    name: v3_exports.string().optional()
  }).passthrough();
  var ModelPreferencesSchema = v3_exports.object({
    /**
     * Optional hints to use for model selection.
     */
    hints: v3_exports.optional(v3_exports.array(ModelHintSchema)),
    /**
     * How much to prioritize cost when selecting a model.
     */
    costPriority: v3_exports.optional(v3_exports.number().min(0).max(1)),
    /**
     * How much to prioritize sampling speed (latency) when selecting a model.
     */
    speedPriority: v3_exports.optional(v3_exports.number().min(0).max(1)),
    /**
     * How much to prioritize intelligence and capabilities when selecting a model.
     */
    intelligencePriority: v3_exports.optional(v3_exports.number().min(0).max(1))
  }).passthrough();
  var SamplingMessageSchema = v3_exports.object({
    role: v3_exports.enum(["user", "assistant"]),
    content: v3_exports.union([TextContentSchema, ImageContentSchema, AudioContentSchema])
  }).passthrough();
  var CreateMessageRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("sampling/createMessage"),
    params: BaseRequestParamsSchema.extend({
      messages: v3_exports.array(SamplingMessageSchema),
      /**
       * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
       */
      systemPrompt: v3_exports.optional(v3_exports.string()),
      /**
       * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
       */
      includeContext: v3_exports.optional(v3_exports.enum(["none", "thisServer", "allServers"])),
      temperature: v3_exports.optional(v3_exports.number()),
      /**
       * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
       */
      maxTokens: v3_exports.number().int(),
      stopSequences: v3_exports.optional(v3_exports.array(v3_exports.string())),
      /**
       * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
       */
      metadata: v3_exports.optional(v3_exports.object({}).passthrough()),
      /**
       * The server's preferences for which model to select.
       */
      modelPreferences: v3_exports.optional(ModelPreferencesSchema)
    })
  });
  var CreateMessageResultSchema = ResultSchema.extend({
    /**
     * The name of the model that generated the message.
     */
    model: v3_exports.string(),
    /**
     * The reason why sampling stopped.
     */
    stopReason: v3_exports.optional(v3_exports.enum(["endTurn", "stopSequence", "maxTokens"]).or(v3_exports.string())),
    role: v3_exports.enum(["user", "assistant"]),
    content: v3_exports.discriminatedUnion("type", [
      TextContentSchema,
      ImageContentSchema,
      AudioContentSchema
    ])
  });
  var BooleanSchemaSchema = v3_exports.object({
    type: v3_exports.literal("boolean"),
    title: v3_exports.optional(v3_exports.string()),
    description: v3_exports.optional(v3_exports.string()),
    default: v3_exports.optional(v3_exports.boolean())
  }).passthrough();
  var StringSchemaSchema = v3_exports.object({
    type: v3_exports.literal("string"),
    title: v3_exports.optional(v3_exports.string()),
    description: v3_exports.optional(v3_exports.string()),
    minLength: v3_exports.optional(v3_exports.number()),
    maxLength: v3_exports.optional(v3_exports.number()),
    format: v3_exports.optional(v3_exports.enum(["email", "uri", "date", "date-time"]))
  }).passthrough();
  var NumberSchemaSchema = v3_exports.object({
    type: v3_exports.enum(["number", "integer"]),
    title: v3_exports.optional(v3_exports.string()),
    description: v3_exports.optional(v3_exports.string()),
    minimum: v3_exports.optional(v3_exports.number()),
    maximum: v3_exports.optional(v3_exports.number())
  }).passthrough();
  var EnumSchemaSchema = v3_exports.object({
    type: v3_exports.literal("string"),
    title: v3_exports.optional(v3_exports.string()),
    description: v3_exports.optional(v3_exports.string()),
    enum: v3_exports.array(v3_exports.string()),
    enumNames: v3_exports.optional(v3_exports.array(v3_exports.string()))
  }).passthrough();
  var PrimitiveSchemaDefinitionSchema = v3_exports.union([
    BooleanSchemaSchema,
    StringSchemaSchema,
    NumberSchemaSchema,
    EnumSchemaSchema
  ]);
  var ElicitRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("elicitation/create"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The message to present to the user.
       */
      message: v3_exports.string(),
      /**
       * The schema for the requested user input.
       */
      requestedSchema: v3_exports.object({
        type: v3_exports.literal("object"),
        properties: v3_exports.record(v3_exports.string(), PrimitiveSchemaDefinitionSchema),
        required: v3_exports.optional(v3_exports.array(v3_exports.string()))
      }).passthrough()
    })
  });
  var ElicitResultSchema = ResultSchema.extend({
    /**
     * The user's response action.
     */
    action: v3_exports.enum(["accept", "reject", "cancel"]),
    /**
     * The collected user input content (only present if action is "accept").
     */
    content: v3_exports.optional(v3_exports.record(v3_exports.string(), v3_exports.unknown()))
  });
  var ResourceTemplateReferenceSchema = v3_exports.object({
    type: v3_exports.literal("ref/resource"),
    /**
     * The URI or URI template of the resource.
     */
    uri: v3_exports.string()
  }).passthrough();
  var PromptReferenceSchema = v3_exports.object({
    type: v3_exports.literal("ref/prompt"),
    /**
     * The name of the prompt or prompt template
     */
    name: v3_exports.string()
  }).passthrough();
  var CompleteRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("completion/complete"),
    params: BaseRequestParamsSchema.extend({
      ref: v3_exports.union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
      /**
       * The argument's information
       */
      argument: v3_exports.object({
        /**
         * The name of the argument
         */
        name: v3_exports.string(),
        /**
         * The value of the argument to use for completion matching.
         */
        value: v3_exports.string()
      }).passthrough(),
      context: v3_exports.optional(v3_exports.object({
        /**
         * Previously-resolved variables in a URI template or prompt.
         */
        arguments: v3_exports.optional(v3_exports.record(v3_exports.string(), v3_exports.string()))
      }))
    })
  });
  var CompleteResultSchema = ResultSchema.extend({
    completion: v3_exports.object({
      /**
       * An array of completion values. Must not exceed 100 items.
       */
      values: v3_exports.array(v3_exports.string()).max(100),
      /**
       * The total number of completion options available. This can exceed the number of values actually sent in the response.
       */
      total: v3_exports.optional(v3_exports.number().int()),
      /**
       * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
       */
      hasMore: v3_exports.optional(v3_exports.boolean())
    }).passthrough()
  });
  var RootSchema = v3_exports.object({
    /**
     * The URI identifying the root. This *must* start with file:// for now.
     */
    uri: v3_exports.string().startsWith("file://"),
    /**
     * An optional name for the root.
     */
    name: v3_exports.optional(v3_exports.string()),
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: v3_exports.optional(v3_exports.object({}).passthrough())
  }).passthrough();
  var ListRootsRequestSchema = RequestSchema.extend({
    method: v3_exports.literal("roots/list")
  });
  var ListRootsResultSchema = ResultSchema.extend({
    roots: v3_exports.array(RootSchema)
  });
  var RootsListChangedNotificationSchema = NotificationSchema.extend({
    method: v3_exports.literal("notifications/roots/list_changed")
  });
  var ClientRequestSchema = v3_exports.union([
    PingRequestSchema,
    InitializeRequestSchema,
    CompleteRequestSchema,
    SetLevelRequestSchema,
    GetPromptRequestSchema,
    ListPromptsRequestSchema,
    ListResourcesRequestSchema,
    ListResourceTemplatesRequestSchema,
    ReadResourceRequestSchema,
    SubscribeRequestSchema,
    UnsubscribeRequestSchema,
    CallToolRequestSchema,
    ListToolsRequestSchema
  ]);
  var ClientNotificationSchema = v3_exports.union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    InitializedNotificationSchema,
    RootsListChangedNotificationSchema
  ]);
  var ClientResultSchema = v3_exports.union([
    EmptyResultSchema,
    CreateMessageResultSchema,
    ElicitResultSchema,
    ListRootsResultSchema
  ]);
  var ServerRequestSchema = v3_exports.union([
    PingRequestSchema,
    CreateMessageRequestSchema,
    ElicitRequestSchema,
    ListRootsRequestSchema
  ]);
  var ServerNotificationSchema = v3_exports.union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    LoggingMessageNotificationSchema,
    ResourceUpdatedNotificationSchema,
    ResourceListChangedNotificationSchema,
    ToolListChangedNotificationSchema,
    PromptListChangedNotificationSchema
  ]);
  var ServerResultSchema = v3_exports.union([
    EmptyResultSchema,
    InitializeResultSchema,
    CompleteResultSchema,
    GetPromptResultSchema,
    ListPromptsResultSchema,
    ListResourcesResultSchema,
    ListResourceTemplatesResultSchema,
    ReadResourceResultSchema,
    CallToolResultSchema,
    ListToolsResultSchema
  ]);
  var McpError = class extends Error {
    constructor(code, message, data2) {
      super(`MCP error ${code}: ${message}`);
      this.code = code;
      this.data = data2;
      this.name = "McpError";
    }
  };

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
  var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
  var Protocol = class {
    constructor(_options) {
      this._options = _options;
      this._requestMessageId = 0;
      this._requestHandlers = /* @__PURE__ */ new Map();
      this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
      this._notificationHandlers = /* @__PURE__ */ new Map();
      this._responseHandlers = /* @__PURE__ */ new Map();
      this._progressHandlers = /* @__PURE__ */ new Map();
      this._timeoutInfo = /* @__PURE__ */ new Map();
      this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
        const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
        controller === null || controller === void 0 ? void 0 : controller.abort(notification.params.reason);
      });
      this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
        this._onprogress(notification);
      });
      this.setRequestHandler(
        PingRequestSchema,
        // Automatic pong by default.
        (_request) => ({})
      );
    }
    _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
      this._timeoutInfo.set(messageId, {
        timeoutId: setTimeout(onTimeout, timeout),
        startTime: Date.now(),
        timeout,
        maxTotalTimeout,
        resetTimeoutOnProgress,
        onTimeout
      });
    }
    _resetTimeout(messageId) {
      const info = this._timeoutInfo.get(messageId);
      if (!info)
        return false;
      const totalElapsed = Date.now() - info.startTime;
      if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
        this._timeoutInfo.delete(messageId);
        throw new McpError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", { maxTotalTimeout: info.maxTotalTimeout, totalElapsed });
      }
      clearTimeout(info.timeoutId);
      info.timeoutId = setTimeout(info.onTimeout, info.timeout);
      return true;
    }
    _cleanupTimeout(messageId) {
      const info = this._timeoutInfo.get(messageId);
      if (info) {
        clearTimeout(info.timeoutId);
        this._timeoutInfo.delete(messageId);
      }
    }
    /**
     * Attaches to the given transport, starts it, and starts listening for messages.
     *
     * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
     */
    async connect(transport) {
      var _a, _b, _c;
      this._transport = transport;
      const _onclose = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.onclose;
      this._transport.onclose = () => {
        _onclose === null || _onclose === void 0 ? void 0 : _onclose();
        this._onclose();
      };
      const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
      this._transport.onerror = (error) => {
        _onerror === null || _onerror === void 0 ? void 0 : _onerror(error);
        this._onerror(error);
      };
      const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
      this._transport.onmessage = (message, extra) => {
        _onmessage === null || _onmessage === void 0 ? void 0 : _onmessage(message, extra);
        if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
          this._onresponse(message);
        } else if (isJSONRPCRequest(message)) {
          this._onrequest(message, extra);
        } else if (isJSONRPCNotification(message)) {
          this._onnotification(message);
        } else {
          this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
        }
      };
      await this._transport.start();
    }
    _onclose() {
      var _a;
      const responseHandlers = this._responseHandlers;
      this._responseHandlers = /* @__PURE__ */ new Map();
      this._progressHandlers.clear();
      this._transport = void 0;
      (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(this);
      const error = new McpError(ErrorCode.ConnectionClosed, "Connection closed");
      for (const handler of responseHandlers.values()) {
        handler(error);
      }
    }
    _onerror(error) {
      var _a;
      (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
    }
    _onnotification(notification) {
      var _a;
      const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;
      if (handler === void 0) {
        return;
      }
      Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
    }
    _onrequest(request, extra) {
      var _a, _b, _c, _d;
      const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;
      if (handler === void 0) {
        (_b = this._transport) === null || _b === void 0 ? void 0 : _b.send({
          jsonrpc: "2.0",
          id: request.id,
          error: {
            code: ErrorCode.MethodNotFound,
            message: "Method not found"
          }
        }).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
        return;
      }
      const abortController = new AbortController();
      this._requestHandlerAbortControllers.set(request.id, abortController);
      const fullExtra = {
        signal: abortController.signal,
        sessionId: (_c = this._transport) === null || _c === void 0 ? void 0 : _c.sessionId,
        _meta: (_d = request.params) === null || _d === void 0 ? void 0 : _d._meta,
        sendNotification: (notification) => this.notification(notification, { relatedRequestId: request.id }),
        sendRequest: (r, resultSchema, options) => this.request(r, resultSchema, { ...options, relatedRequestId: request.id }),
        authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
        requestId: request.id,
        requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo
      };
      Promise.resolve().then(() => handler(request, fullExtra)).then((result) => {
        var _a2;
        if (abortController.signal.aborted) {
          return;
        }
        return (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({
          result,
          jsonrpc: "2.0",
          id: request.id
        });
      }, (error) => {
        var _a2, _b2;
        if (abortController.signal.aborted) {
          return;
        }
        return (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({
          jsonrpc: "2.0",
          id: request.id,
          error: {
            code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
            message: (_b2 = error.message) !== null && _b2 !== void 0 ? _b2 : "Internal error"
          }
        });
      }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
        this._requestHandlerAbortControllers.delete(request.id);
      });
    }
    _onprogress(notification) {
      const { progressToken, ...params } = notification.params;
      const messageId = Number(progressToken);
      const handler = this._progressHandlers.get(messageId);
      if (!handler) {
        this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
        return;
      }
      const responseHandler = this._responseHandlers.get(messageId);
      const timeoutInfo = this._timeoutInfo.get(messageId);
      if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
        try {
          this._resetTimeout(messageId);
        } catch (error) {
          responseHandler(error);
          return;
        }
      }
      handler(params);
    }
    _onresponse(response) {
      const messageId = Number(response.id);
      const handler = this._responseHandlers.get(messageId);
      if (handler === void 0) {
        this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
        return;
      }
      this._responseHandlers.delete(messageId);
      this._progressHandlers.delete(messageId);
      this._cleanupTimeout(messageId);
      if (isJSONRPCResponse(response)) {
        handler(response);
      } else {
        const error = new McpError(response.error.code, response.error.message, response.error.data);
        handler(error);
      }
    }
    get transport() {
      return this._transport;
    }
    /**
     * Closes the connection.
     */
    async close() {
      var _a;
      await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.close());
    }
    /**
     * Sends a request and wait for a response.
     *
     * Do not use this method to emit notifications! Use notification() instead.
     */
    request(request, resultSchema, options) {
      const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
      return new Promise((resolve, reject) => {
        var _a, _b, _c, _d, _e, _f;
        if (!this._transport) {
          reject(new Error("Not connected"));
          return;
        }
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) {
          this.assertCapabilityForMethod(request.method);
        }
        (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();
        const messageId = this._requestMessageId++;
        const jsonrpcRequest = {
          ...request,
          jsonrpc: "2.0",
          id: messageId
        };
        if (options === null || options === void 0 ? void 0 : options.onprogress) {
          this._progressHandlers.set(messageId, options.onprogress);
          jsonrpcRequest.params = {
            ...request.params,
            _meta: {
              ...((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {},
              progressToken: messageId
            }
          };
        }
        const cancel = (reason) => {
          var _a2;
          this._responseHandlers.delete(messageId);
          this._progressHandlers.delete(messageId);
          this._cleanupTimeout(messageId);
          (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({
            jsonrpc: "2.0",
            method: "notifications/cancelled",
            params: {
              requestId: messageId,
              reason: String(reason)
            }
          }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => this._onerror(new Error(`Failed to send cancellation: ${error}`)));
          reject(reason);
        };
        this._responseHandlers.set(messageId, (response) => {
          var _a2;
          if ((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
            return;
          }
          if (response instanceof Error) {
            return reject(response);
          }
          try {
            const result = resultSchema.parse(response.result);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        });
        (_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 ? void 0 : _d.addEventListener("abort", () => {
          var _a2;
          cancel((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.reason);
        });
        const timeout = (_e = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e !== void 0 ? _e : DEFAULT_REQUEST_TIMEOUT_MSEC;
        const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
        this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      });
    }
    /**
     * Emits a notification, which is a one-way message that does not expect a response.
     */
    async notification(notification, options) {
      if (!this._transport) {
        throw new Error("Not connected");
      }
      this.assertNotificationCapability(notification.method);
      const jsonrpcNotification = {
        ...notification,
        jsonrpc: "2.0"
      };
      await this._transport.send(jsonrpcNotification, options);
    }
    /**
     * Registers a handler to invoke when this protocol object receives a request with the given method.
     *
     * Note that this will replace any previous request handler for the same method.
     */
    setRequestHandler(requestSchema, handler) {
      const method = requestSchema.shape.method.value;
      this.assertRequestHandlerCapability(method);
      this._requestHandlers.set(method, (request, extra) => {
        return Promise.resolve(handler(requestSchema.parse(request), extra));
      });
    }
    /**
     * Removes the request handler for the given method.
     */
    removeRequestHandler(method) {
      this._requestHandlers.delete(method);
    }
    /**
     * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
     */
    assertCanSetRequestHandler(method) {
      if (this._requestHandlers.has(method)) {
        throw new Error(`A request handler for ${method} already exists, which would be overridden`);
      }
    }
    /**
     * Registers a handler to invoke when this protocol object receives a notification with the given method.
     *
     * Note that this will replace any previous notification handler for the same method.
     */
    setNotificationHandler(notificationSchema, handler) {
      this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));
    }
    /**
     * Removes the notification handler for the given method.
     */
    removeNotificationHandler(method) {
      this._notificationHandlers.delete(method);
    }
  };
  function mergeCapabilities(base, additional) {
    return Object.entries(additional).reduce((acc, [key, value]) => {
      if (value && typeof value === "object") {
        acc[key] = acc[key] ? { ...acc[key], ...value } : value;
      } else {
        acc[key] = value;
      }
      return acc;
    }, { ...base });
  }

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
  var import_ajv = __toESM(require_ajv(), 1);
  var Client = class extends Protocol {
    /**
     * Initializes this client with the given name and version information.
     */
    constructor(_clientInfo, options) {
      var _a;
      super(options);
      this._clientInfo = _clientInfo;
      this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
      this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
      this._ajv = new import_ajv.default();
    }
    /**
     * Registers new capabilities. This can only be called before connecting to a transport.
     *
     * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
     */
    registerCapabilities(capabilities) {
      if (this.transport) {
        throw new Error("Cannot register capabilities after connecting to transport");
      }
      this._capabilities = mergeCapabilities(this._capabilities, capabilities);
    }
    assertCapability(capability, method) {
      var _a;
      if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a[capability])) {
        throw new Error(`Server does not support ${capability} (required for ${method})`);
      }
    }
    async connect(transport, options) {
      await super.connect(transport);
      if (transport.sessionId !== void 0) {
        return;
      }
      try {
        const result = await this.request({
          method: "initialize",
          params: {
            protocolVersion: LATEST_PROTOCOL_VERSION,
            capabilities: this._capabilities,
            clientInfo: this._clientInfo
          }
        }, InitializeResultSchema, options);
        if (result === void 0) {
          throw new Error(`Server sent invalid initialize result: ${result}`);
        }
        if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
          throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
        }
        this._serverCapabilities = result.capabilities;
        this._serverVersion = result.serverInfo;
        if (transport.setProtocolVersion) {
          transport.setProtocolVersion(result.protocolVersion);
        }
        this._instructions = result.instructions;
        await this.notification({
          method: "notifications/initialized"
        });
      } catch (error) {
        void this.close();
        throw error;
      }
    }
    /**
     * After initialization has completed, this will be populated with the server's reported capabilities.
     */
    getServerCapabilities() {
      return this._serverCapabilities;
    }
    /**
     * After initialization has completed, this will be populated with information about the server's name and version.
     */
    getServerVersion() {
      return this._serverVersion;
    }
    /**
     * After initialization has completed, this may be populated with information about the server's instructions.
     */
    getInstructions() {
      return this._instructions;
    }
    assertCapabilityForMethod(method) {
      var _a, _b, _c, _d, _e;
      switch (method) {
        case "logging/setLevel":
          if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a.logging)) {
            throw new Error(`Server does not support logging (required for ${method})`);
          }
          break;
        case "prompts/get":
        case "prompts/list":
          if (!((_b = this._serverCapabilities) === null || _b === void 0 ? void 0 : _b.prompts)) {
            throw new Error(`Server does not support prompts (required for ${method})`);
          }
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
        case "resources/subscribe":
        case "resources/unsubscribe":
          if (!((_c = this._serverCapabilities) === null || _c === void 0 ? void 0 : _c.resources)) {
            throw new Error(`Server does not support resources (required for ${method})`);
          }
          if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
            throw new Error(`Server does not support resource subscriptions (required for ${method})`);
          }
          break;
        case "tools/call":
        case "tools/list":
          if (!((_d = this._serverCapabilities) === null || _d === void 0 ? void 0 : _d.tools)) {
            throw new Error(`Server does not support tools (required for ${method})`);
          }
          break;
        case "completion/complete":
          if (!((_e = this._serverCapabilities) === null || _e === void 0 ? void 0 : _e.completions)) {
            throw new Error(`Server does not support completions (required for ${method})`);
          }
          break;
        case "initialize":
          break;
        case "ping":
          break;
      }
    }
    assertNotificationCapability(method) {
      var _a;
      switch (method) {
        case "notifications/roots/list_changed":
          if (!((_a = this._capabilities.roots) === null || _a === void 0 ? void 0 : _a.listChanged)) {
            throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
          }
          break;
        case "notifications/initialized":
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break;
      }
    }
    assertRequestHandlerCapability(method) {
      switch (method) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling) {
            throw new Error(`Client does not support sampling capability (required for ${method})`);
          }
          break;
        case "elicitation/create":
          if (!this._capabilities.elicitation) {
            throw new Error(`Client does not support elicitation capability (required for ${method})`);
          }
          break;
        case "roots/list":
          if (!this._capabilities.roots) {
            throw new Error(`Client does not support roots capability (required for ${method})`);
          }
          break;
        case "ping":
          break;
      }
    }
    async ping(options) {
      return this.request({ method: "ping" }, EmptyResultSchema, options);
    }
    async complete(params, options) {
      return this.request({ method: "completion/complete", params }, CompleteResultSchema, options);
    }
    async setLoggingLevel(level, options) {
      return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options);
    }
    async getPrompt(params, options) {
      return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options);
    }
    async listPrompts(params, options) {
      return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options);
    }
    async listResources(params, options) {
      return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options);
    }
    async listResourceTemplates(params, options) {
      return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options);
    }
    async readResource(params, options) {
      return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options);
    }
    async subscribeResource(params, options) {
      return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options);
    }
    async unsubscribeResource(params, options) {
      return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options);
    }
    async callTool(params, resultSchema = CallToolResultSchema, options) {
      const result = await this.request({ method: "tools/call", params }, resultSchema, options);
      const validator = this.getToolOutputValidator(params.name);
      if (validator) {
        if (!result.structuredContent && !result.isError) {
          throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
        }
        if (result.structuredContent) {
          try {
            const isValid2 = validator(result.structuredContent);
            if (!isValid2) {
              throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${this._ajv.errorsText(validator.errors)}`);
            }
          } catch (error) {
            if (error instanceof McpError) {
              throw error;
            }
            throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
      }
      return result;
    }
    cacheToolOutputSchemas(tools) {
      this._cachedToolOutputValidators.clear();
      for (const tool of tools) {
        if (tool.outputSchema) {
          try {
            const validator = this._ajv.compile(tool.outputSchema);
            this._cachedToolOutputValidators.set(tool.name, validator);
          } catch (_a) {
          }
        }
      }
    }
    getToolOutputValidator(toolName) {
      return this._cachedToolOutputValidators.get(toolName);
    }
    async listTools(params, options) {
      const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema, options);
      this.cacheToolOutputSchemas(result.tools);
      return result;
    }
    async sendRootsListChanged() {
      return this.notification({ method: "notifications/roots/list_changed" });
    }
  };

  // ../../packages/mcphappey-mcp/dist/createClient.js
  async function createMcpClient(baseUrl, headers) {
    return new Client({
      name: "web-client",
      version: "1.0.0",
      headers: headers ?? {}
    });
  }
  function closeMcpClient(client) {
    client.close?.();
  }

  // ../../packages/mcphappey-mcp/dist/clientPool.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/pkce-challenge/dist/index.browser.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var crypto2;
  crypto2 = globalThis.crypto;
  async function getRandomValues(size) {
    return (await crypto2).getRandomValues(new Uint8Array(size));
  }
  async function random(size) {
    const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
    let result = "";
    const randomUints = await getRandomValues(size);
    for (let i = 0; i < size; i++) {
      const randomIndex = randomUints[i] % mask.length;
      result += mask[randomIndex];
    }
    return result;
  }
  async function generateVerifier(length) {
    return await random(length);
  }
  async function generateChallenge(code_verifier) {
    const buffer = await (await crypto2).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
    return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
  }
  async function pkceChallenge(length) {
    if (!length)
      length = 43;
    if (length < 43 || length > 128) {
      throw `Expected a length between 43 and 128. Received ${length}.`;
    }
    const verifier = await generateVerifier(length);
    const challenge = await generateChallenge(verifier);
    return {
      code_verifier: verifier,
      code_challenge: challenge
    };
  }

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var OAuthProtectedResourceMetadataSchema = v3_exports.object({
    resource: v3_exports.string().url(),
    authorization_servers: v3_exports.array(v3_exports.string().url()).optional(),
    jwks_uri: v3_exports.string().url().optional(),
    scopes_supported: v3_exports.array(v3_exports.string()).optional(),
    bearer_methods_supported: v3_exports.array(v3_exports.string()).optional(),
    resource_signing_alg_values_supported: v3_exports.array(v3_exports.string()).optional(),
    resource_name: v3_exports.string().optional(),
    resource_documentation: v3_exports.string().optional(),
    resource_policy_uri: v3_exports.string().url().optional(),
    resource_tos_uri: v3_exports.string().url().optional(),
    tls_client_certificate_bound_access_tokens: v3_exports.boolean().optional(),
    authorization_details_types_supported: v3_exports.array(v3_exports.string()).optional(),
    dpop_signing_alg_values_supported: v3_exports.array(v3_exports.string()).optional(),
    dpop_bound_access_tokens_required: v3_exports.boolean().optional()
  }).passthrough();
  var OAuthMetadataSchema = v3_exports.object({
    issuer: v3_exports.string(),
    authorization_endpoint: v3_exports.string(),
    token_endpoint: v3_exports.string(),
    registration_endpoint: v3_exports.string().optional(),
    scopes_supported: v3_exports.array(v3_exports.string()).optional(),
    response_types_supported: v3_exports.array(v3_exports.string()),
    response_modes_supported: v3_exports.array(v3_exports.string()).optional(),
    grant_types_supported: v3_exports.array(v3_exports.string()).optional(),
    token_endpoint_auth_methods_supported: v3_exports.array(v3_exports.string()).optional(),
    token_endpoint_auth_signing_alg_values_supported: v3_exports.array(v3_exports.string()).optional(),
    service_documentation: v3_exports.string().optional(),
    revocation_endpoint: v3_exports.string().optional(),
    revocation_endpoint_auth_methods_supported: v3_exports.array(v3_exports.string()).optional(),
    revocation_endpoint_auth_signing_alg_values_supported: v3_exports.array(v3_exports.string()).optional(),
    introspection_endpoint: v3_exports.string().optional(),
    introspection_endpoint_auth_methods_supported: v3_exports.array(v3_exports.string()).optional(),
    introspection_endpoint_auth_signing_alg_values_supported: v3_exports.array(v3_exports.string()).optional(),
    code_challenge_methods_supported: v3_exports.array(v3_exports.string()).optional()
  }).passthrough();
  var OAuthTokensSchema = v3_exports.object({
    access_token: v3_exports.string(),
    token_type: v3_exports.string(),
    expires_in: v3_exports.number().optional(),
    scope: v3_exports.string().optional(),
    refresh_token: v3_exports.string().optional()
  }).strip();
  var OAuthErrorResponseSchema = v3_exports.object({
    error: v3_exports.string(),
    error_description: v3_exports.string().optional(),
    error_uri: v3_exports.string().optional()
  });
  var OAuthClientMetadataSchema = v3_exports.object({
    redirect_uris: v3_exports.array(v3_exports.string()).refine((uris) => uris.every((uri) => URL.canParse(uri)), { message: "redirect_uris must contain valid URLs" }),
    token_endpoint_auth_method: v3_exports.string().optional(),
    grant_types: v3_exports.array(v3_exports.string()).optional(),
    response_types: v3_exports.array(v3_exports.string()).optional(),
    client_name: v3_exports.string().optional(),
    client_uri: v3_exports.string().optional(),
    logo_uri: v3_exports.string().optional(),
    scope: v3_exports.string().optional(),
    contacts: v3_exports.array(v3_exports.string()).optional(),
    tos_uri: v3_exports.string().optional(),
    policy_uri: v3_exports.string().optional(),
    jwks_uri: v3_exports.string().optional(),
    jwks: v3_exports.any().optional(),
    software_id: v3_exports.string().optional(),
    software_version: v3_exports.string().optional(),
    software_statement: v3_exports.string().optional()
  }).strip();
  var OAuthClientInformationSchema = v3_exports.object({
    client_id: v3_exports.string(),
    client_secret: v3_exports.string().optional(),
    client_id_issued_at: v3_exports.number().optional(),
    client_secret_expires_at: v3_exports.number().optional()
  }).strip();
  var OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);
  var OAuthClientRegistrationErrorSchema = v3_exports.object({
    error: v3_exports.string(),
    error_description: v3_exports.string().optional()
  }).strip();
  var OAuthTokenRevocationRequestSchema = v3_exports.object({
    token: v3_exports.string(),
    token_type_hint: v3_exports.string().optional()
  }).strip();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth-utils.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function resourceUrlFromServerUrl(url) {
    const resourceURL = typeof url === "string" ? new URL(url) : new URL(url.href);
    resourceURL.hash = "";
    return resourceURL;
  }
  function checkResourceAllowed({ requestedResource, configuredResource }) {
    const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
    const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
    if (requested.origin !== configured.origin) {
      return false;
    }
    if (requested.pathname.length < configured.pathname.length) {
      return false;
    }
    const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
    const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
    return requestedPath.startsWith(configuredPath);
  }

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
  var UnauthorizedError = class extends Error {
    constructor(message) {
      super(message !== null && message !== void 0 ? message : "Unauthorized");
    }
  };
  async function auth(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl }) {
    let resourceMetadata;
    let authorizationServerUrl = serverUrl;
    try {
      resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl });
      if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {
        authorizationServerUrl = resourceMetadata.authorization_servers[0];
      }
    } catch (_a) {
    }
    const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
    const metadata = await discoverOAuthMetadata(authorizationServerUrl);
    let clientInformation = await Promise.resolve(provider.clientInformation());
    if (!clientInformation) {
      if (authorizationCode !== void 0) {
        throw new Error("Existing OAuth client information is required when exchanging an authorization code");
      }
      if (!provider.saveClientInformation) {
        throw new Error("OAuth client information must be saveable for dynamic registration");
      }
      const fullInformation = await registerClient(authorizationServerUrl, {
        metadata,
        clientMetadata: provider.clientMetadata
      });
      await provider.saveClientInformation(fullInformation);
      clientInformation = fullInformation;
    }
    if (authorizationCode !== void 0) {
      const codeVerifier2 = await provider.codeVerifier();
      const tokens3 = await exchangeAuthorization(authorizationServerUrl, {
        metadata,
        clientInformation,
        authorizationCode,
        codeVerifier: codeVerifier2,
        redirectUri: provider.redirectUrl,
        resource
      });
      await provider.saveTokens(tokens3);
      return "AUTHORIZED";
    }
    const tokens2 = await provider.tokens();
    if (tokens2 === null || tokens2 === void 0 ? void 0 : tokens2.refresh_token) {
      try {
        const newTokens = await refreshAuthorization(authorizationServerUrl, {
          metadata,
          clientInformation,
          refreshToken: tokens2.refresh_token,
          resource
        });
        await provider.saveTokens(newTokens);
        return "AUTHORIZED";
      } catch (_b) {
      }
    }
    const state = provider.state ? await provider.state() : void 0;
    const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
      metadata,
      clientInformation,
      state,
      redirectUrl: provider.redirectUrl,
      scope: scope || provider.clientMetadata.scope,
      resource
    });
    await provider.saveCodeVerifier(codeVerifier);
    await provider.redirectToAuthorization(authorizationUrl);
    return "REDIRECT";
  }
  async function selectResourceURL(serverUrl, provider, resourceMetadata) {
    const defaultResource = resourceUrlFromServerUrl(serverUrl);
    if (provider.validateResourceURL) {
      return await provider.validateResourceURL(defaultResource, resourceMetadata === null || resourceMetadata === void 0 ? void 0 : resourceMetadata.resource);
    }
    if (!resourceMetadata) {
      return void 0;
    }
    if (!checkResourceAllowed({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {
      throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
    }
    return new URL(resourceMetadata.resource);
  }
  function extractResourceMetadataUrl(res) {
    const authenticateHeader = res.headers.get("WWW-Authenticate");
    if (!authenticateHeader) {
      return void 0;
    }
    const [type, scheme] = authenticateHeader.split(" ");
    if (type.toLowerCase() !== "bearer" || !scheme) {
      return void 0;
    }
    const regex = /resource_metadata="([^"]*)"/;
    const match = regex.exec(authenticateHeader);
    if (!match) {
      return void 0;
    }
    try {
      return new URL(match[1]);
    } catch (_a) {
      return void 0;
    }
  }
  async function discoverOAuthProtectedResourceMetadata(serverUrl, opts) {
    var _a;
    let url;
    if (opts === null || opts === void 0 ? void 0 : opts.resourceMetadataUrl) {
      url = new URL(opts === null || opts === void 0 ? void 0 : opts.resourceMetadataUrl);
    } else {
      url = new URL("/.well-known/oauth-protected-resource", serverUrl);
    }
    let response;
    try {
      response = await fetch(url, {
        headers: {
          "MCP-Protocol-Version": (_a = opts === null || opts === void 0 ? void 0 : opts.protocolVersion) !== null && _a !== void 0 ? _a : LATEST_PROTOCOL_VERSION
        }
      });
    } catch (error) {
      if (error instanceof TypeError) {
        response = await fetch(url);
      } else {
        throw error;
      }
    }
    if (response.status === 404) {
      throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
    }
    if (!response.ok) {
      throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
    }
    return OAuthProtectedResourceMetadataSchema.parse(await response.json());
  }
  async function fetchWithCorsRetry(url, headers) {
    try {
      return await fetch(url, { headers });
    } catch (error) {
      if (error instanceof TypeError) {
        if (headers) {
          return fetchWithCorsRetry(url);
        } else {
          return void 0;
        }
      }
      throw error;
    }
  }
  function buildWellKnownPath(pathname) {
    let wellKnownPath = `/.well-known/oauth-authorization-server${pathname}`;
    if (pathname.endsWith("/")) {
      wellKnownPath = wellKnownPath.slice(0, -1);
    }
    return wellKnownPath;
  }
  async function tryMetadataDiscovery(url, protocolVersion) {
    const headers = {
      "MCP-Protocol-Version": protocolVersion
    };
    return await fetchWithCorsRetry(url, headers);
  }
  function shouldAttemptFallback(response, pathname) {
    return !response || response.status === 404 && pathname !== "/";
  }
  async function discoverOAuthMetadata(authorizationServerUrl, opts) {
    var _a;
    const issuer = new URL(authorizationServerUrl);
    const protocolVersion = (_a = opts === null || opts === void 0 ? void 0 : opts.protocolVersion) !== null && _a !== void 0 ? _a : LATEST_PROTOCOL_VERSION;
    const wellKnownPath = buildWellKnownPath(issuer.pathname);
    const pathAwareUrl = new URL(wellKnownPath, issuer);
    let response = await tryMetadataDiscovery(pathAwareUrl, protocolVersion);
    if (shouldAttemptFallback(response, issuer.pathname)) {
      const rootUrl = new URL("/.well-known/oauth-authorization-server", issuer);
      response = await tryMetadataDiscovery(rootUrl, protocolVersion);
    }
    if (!response || response.status === 404) {
      return void 0;
    }
    if (!response.ok) {
      throw new Error(`HTTP ${response.status} trying to load well-known OAuth metadata`);
    }
    return OAuthMetadataSchema.parse(await response.json());
  }
  async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {
    const responseType = "code";
    const codeChallengeMethod = "S256";
    let authorizationUrl;
    if (metadata) {
      authorizationUrl = new URL(metadata.authorization_endpoint);
      if (!metadata.response_types_supported.includes(responseType)) {
        throw new Error(`Incompatible auth server: does not support response type ${responseType}`);
      }
      if (!metadata.code_challenge_methods_supported || !metadata.code_challenge_methods_supported.includes(codeChallengeMethod)) {
        throw new Error(`Incompatible auth server: does not support code challenge method ${codeChallengeMethod}`);
      }
    } else {
      authorizationUrl = new URL("/authorize", authorizationServerUrl);
    }
    const challenge = await pkceChallenge();
    const codeVerifier = challenge.code_verifier;
    const codeChallenge = challenge.code_challenge;
    authorizationUrl.searchParams.set("response_type", responseType);
    authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
    authorizationUrl.searchParams.set("code_challenge", codeChallenge);
    authorizationUrl.searchParams.set("code_challenge_method", codeChallengeMethod);
    authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
    if (state) {
      authorizationUrl.searchParams.set("state", state);
    }
    if (scope) {
      authorizationUrl.searchParams.set("scope", scope);
    }
    if (resource) {
      authorizationUrl.searchParams.set("resource", resource.href);
    }
    return { authorizationUrl, codeVerifier };
  }
  async function exchangeAuthorization(authorizationServerUrl, { metadata, clientInformation, authorizationCode, codeVerifier, redirectUri, resource }) {
    const grantType = "authorization_code";
    let tokenUrl;
    if (metadata) {
      tokenUrl = new URL(metadata.token_endpoint);
      if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) {
        throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
      }
    } else {
      tokenUrl = new URL("/token", authorizationServerUrl);
    }
    const params = new URLSearchParams({
      grant_type: grantType,
      client_id: clientInformation.client_id,
      code: authorizationCode,
      code_verifier: codeVerifier,
      redirect_uri: String(redirectUri)
    });
    if (clientInformation.client_secret) {
      params.set("client_secret", clientInformation.client_secret);
    }
    if (resource) {
      params.set("resource", resource.href);
    }
    const response = await fetch(tokenUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: params
    });
    if (!response.ok) {
      throw new Error(`Token exchange failed: HTTP ${response.status}`);
    }
    return OAuthTokensSchema.parse(await response.json());
  }
  async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource }) {
    const grantType = "refresh_token";
    let tokenUrl;
    if (metadata) {
      tokenUrl = new URL(metadata.token_endpoint);
      if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) {
        throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
      }
    } else {
      tokenUrl = new URL("/token", authorizationServerUrl);
    }
    const params = new URLSearchParams({
      grant_type: grantType,
      client_id: clientInformation.client_id,
      refresh_token: refreshToken
    });
    if (clientInformation.client_secret) {
      params.set("client_secret", clientInformation.client_secret);
    }
    if (resource) {
      params.set("resource", resource.href);
    }
    const response = await fetch(tokenUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: params
    });
    if (!response.ok) {
      throw new Error(`Token refresh failed: HTTP ${response.status}`);
    }
    return OAuthTokensSchema.parse({ refresh_token: refreshToken, ...await response.json() });
  }
  async function registerClient(authorizationServerUrl, { metadata, clientMetadata }) {
    let registrationUrl;
    if (metadata) {
      if (!metadata.registration_endpoint) {
        throw new Error("Incompatible auth server: does not support dynamic client registration");
      }
      registrationUrl = new URL(metadata.registration_endpoint);
    } else {
      registrationUrl = new URL("/register", authorizationServerUrl);
    }
    const response = await fetch(registrationUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(clientMetadata)
    });
    if (!response.ok) {
      throw new Error(`Dynamic client registration failed: HTTP ${response.status}`);
    }
    return OAuthClientInformationFullSchema.parse(await response.json());
  }

  // ../../node_modules/eventsource-parser/dist/stream.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/eventsource-parser/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var ParseError = class extends Error {
    constructor(message, options) {
      super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
  };
  function noop(_arg) {
  }
  function createParser(callbacks) {
    if (typeof callbacks == "function")
      throw new TypeError(
        "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
      );
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = true, id, data2 = "", eventType = "";
    function feed(newChunk) {
      const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
      for (const line of complete)
        parseLine(line);
      incompleteLine = incomplete, isFirstChunk = false;
    }
    function parseLine(line) {
      if (line === "") {
        dispatchEvent();
        return;
      }
      if (line.startsWith(":")) {
        onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
        return;
      }
      const fieldSeparatorIndex = line.indexOf(":");
      if (fieldSeparatorIndex !== -1) {
        const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
        processField(field, value, line);
        return;
      }
      processField(line, "", line);
    }
    function processField(field, value, line) {
      switch (field) {
        case "event":
          eventType = value;
          break;
        case "data":
          data2 = `${data2}${value}
`;
          break;
        case "id":
          id = value.includes("\0") ? void 0 : value;
          break;
        case "retry":
          /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
            new ParseError(`Invalid \`retry\` value: "${value}"`, {
              type: "invalid-retry",
              value,
              line
            })
          );
          break;
        default:
          onError(
            new ParseError(
              `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
              { type: "unknown-field", field, value, line }
            )
          );
          break;
      }
    }
    function dispatchEvent() {
      data2.length > 0 && onEvent({
        id,
        event: eventType || void 0,
        // If the data buffer's last character is a U+000A LINE FEED (LF) character,
        // then remove the last character from the data buffer.
        data: data2.endsWith(`
`) ? data2.slice(0, -1) : data2
      }), id = void 0, data2 = "", eventType = "";
    }
    function reset(options = {}) {
      incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data2 = "", eventType = "", incompleteLine = "";
    }
    return { feed, reset };
  }
  function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for (; searchIndex < chunk.length; ) {
      const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
      let lineEnd = -1;
      if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
        incompleteLine = chunk.slice(searchIndex);
        break;
      } else {
        const line = chunk.slice(searchIndex, lineEnd);
        lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
      }
    }
    return [lines, incompleteLine];
  }

  // ../../node_modules/eventsource-parser/dist/stream.js
  var EventSourceParserStream = class extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}) {
      let parser;
      super({
        start(controller) {
          parser = createParser({
            onEvent: (event) => {
              controller.enqueue(event);
            },
            onError(error) {
              onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
            },
            onRetry,
            onComment
          });
        },
        transform(chunk) {
          parser.feed(chunk);
        }
      });
    }
  };

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js
  var DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {
    initialReconnectionDelay: 1e3,
    maxReconnectionDelay: 3e4,
    reconnectionDelayGrowFactor: 1.5,
    maxRetries: 2
  };
  var StreamableHTTPError = class extends Error {
    constructor(code, message) {
      super(`Streamable HTTP error: ${message}`);
      this.code = code;
    }
  };
  var StreamableHTTPClientTransport = class {
    constructor(url, opts) {
      var _a;
      this._url = url;
      this._resourceMetadataUrl = void 0;
      this._requestInit = opts === null || opts === void 0 ? void 0 : opts.requestInit;
      this._authProvider = opts === null || opts === void 0 ? void 0 : opts.authProvider;
      this._sessionId = opts === null || opts === void 0 ? void 0 : opts.sessionId;
      this._reconnectionOptions = (_a = opts === null || opts === void 0 ? void 0 : opts.reconnectionOptions) !== null && _a !== void 0 ? _a : DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;
    }
    async _authThenStart() {
      var _a;
      if (!this._authProvider) {
        throw new UnauthorizedError("No auth provider");
      }
      let result;
      try {
        result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl });
      } catch (error) {
        (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
        throw error;
      }
      if (result !== "AUTHORIZED") {
        throw new UnauthorizedError();
      }
      return await this._startOrAuthSse({ resumptionToken: void 0 });
    }
    async _commonHeaders() {
      var _a;
      const headers = {};
      if (this._authProvider) {
        const tokens2 = await this._authProvider.tokens();
        if (tokens2) {
          headers["Authorization"] = `Bearer ${tokens2.access_token}`;
        }
      }
      if (this._sessionId) {
        headers["mcp-session-id"] = this._sessionId;
      }
      if (this._protocolVersion) {
        headers["mcp-protocol-version"] = this._protocolVersion;
      }
      const extraHeaders = this._normalizeHeaders((_a = this._requestInit) === null || _a === void 0 ? void 0 : _a.headers);
      return new Headers({
        ...headers,
        ...extraHeaders
      });
    }
    async _startOrAuthSse(options) {
      var _a, _b;
      const { resumptionToken } = options;
      try {
        const headers = await this._commonHeaders();
        headers.set("Accept", "text/event-stream");
        if (resumptionToken) {
          headers.set("last-event-id", resumptionToken);
        }
        const response = await fetch(this._url, {
          method: "GET",
          headers,
          signal: (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.signal
        });
        if (!response.ok) {
          if (response.status === 401 && this._authProvider) {
            return await this._authThenStart();
          }
          if (response.status === 405) {
            return;
          }
          throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);
        }
        this._handleSseStream(response.body, options);
      } catch (error) {
        (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
        throw error;
      }
    }
    /**
     * Calculates the next reconnection delay using  backoff algorithm
     *
     * @param attempt Current reconnection attempt count for the specific stream
     * @returns Time to wait in milliseconds before next reconnection attempt
     */
    _getNextReconnectionDelay(attempt) {
      const initialDelay = this._reconnectionOptions.initialReconnectionDelay;
      const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;
      const maxDelay = this._reconnectionOptions.maxReconnectionDelay;
      return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);
    }
    _normalizeHeaders(headers) {
      if (!headers)
        return {};
      if (headers instanceof Headers) {
        return Object.fromEntries(headers.entries());
      }
      if (Array.isArray(headers)) {
        return Object.fromEntries(headers);
      }
      return { ...headers };
    }
    /**
     * Schedule a reconnection attempt with exponential backoff
     *
     * @param lastEventId The ID of the last received event for resumability
     * @param attemptCount Current reconnection attempt count for this specific stream
     */
    _scheduleReconnection(options, attemptCount = 0) {
      var _a;
      const maxRetries = this._reconnectionOptions.maxRetries;
      if (maxRetries > 0 && attemptCount >= maxRetries) {
        (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));
        return;
      }
      const delay = this._getNextReconnectionDelay(attemptCount);
      setTimeout(() => {
        this._startOrAuthSse(options).catch((error) => {
          var _a2;
          (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, new Error(`Failed to reconnect SSE stream: ${error instanceof Error ? error.message : String(error)}`));
          this._scheduleReconnection(options, attemptCount + 1);
        });
      }, delay);
    }
    _handleSseStream(stream, options) {
      if (!stream) {
        return;
      }
      const { onresumptiontoken, replayMessageId } = options;
      let lastEventId;
      const processStream = async () => {
        var _a, _b, _c, _d;
        try {
          const reader = stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).getReader();
          while (true) {
            const { value: event, done } = await reader.read();
            if (done) {
              break;
            }
            if (event.id) {
              lastEventId = event.id;
              onresumptiontoken === null || onresumptiontoken === void 0 ? void 0 : onresumptiontoken(event.id);
            }
            if (!event.event || event.event === "message") {
              try {
                const message = JSONRPCMessageSchema.parse(JSON.parse(event.data));
                if (replayMessageId !== void 0 && isJSONRPCResponse(message)) {
                  message.id = replayMessageId;
                }
                (_a = this.onmessage) === null || _a === void 0 ? void 0 : _a.call(this, message);
              } catch (error) {
                (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
              }
            }
          }
        } catch (error) {
          (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, new Error(`SSE stream disconnected: ${error}`));
          if (this._abortController && !this._abortController.signal.aborted) {
            if (lastEventId !== void 0) {
              try {
                this._scheduleReconnection({
                  resumptionToken: lastEventId,
                  onresumptiontoken,
                  replayMessageId
                }, 0);
              } catch (error2) {
                (_d = this.onerror) === null || _d === void 0 ? void 0 : _d.call(this, new Error(`Failed to reconnect: ${error2 instanceof Error ? error2.message : String(error2)}`));
              }
            }
          }
        }
      };
      processStream();
    }
    async start() {
      if (this._abortController) {
        throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");
      }
      this._abortController = new AbortController();
    }
    /**
     * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
     */
    async finishAuth(authorizationCode) {
      if (!this._authProvider) {
        throw new UnauthorizedError("No auth provider");
      }
      const result = await auth(this._authProvider, { serverUrl: this._url, authorizationCode, resourceMetadataUrl: this._resourceMetadataUrl });
      if (result !== "AUTHORIZED") {
        throw new UnauthorizedError("Failed to authorize");
      }
    }
    async close() {
      var _a, _b;
      (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.abort();
      (_b = this.onclose) === null || _b === void 0 ? void 0 : _b.call(this);
    }
    async send(message, options) {
      var _a, _b, _c;
      try {
        const { resumptionToken, onresumptiontoken } = options || {};
        if (resumptionToken) {
          this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : void 0 }).catch((err) => {
            var _a2;
            return (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, err);
          });
          return;
        }
        const headers = await this._commonHeaders();
        headers.set("content-type", "application/json");
        headers.set("accept", "application/json, text/event-stream");
        const init = {
          ...this._requestInit,
          method: "POST",
          headers,
          body: JSON.stringify(message),
          signal: (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.signal
        };
        const response = await fetch(this._url, init);
        const sessionId = response.headers.get("mcp-session-id");
        if (sessionId) {
          this._sessionId = sessionId;
        }
        if (!response.ok) {
          if (response.status === 401 && this._authProvider) {
            this._resourceMetadataUrl = extractResourceMetadataUrl(response);
            const result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl });
            if (result !== "AUTHORIZED") {
              throw new UnauthorizedError();
            }
            return this.send(message);
          }
          const text = await response.text().catch(() => null);
          throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text}`);
        }
        if (response.status === 202) {
          if (isInitializedNotification(message)) {
            this._startOrAuthSse({ resumptionToken: void 0 }).catch((err) => {
              var _a2;
              return (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, err);
            });
          }
          return;
        }
        const messages = Array.isArray(message) ? message : [message];
        const hasRequests = messages.filter((msg) => "method" in msg && "id" in msg && msg.id !== void 0).length > 0;
        const contentType = response.headers.get("content-type");
        if (hasRequests) {
          if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("text/event-stream")) {
            this._handleSseStream(response.body, { onresumptiontoken });
          } else if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
            const data2 = await response.json();
            const responseMessages = Array.isArray(data2) ? data2.map((msg) => JSONRPCMessageSchema.parse(msg)) : [JSONRPCMessageSchema.parse(data2)];
            for (const msg of responseMessages) {
              (_b = this.onmessage) === null || _b === void 0 ? void 0 : _b.call(this, msg);
            }
          } else {
            throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);
          }
        }
      } catch (error) {
        (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, error);
        throw error;
      }
    }
    get sessionId() {
      return this._sessionId;
    }
    /**
     * Terminates the current session by sending a DELETE request to the server.
     *
     * Clients that no longer need a particular session
     * (e.g., because the user is leaving the client application) SHOULD send an
     * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly
     * terminate the session.
     *
     * The server MAY respond with HTTP 405 Method Not Allowed, indicating that
     * the server does not allow clients to terminate sessions.
     */
    async terminateSession() {
      var _a, _b;
      if (!this._sessionId) {
        return;
      }
      try {
        const headers = await this._commonHeaders();
        const init = {
          ...this._requestInit,
          method: "DELETE",
          headers,
          signal: (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.signal
        };
        const response = await fetch(this._url, init);
        if (!response.ok && response.status !== 405) {
          throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);
        }
        this._sessionId = void 0;
      } catch (error) {
        (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
        throw error;
      }
    }
    setProtocolVersion(version2) {
      this._protocolVersion = version2;
    }
    get protocolVersion() {
      return this._protocolVersion;
    }
  };

  // ../../packages/mcphappey-mcp/dist/clientPool.js
  var MCPClientPool = class {
    clients = /* @__PURE__ */ new Map();
    /** Connect (or return cached client) */
    async connect(url, headers) {
      if (this.clients.has(url))
        return this.clients.get(url);
      const opts = {
        requestInit: {
          headers
        }
      };
      const transport = new StreamableHTTPClientTransport(new URL(url), opts);
      const client = await createMcpClient(url, headers);
      await client.connect(transport);
      this.clients.set(url, client);
      return client;
    }
    /**
     * Get a client by URL.
     */
    get(url) {
      return this.clients.get(url);
    }
    /**
     * Disconnect and remove a client.
     */
    disconnect(url) {
      const client = this.clients.get(url);
      if (client) {
        closeMcpClient(client);
        this.clients.delete(url);
      }
    }
    /**
     * List all connected URLs.
     */
    list() {
      return Array.from(this.clients.keys());
    }
  };

  // ../../packages/mcphappey-mcp/dist/react/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-mcp/dist/react/McpClientContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var import_react3 = __toESM(require_react());
  var McpClientContext = (0, import_react3.createContext)(void 0);

  // ../../packages/mcphappey-mcp/dist/react/useMcpClient.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_react4 = __toESM(require_react());

  // ../../packages/mcphappey-state/dist/mcpStore.js
  var pool = new MCPClientPool();
  var useMcpStore = create((set, get) => ({
    clients: {},
    addClient: (url, client) => set((state) => ({ clients: { ...state.clients, [url]: client } })),
    connect: async (url) => {
      if (get().clients[url])
        return;
      const client = await pool.connect(url);
      set((state) => ({
        clients: { ...state.clients, [url]: client }
      }));
    },
    disconnect: (url) => {
      const client = get().clients[url];
      if (client) {
        pool.disconnect(url);
        set((state) => {
          const { [url]: _, ...rest } = state.clients;
          return { clients: rest };
        });
      }
    },
    isConnected: (url) => !!get().clients[url]
  }));

  // ../../packages/mcphappey-core/dist/components/ServerList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime17 = __toESM(require_jsx_runtime());
  var import_react17 = __toESM(require_react());

  // ../../packages/mcphappey-core/dist/components/ServerCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());

  // ../../packages/mcphappey-core/dist/hooks/useMcpConnect.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_react7 = __toESM(require_react());

  // ../../packages/mcphappey-core/dist/context/McpPoolContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var import_react5 = __toESM(require_react());
  var McpPoolContext = (0, import_react5.createContext)(null);
  var McpPoolProvider = ({ children }) => {
    const pool2 = (0, import_react5.useMemo)(() => new MCPClientPool(), []);
    return (0, import_jsx_runtime2.jsx)(McpPoolContext.Provider, { value: pool2, children });
  };
  var useMcpPool = () => {
    const ctx = (0, import_react5.useContext)(McpPoolContext);
    if (!ctx)
      throw new Error("useMcpPool must be used inside McpPoolProvider");
    return ctx;
  };

  // ../../packages/mcphappey-auth/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-auth/dist/oauthFlow.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-auth/dist/pkce.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var generateRandomString = (length) => {
    const array = new Uint32Array(Math.ceil(length / 2));
    crypto.getRandomValues(array);
    return Array.from(array, (dec) => ("0" + dec.toString(16)).slice(-2)).join("").slice(0, length);
  };
  var generateCodeChallenge = async (codeVerifier) => {
    const encoder = new TextEncoder();
    const data2 = encoder.encode(codeVerifier);
    const digest = await crypto.subtle.digest("SHA-256", data2);
    const binaryString = String.fromCharCode(...new Uint8Array(digest));
    return btoa(binaryString).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  };
  var createPkceChallenge = async () => {
    const codeVerifier = generateRandomString(128);
    const codeChallenge = await generateCodeChallenge(codeVerifier);
    return { code_verifier: codeVerifier, code_challenge: codeChallenge };
  };

  // ../../packages/mcphappey-auth/dist/storage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var ACCESS_TOKEN_STORAGE_PREFIX = "mcp_access_token_";
  var saveAccessToken = (serverUrl, token) => {
    try {
      localStorage.setItem(`${ACCESS_TOKEN_STORAGE_PREFIX}${serverUrl}`, token);
    } catch (e) {
    }
  };
  var getAccessToken = (serverUrl) => {
    try {
      return localStorage.getItem(`${ACCESS_TOKEN_STORAGE_PREFIX}${serverUrl}`);
    } catch (e) {
      return null;
    }
  };

  // ../../packages/mcphappey-auth/dist/oauthFlow.js
  var OAUTH_TARGET_URL_KEY = "mcp_oauth_target_url";
  var OAUTH_FLOW_DETAILS_KEY = "mcp_oauth_flow_details";
  var OAUTH_CODE_VERIFIER_KEY = "mcp_oauth_code_verifier";
  var OAUTH_STATE_KEY = "mcp_oauth_state";
  var initiateOAuthFlow = async (mcpServerUrl) => {
    sessionStorage.setItem(OAUTH_TARGET_URL_KEY, mcpServerUrl);
    const parsedMcpUrl = new URL(mcpServerUrl);
    const mcpOrigin = parsedMcpUrl.origin;
    let mcpPath = parsedMcpUrl.pathname;
    if (mcpPath.startsWith("/"))
      mcpPath = mcpPath.substring(1);
    const fullPathForWellKnown = mcpPath && mcpPath !== "/" ? `/${mcpPath}` : "";
    const protectedResourceUrl = `${mcpOrigin}/.well-known/oauth-protected-resource${fullPathForWellKnown}`;
    const prResponse = await fetch(protectedResourceUrl);
    if (!prResponse.ok)
      throw new Error(`Failed to fetch protected resource metadata (${prResponse.status}) from ${protectedResourceUrl}`);
    const prMetadata = await prResponse.json();
    if (!prMetadata.authorization_servers || prMetadata.authorization_servers.length === 0)
      throw new Error("No authorization_servers found in protected resource metadata.");
    const authServerMetadataUrl = prMetadata.authorization_servers[0];
    const asResponse = await fetch(authServerMetadataUrl);
    if (!asResponse.ok)
      throw new Error(`Failed to fetch authorization server metadata (${asResponse.status}) from ${authServerMetadataUrl}`);
    const asMetadata = await asResponse.json();
    if (!asMetadata.authorization_endpoint || !asMetadata.token_endpoint || !asMetadata.registration_endpoint)
      throw new Error("Incomplete authorization server metadata (missing endpoint(s)).");
    const redirectUri = `${window.location.origin}/oauth-callback`;
    const clientRegPayload = {
      client_name: "MCP Happey Web Client",
      redirect_uris: [redirectUri],
      grant_types: ["authorization_code"],
      response_types: ["code"],
      token_endpoint_auth_method: "none",
      scope: prMetadata.scopes_supported ? prMetadata.scopes_supported.join(" ") : void 0
    };
    const regResponse = await fetch(asMetadata.registration_endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(clientRegPayload)
    });
    if (!regResponse.ok) {
      const errorBody = await regResponse.text();
      throw new Error(`Dynamic client registration failed (${regResponse.status}): ${errorBody}`);
    }
    const clientInfo = await regResponse.json();
    const clientId = clientInfo.client_id;
    const flowDetails = {
      clientId,
      tokenEndpoint: asMetadata.token_endpoint,
      redirectUri,
      authServerMetadataUrl
    };
    sessionStorage.setItem(OAUTH_FLOW_DETAILS_KEY, JSON.stringify(flowDetails));
    const { code_verifier, code_challenge } = await createPkceChallenge();
    const state = crypto.randomUUID();
    sessionStorage.setItem(OAUTH_CODE_VERIFIER_KEY, code_verifier);
    sessionStorage.setItem(OAUTH_STATE_KEY, state);
    const authUrl = new URL(asMetadata.authorization_endpoint);
    authUrl.searchParams.set("client_id", clientId);
    authUrl.searchParams.set("response_type", "code");
    authUrl.searchParams.set("redirect_uri", redirectUri);
    authUrl.searchParams.set("code_challenge", code_challenge);
    authUrl.searchParams.set("code_challenge_method", "S256");
    authUrl.searchParams.set("state", state);
    if (clientRegPayload.scope)
      authUrl.searchParams.set("scope", clientRegPayload.scope);
    window.location.assign(authUrl.toString());
  };
  var handleOAuthCallback = async () => {
    const params = new URLSearchParams(window.location.search);
    const code = params.get("code");
    const receivedState = params.get("state");
    const error = params.get("error");
    const errorDescription = params.get("error_description");
    const storedState = sessionStorage.getItem(OAUTH_STATE_KEY);
    const codeVerifier = sessionStorage.getItem(OAUTH_CODE_VERIFIER_KEY);
    const flowDetailsRaw = sessionStorage.getItem(OAUTH_FLOW_DETAILS_KEY);
    const targetUrl = sessionStorage.getItem(OAUTH_TARGET_URL_KEY) || void 0;
    sessionStorage.removeItem(OAUTH_STATE_KEY);
    sessionStorage.removeItem(OAUTH_CODE_VERIFIER_KEY);
    sessionStorage.removeItem(OAUTH_FLOW_DETAILS_KEY);
    if (error) {
      return { error, errorDescription: errorDescription || "Unknown OAuth error occurred." };
    }
    if (!code) {
      return { error: "missing_code", errorDescription: "Authorization code is missing from callback." };
    }
    if (!storedState) {
      return { error: "missing_stored_state", errorDescription: "Stored OAuth state is missing. Cannot verify callback." };
    }
    if (receivedState !== storedState) {
      return { error: "state_mismatch", errorDescription: "OAuth state mismatch. Possible CSRF attack." };
    }
    if (!codeVerifier) {
      return { error: "missing_verifier", errorDescription: "PKCE code verifier is missing from storage." };
    }
    if (!flowDetailsRaw) {
      return { error: "missing_flow_details", errorDescription: "OAuth flow details are missing from storage." };
    }
    try {
      const flowDetails = JSON.parse(flowDetailsRaw);
      const tokenPayload = new URLSearchParams();
      tokenPayload.set("grant_type", "authorization_code");
      tokenPayload.set("client_id", flowDetails.clientId);
      tokenPayload.set("code", code);
      tokenPayload.set("redirect_uri", flowDetails.redirectUri);
      tokenPayload.set("code_verifier", codeVerifier);
      const tokenResponse = await fetch(flowDetails.tokenEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: tokenPayload.toString()
      });
      if (!tokenResponse.ok) {
        const errorBody = await tokenResponse.json().catch(() => ({
          error: "token_exchange_failed",
          error_description: "Failed to parse error from token endpoint."
        }));
        return {
          error: errorBody.error || "token_exchange_failed",
          errorDescription: errorBody.error_description || `Token exchange failed with status ${tokenResponse.status}`
        };
      }
      const tokens2 = await tokenResponse.json();
      if (!tokens2.access_token) {
        return { error: "missing_access_token", errorDescription: "Access token not found in token response." };
      }
      return { accessToken: tokens2.access_token, targetUrl };
    } catch (err) {
      return {
        error: "callback_processing_error",
        errorDescription: err instanceof Error ? err.message : "An unexpected error occurred during callback processing."
      };
    }
  };

  // ../../packages/mcphappey-auth/dist/OAuthCallbackPage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  var import_react6 = __toESM(require_react());
  var OAUTH_TARGET_URL_KEY2 = "mcp_oauth_target_url";
  var OAuthCallbackPage = () => {
    const [status, setStatus] = (0, import_react6.useState)("pending");
    const [message, setMessage] = (0, import_react6.useState)("Processing authentication callback...");
    const navigate = useNavigate();
    (0, import_react6.useEffect)(() => {
      const processCallback = async () => {
        const result = await handleOAuthCallback();
        if ("error" in result) {
          setStatus("error");
          setMessage(`OAuth Error: ${result.error} - ${result.errorDescription || "Please try again."}`);
          sessionStorage.removeItem(OAUTH_TARGET_URL_KEY2);
          return;
        }
        if (result.accessToken && result.targetUrl) {
          saveAccessToken(result.targetUrl, result.accessToken);
          setStatus("success");
          setMessage("Authentication successful! Redirecting...");
          sessionStorage.removeItem(OAUTH_TARGET_URL_KEY2);
          setTimeout(async () => {
            await navigate("/");
          }, 1500);
        } else {
          setStatus("error");
          setMessage("OAuth Error: Could not retrieve access token or target URL after callback.");
          if (sessionStorage.getItem(OAUTH_TARGET_URL_KEY2)) {
            sessionStorage.removeItem(OAUTH_TARGET_URL_KEY2);
          }
        }
      };
      processCallback();
    }, [navigate]);
    return (0, import_jsx_runtime3.jsxs)("div", { style: { padding: 20, textAlign: "center", fontFamily: "sans-serif" }, children: [(0, import_jsx_runtime3.jsx)("h2", { children: "OAuth Authentication Callback" }), (0, import_jsx_runtime3.jsx)("p", { children: message }), status === "pending" && (0, import_jsx_runtime3.jsx)("p", { children: "Please wait..." }), status === "success" && (0, import_jsx_runtime3.jsxs)("p", { children: ["If you are not redirected automatically, please", " ", (0, import_jsx_runtime3.jsx)("a", { href: "/", children: "click here to return to the application" }), "."] }), status === "error" && (0, import_jsx_runtime3.jsxs)("p", { children: ["Please ", (0, import_jsx_runtime3.jsx)("a", { href: "/", children: "return to the application" }), " and try again."] })] });
  };
  var OAuthCallbackPage_default = OAuthCallbackPage;

  // ../../packages/mcphappey-core/dist/hooks/useMcpConnect.js
  var useMcpConnect = () => {
    const pool2 = useMcpPool();
    const { addClient } = useMcpStore();
    const connect = (0, import_react7.useCallback)(async (url) => {
      const token = getAccessToken(url);
      try {
        const client = await pool2.connect(url, token ? { Authorization: `Bearer ${token}` } : void 0);
        addClient(url, client);
        return client;
      } catch (err) {
        if (err == `Error: Error POSTing to endpoint (HTTP 401): Invalid or missing token`) {
          await initiateOAuthFlow(url);
        }
        throw err;
      }
    }, [pool2, addClient]);
    return { connect, pool: pool2 };
  };

  // ../../packages/mcphappey-core/dist/components/ServerCard.js
  var ServerCard = ({ server, onShowDetails }) => {
    const { Button: Button3, Card: Card3 } = useTheme();
    const { connect } = useMcpConnect();
    const { disconnect, isConnected } = useMcpStore();
    const connected = isConnected(server.url);
    return (0, import_jsx_runtime4.jsx)(Card3, { title: server.name, text: server.url, actions: (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [(0, import_jsx_runtime4.jsx)(Button3, { onClick: () => connected ? disconnect(server.url) : connect(server.url), variant: connected ? "success" : "primary", size: "sm", disabled: false, children: connected ? "Disconnect" : "Connect" }), connected && (0, import_jsx_runtime4.jsx)(Button3, { onClick: () => onShowDetails(server), variant: "secondary", size: "sm", children: "Details" })] }) });
  };
  var ServerCard_default = ServerCard;

  // ../../packages/mcphappey-core/dist/components/ServerModal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime16 = __toESM(require_jsx_runtime());
  var import_react16 = __toESM(require_react());

  // ../../packages/mcphappey-core/dist/hooks/useServerPrimitives.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_react8 = __toESM(require_react());

  // ../../packages/mcphappey-state/src/slices/servers.ts
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var useServerPrimitivesStore = create((set, get) => ({
    servers: {},
    async loadCapabilities(url, client) {
      set((s) => ({
        servers: {
          ...s.servers,
          [url]: { ...s.servers[url] || { loading: false }, loading: true, error: void 0 }
        }
      }));
      try {
        const capabilities = await client.getServerCapabilities();
        set((s) => ({
          servers: {
            ...s.servers,
            [url]: { ...s.servers[url] || { loading: false }, capabilities, loading: false }
          }
        }));
      } catch (e) {
        set((s) => ({
          servers: {
            ...s.servers,
            [url]: { ...s.servers[url] || { loading: false }, loading: false, error: e.message }
          }
        }));
      }
    },
    async loadPrompts(url, client) {
      set((s) => ({
        servers: {
          ...s.servers,
          [url]: { ...s.servers[url] || { loading: false }, loading: true, error: void 0 }
        }
      }));
      try {
        const { prompts } = await client.listPrompts();
        set((s) => ({
          servers: {
            ...s.servers,
            [url]: { ...s.servers[url] || { loading: false }, prompts, loading: false }
          }
        }));
      } catch (e) {
        set((s) => ({
          servers: {
            ...s.servers,
            [url]: { ...s.servers[url] || { loading: false }, loading: false, error: e.message }
          }
        }));
      }
    },
    async loadResources(url, client) {
      set((s) => ({
        servers: {
          ...s.servers,
          [url]: { ...s.servers[url] || { loading: false }, loading: true, error: void 0 }
        }
      }));
      try {
        const { resources } = await client.listResources();
        set((s) => ({
          servers: {
            ...s.servers,
            [url]: { ...s.servers[url] || { loading: false }, resources, loading: false }
          }
        }));
      } catch (e) {
        set((s) => ({
          servers: {
            ...s.servers,
            [url]: { ...s.servers[url] || { loading: false }, loading: false, error: e.message }
          }
        }));
      }
    },
    async loadTools(url, client) {
      set((s) => ({
        servers: {
          ...s.servers,
          [url]: { ...s.servers[url] || { loading: false }, loading: true, error: void 0 }
        }
      }));
      try {
        const { tools } = await client.listTools();
        set((s) => ({
          servers: {
            ...s.servers,
            [url]: { ...s.servers[url] || { loading: false }, tools, loading: false }
          }
        }));
      } catch (e) {
        set((s) => ({
          servers: {
            ...s.servers,
            [url]: { ...s.servers[url] || { loading: false }, loading: false, error: e.message }
          }
        }));
      }
    }
  }));

  // ../../packages/mcphappey-core/dist/hooks/useServerPrimitives.js
  function useServerPrimitives(serverUrl) {
    const { connect } = useMcpConnect();
    const state = useServerPrimitivesStore((s) => serverUrl ? s.servers[serverUrl] || { loading: false } : { loading: false });
    const { loadCapabilities, loadPrompts, loadResources, loadTools } = useServerPrimitivesStore();
    const loadAll = (0, import_react8.useCallback)(async () => {
      if (!serverUrl)
        return;
      const client = await connect(serverUrl);
      await loadCapabilities(serverUrl, client);
      const cap = useServerPrimitivesStore.getState().servers[serverUrl]?.capabilities;
      if (cap?.prompts)
        await loadPrompts(serverUrl, client);
      if (cap?.resources)
        await loadResources(serverUrl, client);
      if (cap?.tools)
        await loadTools(serverUrl, client);
    }, [serverUrl, connect, loadCapabilities, loadPrompts, loadResources, loadTools]);
    return {
      ...state,
      loadCapabilities: (0, import_react8.useCallback)(async () => {
        if (!serverUrl)
          return;
        const client = await connect(serverUrl);
        await loadCapabilities(serverUrl, client);
      }, [serverUrl, connect, loadCapabilities]),
      loadPrompts: (0, import_react8.useCallback)(async () => {
        if (!serverUrl)
          return;
        const client = await connect(serverUrl);
        await loadPrompts(serverUrl, client);
      }, [serverUrl, connect, loadPrompts]),
      loadResources: (0, import_react8.useCallback)(async () => {
        if (!serverUrl)
          return;
        const client = await connect(serverUrl);
        await loadResources(serverUrl, client);
      }, [serverUrl, connect, loadResources]),
      loadTools: (0, import_react8.useCallback)(async () => {
        if (!serverUrl)
          return;
        const client = await connect(serverUrl);
        await loadTools(serverUrl, client);
      }, [serverUrl, connect, loadTools]),
      loadAll
    };
  }

  // ../../packages/mcphappey-core/dist/components/ServerSummary.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());

  // ../../packages/mcphappey-core/dist/components/PrettyJson.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var PrettyJson = ({ data: data2 }) => (0, import_jsx_runtime5.jsx)("pre", { className: "mcph-pretty-json", style: { fontSize: 12, background: "#f8f9fa", padding: 8, borderRadius: 4, overflowX: "auto" }, children: JSON.stringify(data2, null, 2) });
  var PrettyJson_default = PrettyJson;

  // ../../packages/mcphappey-core/dist/components/ServerSummary.js
  var ServerSummary = ({ server, loading, promptCount, resourceCount, toolCount, error, capabilities }) => {
    const { Table: Table3, Badge: Badge3, Spinner: Spinner3, Alert: Alert3 } = useTheme();
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Table3, { borderless: true, size: "sm", children: (0, import_jsx_runtime6.jsxs)("tbody", { children: [(0, import_jsx_runtime6.jsxs)("tr", { children: [(0, import_jsx_runtime6.jsx)("th", { children: "Type" }), (0, import_jsx_runtime6.jsx)("td", { children: server.type })] }), (0, import_jsx_runtime6.jsxs)("tr", { children: [(0, import_jsx_runtime6.jsx)("th", { children: "URL" }), (0, import_jsx_runtime6.jsx)("td", { style: { wordBreak: "break-all" }, children: server.url })] }), server.headers && (0, import_jsx_runtime6.jsxs)("tr", { children: [(0, import_jsx_runtime6.jsx)("th", { children: "Headers" }), (0, import_jsx_runtime6.jsx)("td", { children: (0, import_jsx_runtime6.jsx)(PrettyJson_default, { data: server.headers }) })] }), Object.entries(server).filter(([key]) => !["name", "type", "url", "headers"].includes(key)).map(([key, value]) => (0, import_jsx_runtime6.jsxs)("tr", { children: [(0, import_jsx_runtime6.jsx)("th", { children: key }), (0, import_jsx_runtime6.jsx)("td", { children: typeof value === "object" ? (0, import_jsx_runtime6.jsx)(PrettyJson_default, { data: value }) : String(value) })] }, key))] }) }), (0, import_jsx_runtime6.jsx)("hr", {}), (0, import_jsx_runtime6.jsx)("h6", { children: "Capabilities" }), loading ? (0, import_jsx_runtime6.jsx)(Spinner3, { size: "sm" }) : error ? (0, import_jsx_runtime6.jsx)(Alert3, { variant: "danger", children: error }) : capabilities ? (0, import_jsx_runtime6.jsxs)("div", { style: { display: "flex", gap: 12 }, children: [capabilities.prompts && (0, import_jsx_runtime6.jsxs)(Badge3, { bg: "primary", children: [promptCount, " prompt(s)"] }), capabilities.resources && (0, import_jsx_runtime6.jsxs)(Badge3, { bg: "success", children: [resourceCount, " resource(s)"] }), capabilities.tools && (0, import_jsx_runtime6.jsxs)(Badge3, { bg: "warning", children: [toolCount, " tool(s)"] }), !capabilities.prompts && !capabilities.resources && !capabilities.tools && (0, import_jsx_runtime6.jsx)("span", { children: "No primitives supported" })] }) : (0, import_jsx_runtime6.jsx)("span", { children: "\u2014" })] });
  };
  var ServerSummary_default = ServerSummary;

  // ../../packages/mcphappey-core/dist/components/PromptsTab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());

  // ../../packages/mcphappey-core/dist/components/PromptCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var PromptCard = ({ prompt, onOpen }) => {
    const { Card: Card3, Button: Button3 } = useTheme();
    return (0, import_jsx_runtime7.jsx)(Card3, { title: prompt.name, text: prompt.description ?? "", actions: (0, import_jsx_runtime7.jsx)(Button3, { variant: "primary", size: "sm", onClick: () => onOpen(prompt), children: "Open" }) });
  };
  var PromptCard_default = PromptCard;

  // ../../packages/mcphappey-core/dist/components/PromptModal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var import_react10 = __toESM(require_react());

  // ../../node_modules/react-json-view-lite/dist/index.modern.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_react9 = __toESM(require_react());
  var isBoolean = (data2) => {
    return typeof data2 === "boolean" || data2 instanceof Boolean;
  };
  var isNumber = (data2) => {
    return typeof data2 === "number" || data2 instanceof Number;
  };
  var isBigInt = (data2) => {
    return typeof data2 === "bigint" || data2 instanceof BigInt;
  };
  var isDate = (data2) => {
    return !!data2 && data2 instanceof Date;
  };
  var isString = (data2) => {
    return typeof data2 === "string" || data2 instanceof String;
  };
  var isArray = (data2) => {
    return Array.isArray(data2);
  };
  var isObject = (data2) => {
    return typeof data2 === "object" && data2 !== null;
  };
  var isFunction = (data2) => {
    return !!data2 && data2 instanceof Object && typeof data2 === "function";
  };
  function quoteString(value, quoted) {
    if (quoted === void 0) {
      quoted = false;
    }
    return !value || quoted ? `"${value}"` : value;
  }
  function quoteStringValue(value, quoted, stringify) {
    if (stringify) {
      return JSON.stringify(value);
    }
    return quoted ? `"${value}"` : value;
  }
  function ExpandableObject(_ref) {
    let {
      field,
      value,
      data: data2,
      lastElement,
      openBracket,
      closeBracket,
      level,
      style,
      shouldExpandNode,
      clickToExpandNode,
      outerRef,
      beforeExpandChange
    } = _ref;
    const shouldExpandNodeCalledRef = (0, import_react9.useRef)(false);
    const [expanded, setExpanded] = (0, import_react9.useState)(() => shouldExpandNode(level, value, field));
    const expanderButtonRef = (0, import_react9.useRef)(null);
    (0, import_react9.useEffect)(() => {
      if (!shouldExpandNodeCalledRef.current) {
        shouldExpandNodeCalledRef.current = true;
      } else {
        setExpanded(shouldExpandNode(level, value, field));
      }
    }, [shouldExpandNode]);
    const contentsId = (0, import_react9.useId)();
    if (data2.length === 0) {
      return EmptyObject({
        field,
        openBracket,
        closeBracket,
        lastElement,
        style
      });
    }
    const expanderIconStyle = expanded ? style.collapseIcon : style.expandIcon;
    const ariaLabel = expanded ? style.ariaLables.collapseJson : style.ariaLables.expandJson;
    const childLevel = level + 1;
    const lastIndex2 = data2.length - 1;
    const setExpandWithCallback = (newExpandValue) => {
      if (expanded !== newExpandValue && (!beforeExpandChange || beforeExpandChange({
        level,
        value,
        field,
        newExpandValue
      }))) {
        setExpanded(newExpandValue);
      }
    };
    const onKeyDown = (e) => {
      if (e.key === "ArrowRight" || e.key === "ArrowLeft") {
        e.preventDefault();
        setExpandWithCallback(e.key === "ArrowRight");
      } else if (e.key === "ArrowUp" || e.key === "ArrowDown") {
        e.preventDefault();
        const direction = e.key === "ArrowUp" ? -1 : 1;
        if (!outerRef.current) return;
        const buttonElements = outerRef.current.querySelectorAll("[role=button]");
        let currentIndex = -1;
        for (let i = 0; i < buttonElements.length; i++) {
          if (buttonElements[i].tabIndex === 0) {
            currentIndex = i;
            break;
          }
        }
        if (currentIndex < 0) {
          return;
        }
        const nextIndex = (currentIndex + direction + buttonElements.length) % buttonElements.length;
        buttonElements[currentIndex].tabIndex = -1;
        buttonElements[nextIndex].tabIndex = 0;
        buttonElements[nextIndex].focus();
      }
    };
    const onClick = () => {
      var _outerRef$current;
      setExpandWithCallback(!expanded);
      const buttonElement = expanderButtonRef.current;
      if (!buttonElement) return;
      const prevButtonElement = (_outerRef$current = outerRef.current) === null || _outerRef$current === void 0 ? void 0 : _outerRef$current.querySelector('[role=button][tabindex="0"]');
      if (prevButtonElement) {
        prevButtonElement.tabIndex = -1;
      }
      buttonElement.tabIndex = 0;
      buttonElement.focus();
    };
    return /* @__PURE__ */ (0, import_react9.createElement)("div", {
      className: style.basicChildStyle,
      role: "treeitem",
      "aria-expanded": expanded,
      "aria-selected": void 0
    }, /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: expanderIconStyle,
      onClick,
      onKeyDown,
      role: "button",
      "aria-label": ariaLabel,
      "aria-expanded": expanded,
      "aria-controls": expanded ? contentsId : void 0,
      ref: expanderButtonRef,
      tabIndex: level === 0 ? 0 : -1
    }), (field || field === "") && (clickToExpandNode ? /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.clickableLabel,
      onClick,
      onKeyDown
    }, quoteString(field, style.quotesForFieldNames), ":") : /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.label
    }, quoteString(field, style.quotesForFieldNames), ":")), /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.punctuation
    }, openBracket), expanded ? /* @__PURE__ */ (0, import_react9.createElement)("ul", {
      id: contentsId,
      role: "group",
      className: style.childFieldsContainer
    }, data2.map((dataElement, index) => /* @__PURE__ */ (0, import_react9.createElement)(DataRender, {
      key: dataElement[0] || index,
      field: dataElement[0],
      value: dataElement[1],
      style,
      lastElement: index === lastIndex2,
      level: childLevel,
      shouldExpandNode,
      clickToExpandNode,
      outerRef
    }))) : /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.collapsedContent,
      onClick,
      onKeyDown
    }), /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.punctuation
    }, closeBracket), !lastElement && /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.punctuation
    }, ","));
  }
  function EmptyObject(_ref2) {
    let {
      field,
      openBracket,
      closeBracket,
      lastElement,
      style
    } = _ref2;
    return /* @__PURE__ */ (0, import_react9.createElement)("div", {
      className: style.basicChildStyle,
      role: "treeitem",
      "aria-selected": void 0
    }, (field || field === "") && /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.label
    }, quoteString(field, style.quotesForFieldNames), ":"), /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.punctuation
    }, openBracket), /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.punctuation
    }, closeBracket), !lastElement && /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.punctuation
    }, ","));
  }
  function JsonObject(_ref3) {
    let {
      field,
      value,
      style,
      lastElement,
      shouldExpandNode,
      clickToExpandNode,
      level,
      outerRef,
      beforeExpandChange
    } = _ref3;
    return ExpandableObject({
      field,
      value,
      lastElement: lastElement || false,
      level,
      openBracket: "{",
      closeBracket: "}",
      style,
      shouldExpandNode,
      clickToExpandNode,
      data: Object.keys(value).map((key) => [key, value[key]]),
      outerRef,
      beforeExpandChange
    });
  }
  function JsonArray(_ref4) {
    let {
      field,
      value,
      style,
      lastElement,
      level,
      shouldExpandNode,
      clickToExpandNode,
      outerRef,
      beforeExpandChange
    } = _ref4;
    return ExpandableObject({
      field,
      value,
      lastElement: lastElement || false,
      level,
      openBracket: "[",
      closeBracket: "]",
      style,
      shouldExpandNode,
      clickToExpandNode,
      data: value.map((element) => [void 0, element]),
      outerRef,
      beforeExpandChange
    });
  }
  function JsonPrimitiveValue(_ref5) {
    let {
      field,
      value,
      style,
      lastElement
    } = _ref5;
    let stringValue;
    let valueStyle = style.otherValue;
    if (value === null) {
      stringValue = "null";
      valueStyle = style.nullValue;
    } else if (value === void 0) {
      stringValue = "undefined";
      valueStyle = style.undefinedValue;
    } else if (isString(value)) {
      stringValue = quoteStringValue(value, !style.noQuotesForStringValues, style.stringifyStringValues);
      valueStyle = style.stringValue;
    } else if (isBoolean(value)) {
      stringValue = value ? "true" : "false";
      valueStyle = style.booleanValue;
    } else if (isNumber(value)) {
      stringValue = value.toString();
      valueStyle = style.numberValue;
    } else if (isBigInt(value)) {
      stringValue = `${value.toString()}n`;
      valueStyle = style.numberValue;
    } else if (isDate(value)) {
      stringValue = value.toISOString();
    } else if (isFunction(value)) {
      stringValue = "function() { }";
    } else {
      stringValue = value.toString();
    }
    return /* @__PURE__ */ (0, import_react9.createElement)("div", {
      className: style.basicChildStyle,
      role: "treeitem",
      "aria-selected": void 0
    }, (field || field === "") && /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.label
    }, quoteString(field, style.quotesForFieldNames), ":"), /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: valueStyle
    }, stringValue), !lastElement && /* @__PURE__ */ (0, import_react9.createElement)("span", {
      className: style.punctuation
    }, ","));
  }
  function DataRender(props) {
    const value = props.value;
    if (isArray(value)) {
      return /* @__PURE__ */ (0, import_react9.createElement)(JsonArray, Object.assign({}, props));
    }
    if (isObject(value) && !isDate(value) && !isFunction(value)) {
      return /* @__PURE__ */ (0, import_react9.createElement)(JsonObject, Object.assign({}, props));
    }
    return /* @__PURE__ */ (0, import_react9.createElement)(JsonPrimitiveValue, Object.assign({}, props));
  }
  var styles = { "container-base": "_GzYRV", "punctuation-base": "_3eOF8", "pointer": "_1MFti", "expander-base": "_f10Tu _1MFti", "expand-icon": "_1UmXx", "collapse-icon": "_1LId0", "collapsed-content-base": "_1pNG9 _1MFti", "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
  var defaultAriaLables = {
    collapseJson: "collapse JSON",
    expandJson: "expand JSON"
  };
  var defaultStyles = {
    container: styles["container-light"],
    basicChildStyle: styles["basic-element-style"],
    childFieldsContainer: styles["child-fields-container"],
    label: styles["label-light"],
    clickableLabel: styles["clickable-label-light"],
    nullValue: styles["value-null-light"],
    undefinedValue: styles["value-undefined-light"],
    stringValue: styles["value-string-light"],
    booleanValue: styles["value-boolean-light"],
    numberValue: styles["value-number-light"],
    otherValue: styles["value-other-light"],
    punctuation: styles["punctuation-light"],
    collapseIcon: styles["collapse-icon-light"],
    expandIcon: styles["expand-icon-light"],
    collapsedContent: styles["collapsed-content-light"],
    noQuotesForStringValues: false,
    quotesForFieldNames: false,
    ariaLables: defaultAriaLables,
    stringifyStringValues: false
  };
  var darkStyles = {
    container: styles["container-dark"],
    basicChildStyle: styles["basic-element-style"],
    childFieldsContainer: styles["child-fields-container"],
    label: styles["label-dark"],
    clickableLabel: styles["clickable-label-dark"],
    nullValue: styles["value-null-dark"],
    undefinedValue: styles["value-undefined-dark"],
    stringValue: styles["value-string-dark"],
    booleanValue: styles["value-boolean-dark"],
    numberValue: styles["value-number-dark"],
    otherValue: styles["value-other-dark"],
    punctuation: styles["punctuation-dark"],
    collapseIcon: styles["collapse-icon-dark"],
    expandIcon: styles["expand-icon-dark"],
    collapsedContent: styles["collapsed-content-dark"],
    noQuotesForStringValues: false,
    quotesForFieldNames: false,
    ariaLables: defaultAriaLables,
    stringifyStringValues: false
  };
  var allExpanded = () => true;
  var JsonView = (_ref) => {
    let {
      data: data2,
      style = defaultStyles,
      shouldExpandNode = allExpanded,
      clickToExpandNode = false,
      beforeExpandChange,
      ...ariaAttrs
    } = _ref;
    const outerRef = (0, import_react9.useRef)(null);
    return /* @__PURE__ */ (0, import_react9.createElement)("div", Object.assign({
      "aria-label": "JSON view"
    }, ariaAttrs, {
      className: style.container,
      ref: outerRef,
      role: "tree"
    }), /* @__PURE__ */ (0, import_react9.createElement)(DataRender, {
      value: data2,
      style: {
        ...defaultStyles,
        ...style
      },
      lastElement: true,
      level: 0,
      shouldExpandNode,
      clickToExpandNode,
      outerRef,
      beforeExpandChange
    }));
  };

  // ../../packages/mcphappey-core/dist/components/PromptModal.js
  var PromptModal = ({ show, prompt, onClose, onSubmit, result }) => {
    const { Modal: Modal2, Input: Input3, Button: Button3, Badge: Badge3 } = useTheme();
    const [formValues, setFormValues] = (0, import_react10.useState)({});
    const [touched, setTouched] = (0, import_react10.useState)({});
    const [view, setView] = (0, import_react10.useState)("form");
    (0, import_react10.useEffect)(() => {
      if (prompt?.arguments) {
        const initial = {};
        prompt.arguments.forEach((a) => {
          initial[a.name] = "";
        });
        setFormValues(initial);
        setTouched({});
      }
      setView("form");
    }, [prompt, show]);
    (0, import_react10.useEffect)(() => {
      if (result !== void 0 && result !== null) {
        setView("result");
      }
    }, [result]);
    if (!prompt)
      return null;
    const handleChange = (name, value) => {
      setFormValues((v) => ({ ...v, [name]: value }));
      setTouched((t) => ({ ...t, [name]: true }));
    };
    const requiredArgs = (prompt.arguments || []).filter((a) => a.required);
    const isValid2 = requiredArgs.length === 0 || requiredArgs.every((a) => !!formValues[a.name]?.trim());
    const handleSubmit = (e) => {
      e.preventDefault();
      if (isValid2) {
        onSubmit(formValues);
      }
    };
    const allExpanded2 = () => true;
    return (0, import_jsx_runtime8.jsx)(Modal2, { show, onHide: onClose, size: "lg", title: prompt.name, children: (0, import_jsx_runtime8.jsxs)("div", { children: [(0, import_jsx_runtime8.jsx)("div", { style: { marginBottom: 12, color: "#666" }, children: prompt.description }), view === "form" ? (0, import_jsx_runtime8.jsxs)("form", { onSubmit: handleSubmit, children: [prompt.arguments && prompt.arguments.length > 0 ? (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: 16 }, children: prompt.arguments.map((arg) => (0, import_jsx_runtime8.jsxs)("div", { children: [(0, import_jsx_runtime8.jsxs)("label", { style: { fontWeight: 500 }, children: [arg.name, arg.required && (0, import_jsx_runtime8.jsx)("span", { style: { marginLeft: 6 }, children: (0, import_jsx_runtime8.jsx)(Badge3, { bg: "danger", children: "required" }) })] }), (0, import_jsx_runtime8.jsx)("div", { style: { color: "#666", fontSize: 13, marginBottom: 2 }, children: arg.description }), (0, import_jsx_runtime8.jsx)(Input3, { type: "text", required: arg.required, value: formValues[arg.name] || "", onChange: (e) => handleChange(arg.name, e?.target?.value !== void 0 ? e.target.value : e), placeholder: arg.description || arg.name, style: {
      borderColor: touched[arg.name] && arg.required && !formValues[arg.name] ? "#dc3545" : void 0
    } })] }, arg.name)) }) : (0, import_jsx_runtime8.jsx)("div", { style: { color: "#888", marginBottom: 16 }, children: "No arguments required for this prompt." }), (0, import_jsx_runtime8.jsxs)("div", { style: { marginTop: 24, display: "flex", gap: 8 }, children: [(0, import_jsx_runtime8.jsx)(Button3, { variant: "primary", type: "submit", disabled: !isValid2, children: "Get prompt" }), (0, import_jsx_runtime8.jsx)(Button3, { variant: "secondary", onClick: onClose, type: "button", children: "Close" })] })] }) : (0, import_jsx_runtime8.jsxs)("div", { children: [(0, import_jsx_runtime8.jsx)("div", { style: { marginTop: 8 }, children: (0, import_jsx_runtime8.jsx)(JsonView, { data: result, shouldExpandNode: allExpanded2, style: defaultStyles }) }), (0, import_jsx_runtime8.jsxs)("div", { style: { marginTop: 24, display: "flex", gap: 8 }, children: [(0, import_jsx_runtime8.jsx)(Button3, { variant: "secondary", onClick: () => setView("form"), children: "Back" }), (0, import_jsx_runtime8.jsx)(Button3, { variant: "primary", onClick: onClose, children: "Close" })] })] })] }) });
  };
  var PromptModal_default = PromptModal;

  // ../../packages/mcphappey-core/dist/components/PromptsTab.js
  var import_react11 = __toESM(require_react());
  var import_react12 = __toESM(require_react());
  var PromptsTab = ({ serverUrl, capabilities, prompts, loading, error }) => {
    const { Spinner: Spinner3, Alert: Alert3 } = useTheme();
    const [modalPrompt, setModalPrompt] = (0, import_react11.useState)(null);
    const [submitError, setSubmitError] = (0, import_react11.useState)(null);
    const [promptResult, setPromptResult] = (0, import_react11.useState)(null);
    const { connect } = useMcpConnect();
    const handleOpenPrompt = (prompt) => {
      setModalPrompt(prompt);
      setSubmitError(null);
      setPromptResult(null);
    };
    const handleCloseModal = () => {
      setModalPrompt(null);
      setSubmitError(null);
      setPromptResult(null);
    };
    const handleSubmitPrompt = (0, import_react12.useCallback)(async (values) => {
      setSubmitError(null);
      try {
        const client = await connect(serverUrl);
        if (!modalPrompt)
          throw new Error("No prompt selected");
        const result = await client.getPrompt({
          name: modalPrompt.name,
          arguments: values
        });
        setPromptResult(result);
        console.log("Prompt result:", result);
      } catch (err) {
        setSubmitError(err?.message || String(err));
      }
    }, [connect, serverUrl, modalPrompt]);
    if (!capabilities?.prompts)
      return (0, import_jsx_runtime9.jsx)("span", { children: "No prompt support." });
    if (loading)
      return (0, import_jsx_runtime9.jsx)(Spinner3, { size: "sm" });
    if (error)
      return (0, import_jsx_runtime9.jsx)(Alert3, { variant: "danger", children: error });
    if (!prompts || prompts.length === 0)
      return (0, import_jsx_runtime9.jsx)("span", { children: "No prompts found." });
    return (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [submitError && (0, import_jsx_runtime9.jsx)(Alert3, { variant: "danger", className: "mb-3", children: submitError }), (0, import_jsx_runtime9.jsx)("div", { style: {
      display: "grid",
      gap: 16
    }, children: prompts.map((p) => (0, import_jsx_runtime9.jsx)("div", { children: (0, import_jsx_runtime9.jsx)(PromptCard_default, { prompt: p, onOpen: handleOpenPrompt }) }, p.name)) }), (0, import_jsx_runtime9.jsx)(PromptModal_default, { show: !!modalPrompt, prompt: modalPrompt, onClose: handleCloseModal, onSubmit: handleSubmitPrompt, result: promptResult })] });
  };
  var PromptsTab_default = PromptsTab;

  // ../../packages/mcphappey-core/dist/components/ResourcesTab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime12 = __toESM(require_jsx_runtime());
  var import_react13 = __toESM(require_react());

  // ../../packages/mcphappey-core/dist/components/ResourceCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var ResourceCard = ({ resource, onRead, onOpenLink }) => {
    const { Card: Card3, Button: Button3 } = useTheme();
    return (0, import_jsx_runtime10.jsx)(Card3, { title: resource.name, text: resource.description ?? "", actions: (0, import_jsx_runtime10.jsxs)("div", { style: { display: "flex", gap: 8 }, children: [(0, import_jsx_runtime10.jsx)(Button3, { variant: "primary", size: "sm", onClick: () => onRead(resource), children: "Read resource" }), (0, import_jsx_runtime10.jsx)(Button3, { variant: "secondary", size: "sm", onClick: () => onOpenLink(resource), children: "Open link" })] }) });
  };
  var ResourceCard_default = ResourceCard;

  // ../../packages/mcphappey-core/dist/components/ResourceModal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime11 = __toESM(require_jsx_runtime());
  var ResourceModal = ({ show, onClose, resourceName, mimeType, content, loading, error }) => {
    const { Modal: Modal2, Spinner: Spinner3, Alert: Alert3, Button: Button3 } = useTheme();
    const renderContent = () => {
      if (loading)
        return (0, import_jsx_runtime11.jsx)(Spinner3, { size: "sm" });
      if (error)
        return (0, import_jsx_runtime11.jsx)(Alert3, { variant: "danger", children: error });
      if (content === null || content === void 0)
        return (0, import_jsx_runtime11.jsx)("span", { children: "No content" });
      if (typeof content === "object") {
        return (0, import_jsx_runtime11.jsx)(JsonView, { data: content, shouldExpandNode: () => true, style: defaultStyles });
      }
      if (mimeType?.startsWith("image/") && content instanceof Blob) {
        const url = URL.createObjectURL(content);
        return (0, import_jsx_runtime11.jsx)("img", { src: url, alt: resourceName, style: { maxWidth: "100%" } });
      }
      if (typeof content === "string" && (mimeType?.includes("json") || mimeType?.includes("application/"))) {
        try {
          const json = JSON.parse(content);
          return (0, import_jsx_runtime11.jsx)(JsonView, { data: json, shouldExpandNode: () => true, style: defaultStyles });
        } catch {
        }
      }
      return (0, import_jsx_runtime11.jsx)("pre", { style: { whiteSpace: "pre-wrap", wordBreak: "break-word" }, children: typeof content === "string" ? content : String(content) });
    };
    return (0, import_jsx_runtime11.jsxs)(Modal2, { show, onHide: onClose, size: "lg", title: resourceName, children: [(0, import_jsx_runtime11.jsxs)("div", { style: { marginBottom: 16, color: "#666" }, children: ["mimeType: ", mimeType] }), renderContent(), (0, import_jsx_runtime11.jsx)("div", { style: { marginTop: 24, display: "flex", gap: 8 }, children: (0, import_jsx_runtime11.jsx)(Button3, { variant: "secondary", onClick: onClose, children: "Close" }) })] });
  };
  var ResourceModal_default = ResourceModal;

  // ../../packages/mcphappey-core/dist/components/ResourcesTab.js
  var ResourcesTab = ({ serverUrl, capabilities, resources, loading, error }) => {
    const { Spinner: Spinner3, Alert: Alert3 } = useTheme();
    const { connect } = useMcpConnect();
    const [modalResource, setModalResource] = (0, import_react13.useState)(null);
    const [resourceContent, setResourceContent] = (0, import_react13.useState)(null);
    const [reading, setReading] = (0, import_react13.useState)(false);
    const [readError, setReadError] = (0, import_react13.useState)(null);
    const handleReadResource = (0, import_react13.useCallback)(async (res) => {
      setModalResource(res);
      setReading(true);
      setReadError(null);
      setResourceContent(null);
      try {
        const client = await connect(serverUrl);
        const data2 = await client.readResource({
          uri: res.uri
        });
        setResourceContent(data2);
      } catch (err) {
        setReadError(err?.message || String(err));
      } finally {
        setReading(false);
      }
    }, [connect, serverUrl]);
    const handleOpenLink = (res) => {
      window.open(res.uri, "_blank", "noopener");
    };
    const handleCloseModal = () => {
      setModalResource(null);
      setResourceContent(null);
      setReadError(null);
      setReading(false);
    };
    if (!capabilities?.resources)
      return (0, import_jsx_runtime12.jsx)("span", { children: "No resource support." });
    if (loading)
      return (0, import_jsx_runtime12.jsx)(Spinner3, { size: "sm" });
    if (error)
      return (0, import_jsx_runtime12.jsx)(Alert3, { variant: "danger", children: error });
    if (!resources || resources.length === 0)
      return (0, import_jsx_runtime12.jsx)("span", { children: "No resources found." });
    return (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [(0, import_jsx_runtime12.jsx)("div", { style: {
      display: "grid",
      gap: 16
    }, children: resources.map((r) => (0, import_jsx_runtime12.jsx)("div", { children: (0, import_jsx_runtime12.jsx)(ResourceCard_default, { resource: r, onRead: handleReadResource, onOpenLink: handleOpenLink }) }, r.id)) }), (0, import_jsx_runtime12.jsx)(ResourceModal_default, { show: !!modalResource, onClose: handleCloseModal, resourceName: modalResource?.name || "", mimeType: modalResource?.mimeType, content: resourceContent, loading: reading, error: readError })] });
  };
  var ResourcesTab_default = ResourcesTab;

  // ../../packages/mcphappey-core/dist/components/ToolsTab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  var import_react15 = __toESM(require_react());

  // ../../packages/mcphappey-core/dist/components/ToolCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime13 = __toESM(require_jsx_runtime());
  var ToolCard = ({ tool, onOpen }) => {
    const { Card: Card3, Button: Button3 } = useTheme();
    return (0, import_jsx_runtime13.jsx)(Card3, { title: tool.name, text: tool.description ?? "", actions: (0, import_jsx_runtime13.jsx)(Button3, { variant: "primary", size: "sm", onClick: () => onOpen(tool), children: "Open" }) });
  };
  var ToolCard_default = ToolCard;

  // ../../packages/mcphappey-core/dist/components/ToolModal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime14 = __toESM(require_jsx_runtime());
  var import_react14 = __toESM(require_react());
  var ToolModal = ({ show, tool, onClose, onSubmit, result }) => {
    const { Modal: Modal2, Input: Input3, Button: Button3, Badge: Badge3 } = useTheme();
    const [formValues, setFormValues] = (0, import_react14.useState)({});
    const [touched, setTouched] = (0, import_react14.useState)({});
    const [view, setView] = (0, import_react14.useState)("form");
    const schema = tool?.inputSchema ?? {};
    const properties = schema.properties ?? {};
    const requiredSet = (0, import_react14.useMemo)(() => {
      const req = schema.required;
      return new Set(req ?? []);
    }, [schema.required]);
    (0, import_react14.useEffect)(() => {
      if (tool) {
        const initial = {};
        Object.entries(properties).forEach(([name, prop]) => {
          if (prop.default !== void 0)
            initial[name] = prop.default;
          else if (prop.type === "boolean")
            initial[name] = false;
          else
            initial[name] = "";
        });
        setFormValues(initial);
        setTouched({});
      }
      setView("form");
    }, [tool, show]);
    (0, import_react14.useEffect)(() => {
      if (result !== void 0 && result !== null)
        setView("result");
    }, [result]);
    if (!tool)
      return null;
    const handleChange = (name, value) => {
      setFormValues((v) => ({ ...v, [name]: value }));
      setTouched((t) => ({ ...t, [name]: true }));
    };
    const isValid2 = () => {
      for (const key of requiredSet) {
        const v = formValues[key];
        if (v === void 0 || v === null || typeof v === "string" && !v.trim())
          return false;
      }
      return true;
    };
    const handleSubmit = (e) => {
      e.preventDefault();
      if (isValid2()) {
        const fixed = {};
        Object.entries(properties).forEach(([name, prop]) => {
          let val = formValues[name];
          if (val === "" && prop.enum?.includes(null))
            val = null;
          fixed[name] = val;
        });
        onSubmit(fixed);
      }
    };
    const allExpanded2 = () => true;
    const renderField = (name, prop) => {
      const required = requiredSet.has(name);
      const typeArray = Array.isArray(prop.type) ? prop.type : prop.type ? [prop.type] : [];
      if (prop.enum && prop.enum.length > 0) {
        return (0, import_jsx_runtime14.jsxs)("select", { value: formValues[name] ?? "", onChange: (e) => handleChange(name, e.target.value), required, style: { padding: 6, width: "100%" }, children: [!required && !prop.enum.includes(null) && (0, import_jsx_runtime14.jsx)("option", { value: "", children: "-- none --" }), prop.enum.map((opt) => (0, import_jsx_runtime14.jsx)("option", { value: opt === null ? "" : String(opt), children: opt === null ? "-- none --" : String(opt) }, String(opt)))] });
      }
      if (typeArray.includes("boolean")) {
        return (0, import_jsx_runtime14.jsx)("input", { type: "checkbox", checked: !!formValues[name], onChange: (e) => handleChange(name, e.target.checked) });
      }
      const inputType = typeArray.includes("number") ? "number" : "text";
      return (0, import_jsx_runtime14.jsx)(Input3, { type: inputType, required, value: formValues[name] ?? "", onChange: (e) => handleChange(name, e?.target?.value !== void 0 ? e.target.value : e), placeholder: prop.description || name, style: {
        borderColor: touched[name] && required && !formValues[name] ? "#dc3545" : void 0
      } });
    };
    return (0, import_jsx_runtime14.jsx)(Modal2, { show, onHide: onClose, size: "lg", title: tool.name, children: (0, import_jsx_runtime14.jsxs)("div", { children: [(0, import_jsx_runtime14.jsx)("div", { style: { marginBottom: 12, color: "#666" }, children: tool.description }), view === "form" ? (0, import_jsx_runtime14.jsxs)("form", { onSubmit: handleSubmit, children: [Object.keys(properties).length > 0 ? (0, import_jsx_runtime14.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: 16 }, children: Object.entries(properties).map(([name, prop]) => (0, import_jsx_runtime14.jsxs)("div", { children: [(0, import_jsx_runtime14.jsxs)("label", { style: { fontWeight: 500 }, children: [name, requiredSet.has(name) && (0, import_jsx_runtime14.jsx)("span", { style: { marginLeft: 6 }, children: (0, import_jsx_runtime14.jsx)(Badge3, { bg: "danger", children: "required" }) })] }), (0, import_jsx_runtime14.jsx)("div", { style: { color: "#666", fontSize: 13, marginBottom: 2 }, children: prop.description }), renderField(name, prop)] }, name)) }) : (0, import_jsx_runtime14.jsx)("div", { style: { color: "#888", marginBottom: 16 }, children: "No inputs required for this tool." }), (0, import_jsx_runtime14.jsxs)("div", { style: { marginTop: 24, display: "flex", gap: 8 }, children: [(0, import_jsx_runtime14.jsx)(Button3, { variant: "primary", type: "submit", disabled: !isValid2(), children: "Call tool" }), (0, import_jsx_runtime14.jsx)(Button3, { variant: "secondary", onClick: onClose, type: "button", children: "Close" })] })] }) : (0, import_jsx_runtime14.jsxs)("div", { children: [(0, import_jsx_runtime14.jsx)("div", { style: { marginTop: 8 }, children: (0, import_jsx_runtime14.jsx)(JsonView, { data: result, shouldExpandNode: allExpanded2, style: defaultStyles }) }), (0, import_jsx_runtime14.jsxs)("div", { style: { marginTop: 24, display: "flex", gap: 8 }, children: [(0, import_jsx_runtime14.jsx)(Button3, { variant: "secondary", onClick: () => setView("form"), children: "Back" }), (0, import_jsx_runtime14.jsx)(Button3, { variant: "primary", onClick: onClose, children: "Close" })] })] })] }) });
  };
  var ToolModal_default = ToolModal;

  // ../../packages/mcphappey-core/dist/components/ToolsTab.js
  var ToolsTab = ({ serverUrl, capabilities, tools, loading, error }) => {
    const { Spinner: Spinner3, Alert: Alert3 } = useTheme();
    const { connect } = useMcpConnect();
    const [modalTool, setModalTool] = (0, import_react15.useState)(null);
    const [submitError, setSubmitError] = (0, import_react15.useState)(null);
    const [toolResult, setToolResult] = (0, import_react15.useState)(null);
    const handleOpenTool = (tool) => {
      setModalTool(tool);
      setSubmitError(null);
      setToolResult(null);
    };
    const handleCloseModal = () => {
      setModalTool(null);
      setSubmitError(null);
      setToolResult(null);
    };
    const handleSubmitTool = (0, import_react15.useCallback)(async (values) => {
      setSubmitError(null);
      try {
        const client = await connect(serverUrl);
        await new Promise((resolve) => setTimeout(resolve, 100));
        if (!modalTool)
          throw new Error("No tool selected");
        const result = await client.callTool({
          name: modalTool.name,
          arguments: values
        });
        setToolResult(result);
        console.log("Tool result:", result);
      } catch (err) {
        setSubmitError(err?.message || String(err));
      }
    }, [connect, serverUrl, modalTool]);
    if (!capabilities?.tools)
      return (0, import_jsx_runtime15.jsx)("span", { children: "No tool support." });
    if (loading)
      return (0, import_jsx_runtime15.jsx)(Spinner3, { size: "sm" });
    if (error)
      return (0, import_jsx_runtime15.jsx)(Alert3, { variant: "danger", children: error });
    if (!tools || tools.length === 0)
      return (0, import_jsx_runtime15.jsx)("span", { children: "No tools found." });
    return (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [submitError && (0, import_jsx_runtime15.jsx)(Alert3, { variant: "danger", className: "mb-3", children: submitError }), (0, import_jsx_runtime15.jsx)("div", { style: {
      display: "grid",
      gap: 16
    }, children: tools.map((t) => (0, import_jsx_runtime15.jsx)("div", { children: (0, import_jsx_runtime15.jsx)(ToolCard_default, { tool: t, onOpen: handleOpenTool }) }, t.name)) }), (0, import_jsx_runtime15.jsx)(ToolModal_default, { show: !!modalTool, tool: modalTool, onClose: handleCloseModal, onSubmit: handleSubmitTool, result: toolResult })] });
  };
  var ToolsTab_default = ToolsTab;

  // ../../packages/mcphappey-core/dist/components/ServerModal.js
  var ServerModal = ({ show, server, onClose }) => {
    const { Modal: Modal2, Tabs: Tabs2, Tab: Tab4, Button: Button3 } = useTheme();
    const [tabKey, setTabKey] = (0, import_react16.useState)("summary");
    const primitives = useServerPrimitives(server?.url || null);
    (0, import_react16.useEffect)(() => {
      setTabKey("summary");
    }, [server, show]);
    (0, import_react16.useEffect)(() => {
      if (show && server) {
        primitives.loadAll();
      }
    }, [show, server?.url]);
    if (!show || !server)
      return null;
    return (0, import_jsx_runtime16.jsx)(Modal2, { show, onHide: onClose, title: server.name, size: "lg", centered: true, children: (0, import_jsx_runtime16.jsx)("div", { className: "mcph-modal-body", style: { padding: 16 }, children: (0, import_jsx_runtime16.jsxs)(Tabs2, { activeKey: tabKey, onSelect: setTabKey, className: "mb-3", children: [(0, import_jsx_runtime16.jsx)(Tab4, { eventKey: "summary", title: "Summary", children: (0, import_jsx_runtime16.jsx)(ServerSummary_default, { server, loading: !!primitives.loading, toolCount: primitives.tools?.length, resourceCount: primitives.resources?.length, promptCount: primitives.prompts?.length, error: primitives.error, capabilities: primitives.capabilities }) }), (0, import_jsx_runtime16.jsx)(Tab4, { eventKey: "prompts", title: "Prompts", children: (0, import_jsx_runtime16.jsx)(PromptsTab_default, { serverUrl: server.url, capabilities: primitives.capabilities, prompts: primitives.prompts, loading: !!primitives.loading, error: primitives.error }) }), (0, import_jsx_runtime16.jsx)(Tab4, { eventKey: "resources", title: "Resources", children: (0, import_jsx_runtime16.jsx)(ResourcesTab_default, { serverUrl: server.url, capabilities: primitives.capabilities, resources: primitives.resources, loading: !!primitives.loading, error: primitives.error }) }), (0, import_jsx_runtime16.jsx)(Tab4, { eventKey: "tools", title: "Tools", children: (0, import_jsx_runtime16.jsx)(ToolsTab_default, { serverUrl: server.url, capabilities: primitives.capabilities, tools: primitives.tools, loading: !!primitives.loading, error: primitives.error }) })] }) }) });
  };
  var ServerModal_default = ServerModal;

  // ../../packages/mcphappey-core/dist/components/ServerList.js
  var ServerList = ({ servers }) => {
    const { Alert: Alert3, Switch: Switch3, TextArea: TextArea2 } = useTheme();
    const [selectedServer, setSelectedServer] = (0, import_react17.useState)(null);
    const [modalOpen, setModalOpen] = (0, import_react17.useState)(false);
    const [showRaw, setShowRaw] = (0, import_react17.useState)(false);
    const handleShowDetails = (server) => {
      setSelectedServer(server);
      setModalOpen(true);
    };
    const handleCloseModal = () => {
      setModalOpen(false);
      setSelectedServer(null);
    };
    const serversWithAuth = servers.map((s) => {
      const token = getAccessToken(s.url);
      return token ? {
        ...s,
        headers: { ...s.headers ?? {}, Authorization: `Bearer ${token}` }
      } : s;
    });
    const serverDict = Object.fromEntries(serversWithAuth.map(({ name, ...rest }) => [name, rest]));
    if (servers.length === 0) {
      return (0, import_jsx_runtime17.jsx)(Alert3, { variant: "info", className: "my-3", children: "No MCP servers found." });
    }
    return (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [(0, import_jsx_runtime17.jsx)("div", { style: { marginBottom: 16 }, children: (0, import_jsx_runtime17.jsx)(Switch3, { id: "raw-json-toggle", label: "Show raw JSON", checked: showRaw, onChange: setShowRaw }) }), showRaw ? (0, import_jsx_runtime17.jsx)(TextArea2, { rows: Math.min(20, serversWithAuth.length * 4), value: JSON.stringify({ servers: serverDict }, null, 2), style: {
      fontFamily: "monospace",
      fontSize: 12,
      background: "#f8f9fa",
      borderRadius: 4
    }, onChange: () => {
    } }) : (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [(0, import_jsx_runtime17.jsx)("div", { style: { display: "flex", flexWrap: "wrap", gap: 16 }, children: servers.map((server) => (0, import_jsx_runtime17.jsx)("div", { style: { flex: "1 0 250px", minWidth: 250 }, children: (0, import_jsx_runtime17.jsx)(ServerCard_default, { server, onShowDetails: handleShowDetails }) }, server.name)) }), (0, import_jsx_runtime17.jsx)(ServerModal_default, { show: modalOpen, server: selectedServer, onClose: handleCloseModal })] })] });
  };
  var ServerList_default = ServerList;

  // ../../packages/mcphappey-core/dist/CoreRoot.js
  var CoreRoot = ({ initialLists = [], allowCustomLists = true }) => {
    const theme = useTheme();
    const { Alert: Alert3, Button: Button3, Spinner: Spinner3, Input: Input3 } = theme;
    const { servers, loading, error, importList, clearAll } = useAppStore();
    const [customUrl, setCustomUrl] = (0, import_react18.useState)("");
    (0, import_react18.useEffect)(() => {
      if (initialLists.length > 0) {
        initialLists.forEach((url) => importList(url));
      }
    }, []);
    const handleAddCustom = (e) => {
      e.preventDefault();
      if (customUrl.trim()) {
        importList(customUrl.trim());
        setCustomUrl("");
      }
    };
    return (0, import_jsx_runtime18.jsx)(McpPoolProvider, { children: (0, import_jsx_runtime18.jsxs)("div", { role: "main", style: { maxWidth: 900, margin: "0 auto", padding: 16 }, children: [(0, import_jsx_runtime18.jsx)("h2", { children: "MCP Server Discovery" }), allowCustomLists && (0, import_jsx_runtime18.jsxs)("form", { onSubmit: handleAddCustom, style: { marginBottom: 16, display: "flex", gap: 8 }, children: [(0, import_jsx_runtime18.jsx)(Input3, { type: "url", placeholder: "Add MCP server list URL", value: customUrl, onChange: (e) => setCustomUrl(e.target.value), required: true, style: { flex: 1 } }), (0, import_jsx_runtime18.jsx)(Button3, { type: "submit", variant: "secondary", children: "Add" }), (0, import_jsx_runtime18.jsx)(Button3, { type: "button", variant: "outline-danger", onClick: clearAll, children: "Clear" })] }), loading && (0, import_jsx_runtime18.jsxs)("div", { style: { margin: "16px 0" }, children: [(0, import_jsx_runtime18.jsx)(Spinner3, {}), " Loading server lists..."] }), error && (0, import_jsx_runtime18.jsx)("div", { style: { margin: "16px 0" }, children: (0, import_jsx_runtime18.jsx)(Alert3, { variant: "danger", children: error }) }), (0, import_jsx_runtime18.jsx)(ServerList_default, { servers })] }) });
  };
  var CoreRoot_default = CoreRoot;

  // ../../packages/mcphappey-core/dist/index.js
  var dist_default = CoreRoot_default;

  // ../../packages/mcphappey-theme-fluent/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-theme-fluent/dist/ThemeProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime53 = __toESM(require_jsx_runtime());

  // ../../packages/mcphappey-theme-fluent/dist/primitives.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-theme-fluent/dist/fluentTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Button.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime40 = __toESM(require_jsx_runtime());

  // ../../node_modules/@fluentui/react-components/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@griffel/react/index.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@griffel/core/index.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@griffel/core/renderer/createDOMRenderer.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@griffel/core/constants.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var __GLOBAL__ = typeof window === "undefined" ? global : window;
  var __NAMESPACE_PREFIX__ = "@griffel/";
  function getGlobalVar(name, defaultValue) {
    if (!__GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name)]) {
      __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name)] = defaultValue;
    }
    return __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name)];
  }
  var DEFINITION_LOOKUP_TABLE = /* @__PURE__ */ getGlobalVar("DEFINITION_LOOKUP_TABLE", {});
  var DATA_BUCKET_ATTR = "data-make-styles-bucket";
  var DATA_PRIORITY_ATTR = "data-priority";
  var SEQUENCE_HASH_LENGTH = 7;
  var SEQUENCE_PREFIX = "___";
  var DEBUG_SEQUENCE_SEPARATOR = "_";
  var SEQUENCE_SIZE = true ? SEQUENCE_PREFIX.length + SEQUENCE_HASH_LENGTH : SEQUENCE_PREFIX.length + SEQUENCE_HASH_LENGTH + DEBUG_SEQUENCE_SEPARATOR.length + SEQUENCE_HASH_LENGTH;
  var LOOKUP_DEFINITIONS_INDEX = 0;
  var LOOKUP_DIR_INDEX = 1;

  // ../../node_modules/@griffel/core/mergeClasses.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@griffel/core/runtime/utils/hashSequence.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@emotion/hash/dist/emotion-hash.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function murmur2(str) {
    var h = 0;
    var k, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }

  // ../../node_modules/@griffel/core/runtime/utils/hashSequence.esm.js
  function padEndHash(value) {
    const hashLength = value.length;
    if (hashLength === SEQUENCE_HASH_LENGTH) {
      return value;
    }
    for (let i = hashLength; i < SEQUENCE_HASH_LENGTH; i++) {
      value += "0";
    }
    return value;
  }
  function hashSequence(classes, dir, sequenceIds = []) {
    if (true) {
      return SEQUENCE_PREFIX + padEndHash(murmur2(classes + dir));
    }
    return SEQUENCE_PREFIX + padEndHash(murmur2(classes + dir)) + DEBUG_SEQUENCE_SEPARATOR + padEndHash(murmur2(sequenceIds.join("")));
  }

  // ../../node_modules/@griffel/core/runtime/reduceToClassNameForSlots.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function reduceToClassName(classMap, dir) {
    let classString = "";
    let hashString = "";
    for (const propertyHash in classMap) {
      const classNameMapping = classMap[propertyHash];
      if (classNameMapping === 0) {
        hashString += propertyHash + " ";
        continue;
      }
      const hasRTLClassName = Array.isArray(classNameMapping);
      const className = dir === "rtl" ? (hasRTLClassName ? classNameMapping[1] : classNameMapping) + " " : (hasRTLClassName ? classNameMapping[0] : classNameMapping) + " ";
      classString += className;
      hashString += className;
    }
    return [classString.slice(0, -1), hashString.slice(0, -1)];
  }
  function reduceToClassNameForSlots(classesMapBySlot, dir) {
    const classNamesForSlots = {};
    for (const slotName in classesMapBySlot) {
      const [slotClasses, slotClassesHash] = reduceToClassName(classesMapBySlot[slotName], dir);
      if (slotClassesHash === "") {
        classNamesForSlots[slotName] = "";
        continue;
      }
      const sequenceHash = hashSequence(slotClassesHash, dir);
      const resultSlotClasses = sequenceHash + (slotClasses === "" ? "" : " " + slotClasses);
      DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];
      classNamesForSlots[slotName] = resultSlotClasses;
    }
    return classNamesForSlots;
  }

  // ../../node_modules/@griffel/core/mergeClasses.esm.js
  var mergeClassesCachedResults = {};
  function mergeClasses() {
    let dir = null;
    let resultClassName = "";
    let sequenceMatch = "";
    const sequencesIds = new Array(arguments.length);
    let containsResetClassName = "";
    for (let i = 0; i < arguments.length; i++) {
      const className = arguments[i];
      if (typeof className === "string" && className !== "") {
        const sequenceIndex = className.indexOf(SEQUENCE_PREFIX);
        if (sequenceIndex === -1) {
          if (false) {
            className.split(" ").forEach((entry) => {
              if (entry.startsWith(RESET_HASH_PREFIX) && DEBUG_RESET_CLASSES[entry]) {
                if (containsResetClassName) {
                  console.error(`mergeClasses(): a passed string contains multiple classes produced by makeResetStyles (${className} & ${resultClassName}, this will lead to non-deterministic behavior. Learn more:https://griffel.js.org/react/api/make-reset-styles#limitations
Source string: ${className}`);
                } else {
                  containsResetClassName = entry;
                }
              }
            });
          }
          resultClassName += className + " ";
        } else {
          const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE);
          if (sequenceIndex > 0) {
            resultClassName += className.slice(0, sequenceIndex);
          }
          sequenceMatch += sequenceId;
          sequencesIds[i] = sequenceId;
        }
        if (false) {
          if (className.indexOf(SEQUENCE_PREFIX, sequenceIndex + 1) !== -1) {
            console.error(`mergeClasses(): a passed string contains multiple identifiers of atomic classes (classes that start with "${SEQUENCE_PREFIX}"), it's possible that passed classes were concatenated in a wrong way. Source string: ${className}`);
          }
        }
      }
    }
    if (sequenceMatch === "") {
      return resultClassName.slice(0, -1);
    }
    const mergeClassesResult = mergeClassesCachedResults[sequenceMatch];
    if (mergeClassesResult !== void 0) {
      return resultClassName + mergeClassesResult;
    }
    const sequenceMappings = [];
    for (let i = 0; i < arguments.length; i++) {
      const sequenceId = sequencesIds[i];
      if (sequenceId) {
        const sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId];
        if (sequenceMapping) {
          sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX]);
          if (false) {
            if (dir !== null && dir !== sequenceMapping[LOOKUP_DIR_INDEX]) {
              console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that has different direction (dir="${sequenceMapping[1] ? "rtl" : "ltr"}") setting than other classes. This is not supported. Source string: ${arguments[i]}`);
            }
          }
          dir = sequenceMapping[LOOKUP_DIR_INDEX];
        } else {
          if (false) {
            console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that does not match any entry in cache. Source string: ${arguments[i]}`);
          }
        }
      }
    }
    const resultClassesMap = Object.assign.apply(
      Object,
      // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later
      [{}].concat(sequenceMappings)
    );
    const [atomicClasses, classesMapHash] = reduceToClassName(resultClassesMap, dir);
    const newSequenceHash = hashSequence(classesMapHash, dir, sequencesIds);
    const newClassName = newSequenceHash + " " + atomicClasses;
    mergeClassesCachedResults[sequenceMatch] = newClassName;
    DEFINITION_LOOKUP_TABLE[newSequenceHash] = [resultClassesMap, dir];
    return resultClassName + newClassName;
  }

  // ../../node_modules/@griffel/core/runtime/utils/normalizeCSSBucketEntry.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function normalizeCSSBucketEntry(entry) {
    if (!Array.isArray(entry)) {
      return [entry];
    }
    if (false) {
      throw new Error("CSS Bucket contains an entry with greater than 2 items, please report this to https://github.com/microsoft/griffel/issues");
    }
    return entry;
  }

  // ../../node_modules/@griffel/core/renderer/getStyleSheetForBucket.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@griffel/core/renderer/createIsomorphicStyleSheet.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function createIsomorphicStyleSheet(styleElement, bucketName, priority, elementAttributes) {
    const __cssRulesForSSR = [];
    elementAttributes[DATA_BUCKET_ATTR] = bucketName;
    elementAttributes[DATA_PRIORITY_ATTR] = String(priority);
    if (styleElement) {
      for (const attrName in elementAttributes) {
        styleElement.setAttribute(attrName, elementAttributes[attrName]);
      }
    }
    function insertRule(rule) {
      if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {
        return styleElement.sheet.insertRule(rule, styleElement.sheet.cssRules.length);
      }
      return __cssRulesForSSR.push(rule);
    }
    return {
      elementAttributes,
      insertRule,
      element: styleElement,
      bucketName,
      cssRules() {
        if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {
          return Array.from(styleElement.sheet.cssRules).map((cssRule) => cssRule.cssText);
        }
        return __cssRulesForSSR;
      }
    };
  }

  // ../../node_modules/@griffel/core/renderer/getStyleSheetForBucket.esm.js
  var styleBucketOrdering = [
    // reset styles
    "r",
    // catch-all
    "d",
    // link
    "l",
    // visited
    "v",
    // focus-within
    "w",
    // focus
    "f",
    // focus-visible
    "i",
    // hover
    "h",
    // active
    "a",
    // at rules for reset styles
    "s",
    // keyframes
    "k",
    // at-rules
    "t",
    // @media rules
    "m",
    // @container rules
    "c"
  ];
  var styleBucketOrderingMap = /* @__PURE__ */ styleBucketOrdering.reduce((acc, cur, j) => {
    acc[cur] = j;
    return acc;
  }, {});
  function getStyleSheetKey(bucketName, media, priority) {
    return (bucketName === "m" ? bucketName + media : bucketName) + priority;
  }
  function getStyleSheetForBucket(bucketName, targetDocument, insertionPoint, renderer, metadata = {}) {
    var _a, _b;
    const isMediaBucket = bucketName === "m";
    const media = (_a = metadata["m"]) !== null && _a !== void 0 ? _a : "0";
    const priority = (_b = metadata["p"]) !== null && _b !== void 0 ? _b : 0;
    const stylesheetKey = getStyleSheetKey(bucketName, media, priority);
    if (!renderer.stylesheets[stylesheetKey]) {
      const tag = targetDocument && targetDocument.createElement("style");
      const stylesheet = createIsomorphicStyleSheet(tag, bucketName, priority, Object.assign({}, renderer.styleElementAttributes, isMediaBucket && {
        media
      }));
      renderer.stylesheets[stylesheetKey] = stylesheet;
      if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.head) && tag) {
        targetDocument.head.insertBefore(tag, findInsertionPoint(targetDocument, insertionPoint, bucketName, renderer, metadata));
      }
    }
    return renderer.stylesheets[stylesheetKey];
  }
  function isSameInsertionKey(element, bucketName, metadata) {
    var _a, _b;
    const targetKey = bucketName + ((_a = metadata["m"]) !== null && _a !== void 0 ? _a : "");
    const elementKey = element.getAttribute(DATA_BUCKET_ATTR) + ((_b = element.media) !== null && _b !== void 0 ? _b : "");
    return targetKey === elementKey;
  }
  function findInsertionPoint(targetDocument, insertionPoint, targetBucket, renderer, metadata = {}) {
    var _a, _b;
    const targetOrder = styleBucketOrderingMap[targetBucket];
    const media = (_a = metadata["m"]) !== null && _a !== void 0 ? _a : "";
    const priority = (_b = metadata["p"]) !== null && _b !== void 0 ? _b : 0;
    let comparer = (el) => targetOrder - styleBucketOrderingMap[el.getAttribute(DATA_BUCKET_ATTR)];
    let styleElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}]`);
    if (targetBucket === "m") {
      const mediaElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}="${targetBucket}"]`);
      if (mediaElements.length) {
        styleElements = mediaElements;
        comparer = (el) => renderer.compareMediaQueries(media, el.media);
      }
    }
    const comparerWithPriority = (el) => {
      if (isSameInsertionKey(el, targetBucket, metadata)) {
        return priority - Number(el.getAttribute("data-priority"));
      }
      return comparer(el);
    };
    const length = styleElements.length;
    let index = length - 1;
    while (index >= 0) {
      const styleElement = styleElements.item(index);
      if (comparerWithPriority(styleElement) > 0) {
        return styleElement.nextSibling;
      }
      index--;
    }
    if (length > 0) {
      return styleElements.item(0);
    }
    return insertionPoint ? insertionPoint.nextSibling : null;
  }

  // ../../node_modules/@griffel/core/renderer/safeInsertRule.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var ignoreSuffixes = /* @__PURE__ */ ["-moz-placeholder", "-moz-focus-inner", "-moz-focusring", "-ms-input-placeholder", "-moz-read-write", "-moz-read-only"].join("|");
  var ignoreSuffixesRegex = /* @__PURE__ */ new RegExp(`:(${ignoreSuffixes})`);
  function safeInsertRule(sheet, ruleCSS) {
    try {
      sheet.insertRule(ruleCSS);
    } catch (e) {
      if (false) {
        console.error(`There was a problem inserting the following rule: "${ruleCSS}"`, e);
      }
    }
  }

  // ../../node_modules/@griffel/core/renderer/createDOMRenderer.esm.js
  var lastIndex = 0;
  var defaultCompareMediaQueries = (a, b) => a < b ? -1 : a > b ? 1 : 0;
  function createDOMRenderer(targetDocument = typeof document === "undefined" ? void 0 : document, options = {}) {
    const {
      classNameHashSalt,
      unstable_filterCSSRule,
      insertionPoint,
      styleElementAttributes,
      compareMediaQueries = defaultCompareMediaQueries
    } = options;
    const renderer = {
      classNameHashSalt,
      insertionCache: {},
      stylesheets: {},
      styleElementAttributes: Object.freeze(styleElementAttributes),
      compareMediaQueries,
      id: `d${lastIndex++}`,
      insertCSSRules(cssRules) {
        for (const styleBucketName in cssRules) {
          const cssRulesForBucket = cssRules[styleBucketName];
          for (let i = 0, l = cssRulesForBucket.length; i < l; i++) {
            const [ruleCSS, metadata] = normalizeCSSBucketEntry(cssRulesForBucket[i]);
            const sheet = getStyleSheetForBucket(styleBucketName, targetDocument, insertionPoint || null, renderer, metadata);
            if (renderer.insertionCache[ruleCSS]) {
              continue;
            }
            renderer.insertionCache[ruleCSS] = styleBucketName;
            if (false) {
              debugData.addCSSRule(ruleCSS);
            }
            if (unstable_filterCSSRule) {
              if (unstable_filterCSSRule(ruleCSS)) {
                safeInsertRule(sheet, ruleCSS);
              }
            } else {
              safeInsertRule(sheet, ruleCSS);
            }
          }
        }
      }
    };
    if (targetDocument && false) {
      injectDevTools(targetDocument);
    }
    return renderer;
  }

  // ../../node_modules/@griffel/core/insertionFactory.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var insertionFactory = () => {
    const insertionCache = {};
    return function insertStyles(renderer, cssRules) {
      if (insertionCache[renderer.id] === void 0) {
        renderer.insertCSSRules(cssRules);
        insertionCache[renderer.id] = true;
      }
    };
  };

  // ../../node_modules/@griffel/core/__styles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function __styles(classesMapBySlot, cssRules, factory = insertionFactory) {
    const insertStyles = factory();
    let ltrClassNamesForSlots = null;
    let rtlClassNamesForSlots = null;
    let sourceURL;
    if (false) {
      sourceURL = getSourceURLfromError();
    }
    function computeClasses(options) {
      const {
        dir,
        renderer
      } = options;
      const isLTR = dir === "ltr";
      if (isLTR) {
        if (ltrClassNamesForSlots === null) {
          ltrClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
        }
      } else {
        if (rtlClassNamesForSlots === null) {
          rtlClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
        }
      }
      insertStyles(renderer, cssRules);
      const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
      if (false) {
        debugData.addSequenceDetails(classNamesForSlots, sourceURL);
      }
      return classNamesForSlots;
    }
    return computeClasses;
  }

  // ../../node_modules/@griffel/core/__resetStyles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function __resetStyles(ltrClassName, rtlClassName, cssRules, factory = insertionFactory) {
    const insertStyles = factory();
    function computeClassName(options) {
      const {
        dir,
        renderer
      } = options;
      const className = dir === "ltr" ? ltrClassName : rtlClassName || ltrClassName;
      insertStyles(renderer, Array.isArray(cssRules) ? {
        r: cssRules
      } : cssRules);
      if (false) {
        DEBUG_RESET_CLASSES[className] = 1;
      }
      return className;
    }
    return computeClassName;
  }

  // ../../node_modules/@griffel/react/insertionFactory.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@griffel/react/utils/canUseDOM.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function canUseDOM() {
    return typeof window !== "undefined" && !!(window.document && window.document.createElement);
  }

  // ../../node_modules/@griffel/react/useInsertionEffect.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React14 = __toESM(require_react());
  var useInsertionEffect2 = (
    // @ts-expect-error Hack to make sure that `useInsertionEffect` will not cause bundling issues in older React versions
    // eslint-disable-next-line no-useless-concat
    React14["useInsertionEffect"] ? React14["useInsertionEffect"] : void 0
  );

  // ../../node_modules/@griffel/react/insertionFactory.esm.js
  var insertionFactory2 = () => {
    const insertionCache = {};
    return function insert(renderer, cssRules) {
      if (useInsertionEffect2 && canUseDOM()) {
        useInsertionEffect2(() => {
          renderer.insertCSSRules(cssRules);
        }, [renderer, cssRules]);
        return;
      }
      if (insertionCache[renderer.id] === void 0) {
        renderer.insertCSSRules(cssRules);
        insertionCache[renderer.id] = true;
      }
    };
  };

  // ../../node_modules/@griffel/react/RendererContext.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React15 = __toESM(require_react());
  var RendererContext = /* @__PURE__ */ React15.createContext(/* @__PURE__ */ createDOMRenderer());
  function useRenderer() {
    return React15.useContext(RendererContext);
  }

  // ../../node_modules/@griffel/react/TextDirectionContext.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React16 = __toESM(require_react());
  var TextDirectionContext = /* @__PURE__ */ React16.createContext("ltr");
  var TextDirectionProvider = ({
    children,
    dir
  }) => {
    return /* @__PURE__ */ React16.createElement(TextDirectionContext.Provider, {
      value: dir
    }, children);
  };
  function useTextDirection() {
    return React16.useContext(TextDirectionContext);
  }

  // ../../node_modules/@griffel/react/__styles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function __styles2(classesMapBySlot, cssRules) {
    const getStyles = __styles(classesMapBySlot, cssRules, insertionFactory2);
    return function useClasses() {
      const dir = useTextDirection();
      const renderer = useRenderer();
      return getStyles({
        dir,
        renderer
      });
    };
  }

  // ../../node_modules/@griffel/react/__resetStyles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function __resetStyles2(ltrClassName, rtlClassName, cssRules) {
    const getStyles = __resetStyles(ltrClassName, rtlClassName, cssRules, insertionFactory2);
    return function useClasses() {
      const dir = useTextDirection();
      const renderer = useRenderer();
      return getStyles({
        dir,
        renderer
      });
    };
  }

  // ../../node_modules/@fluentui/react-provider/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-provider/lib/FluentProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/createCSSRuleFromTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function createCSSRuleFromTheme(selector, theme) {
    if (theme) {
      const cssVarsAsString = Object.keys(theme).reduce((cssVarRule, cssVar) => {
        return `${cssVarRule}--${cssVar}: ${theme[cssVar]}; `;
      }, "");
      return `${selector} { ${cssVarsAsString} }`;
    }
    return `${selector} {}`;
  }

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/FluentProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React55 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/renderFluentProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx-runtime.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/compose/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/compose/slot.js
  var slot_exports = {};
  __export(slot_exports, {
    always: () => always,
    optional: () => optional,
    resolveShorthand: () => resolveShorthand
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React17 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/compose/constants.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var SLOT_RENDER_FUNCTION_SYMBOL = Symbol.for("fui.slotRenderFunction");
  var SLOT_ELEMENT_TYPE_SYMBOL = Symbol.for("fui.slotElementType");
  var SLOT_CLASS_NAME_PROP_SYMBOL = Symbol.for("fui.slotClassNameProp");

  // ../../node_modules/@fluentui/react-utilities/lib/compose/slot.js
  function always(value, options) {
    const { defaultProps, elementType } = options;
    const props = resolveShorthand(value);
    const propsWithMetadata = {
      ...defaultProps,
      ...props,
      [SLOT_ELEMENT_TYPE_SYMBOL]: elementType,
      [SLOT_CLASS_NAME_PROP_SYMBOL]: props === null || props === void 0 ? void 0 : props.className
    };
    if (props && typeof props.children === "function") {
      propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = props.children;
      propsWithMetadata.children = defaultProps === null || defaultProps === void 0 ? void 0 : defaultProps.children;
    }
    return propsWithMetadata;
  }
  function optional(value, options) {
    if (value === null || value === void 0 && !options.renderByDefault) {
      return void 0;
    }
    return always(value, options);
  }
  function resolveShorthand(value) {
    if (typeof value === "string" || typeof value === "number" || isIterable(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    React17.isValidElement(value)) {
      return {
        children: value
      };
    }
    if (value && typeof value !== "object" && false) {
      console.error(`@fluentui/react-utilities [slot.${resolveShorthand.name}]:
A slot got an invalid value "${value}" (${typeof value}).
A valid value for a slot is a slot shorthand or slot properties object.
Slot shorthands can be strings, numbers, arrays or JSX elements`);
    }
    return value;
  }
  var isIterable = (value) => typeof value === "object" && value !== null && Symbol.iterator in value;

  // ../../node_modules/@fluentui/react-utilities/lib/compose/isResolvedShorthand.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React18 = __toESM(require_react());
  function isResolvedShorthand(shorthand) {
    return shorthand !== null && typeof shorthand === "object" && !Array.isArray(shorthand) && !React18.isValidElement(shorthand);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/compose/isSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function isSlot(element) {
    return Boolean(element === null || element === void 0 ? void 0 : element.hasOwnProperty(SLOT_ELEMENT_TYPE_SYMBOL));
  }

  // ../../node_modules/@fluentui/react-utilities/lib/compose/assertSlots.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React19 = __toESM(require_react());
  function assertSlots(state) {
    if (false) {
      const typedState = state;
      for (const slotName of Object.keys(typedState.components)) {
        const slotElement = typedState[slotName];
        if (slotElement === void 0) {
          continue;
        }
        if (!isSlot(slotElement)) {
          typedState[slotName] = always(slotElement, {
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            elementType: typedState.components[slotName]
          });
          console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" is not a slot!
Be sure to create slots properly by using "slot.always" or "slot.optional".`);
        } else {
          const { [SLOT_ELEMENT_TYPE_SYMBOL]: elementType } = slotElement;
          if (elementType !== typedState.components[slotName]) {
            slotElement[SLOT_ELEMENT_TYPE_SYMBOL] = typedState.components[slotName];
            console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" element type differs from "state.components.${slotName}",
${elementType} !== ${typedState.components[slotName]}.
Be sure to create slots properly by using "slot.always" or "slot.optional" with the correct elementType.`);
          }
        }
      }
    }
  }

  // ../../node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React21 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React20 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/utils/properties.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var toObjectMap = (...items) => {
    const result = {};
    for (const item of items) {
      const keys = Array.isArray(item) ? item : Object.keys(item);
      for (const key of keys) {
        result[key] = 1;
      }
    }
    return result;
  };
  var baseElementEvents = toObjectMap([
    "onAuxClick",
    "onAnimationEnd",
    "onAnimationStart",
    "onCopy",
    "onCut",
    "onPaste",
    "onCompositionEnd",
    "onCompositionStart",
    "onCompositionUpdate",
    "onFocus",
    "onFocusCapture",
    "onBlur",
    "onBlurCapture",
    "onChange",
    "onInput",
    "onSubmit",
    "onLoad",
    "onError",
    "onKeyDown",
    "onKeyDownCapture",
    "onKeyPress",
    "onKeyUp",
    "onAbort",
    "onCanPlay",
    "onCanPlayThrough",
    "onDurationChange",
    "onEmptied",
    "onEncrypted",
    "onEnded",
    "onLoadedData",
    "onLoadedMetadata",
    "onLoadStart",
    "onPause",
    "onPlay",
    "onPlaying",
    "onProgress",
    "onRateChange",
    "onSeeked",
    "onSeeking",
    "onStalled",
    "onSuspend",
    "onTimeUpdate",
    "onVolumeChange",
    "onWaiting",
    "onClick",
    "onClickCapture",
    "onContextMenu",
    "onDoubleClick",
    "onDrag",
    "onDragEnd",
    "onDragEnter",
    "onDragExit",
    "onDragLeave",
    "onDragOver",
    "onDragStart",
    "onDrop",
    "onMouseDown",
    "onMouseDownCapture",
    "onMouseEnter",
    "onMouseLeave",
    "onMouseMove",
    "onMouseOut",
    "onMouseOver",
    "onMouseUp",
    "onMouseUpCapture",
    "onSelect",
    "onTouchCancel",
    "onTouchEnd",
    "onTouchMove",
    "onTouchStart",
    "onScroll",
    "onWheel",
    "onPointerCancel",
    "onPointerDown",
    "onPointerEnter",
    "onPointerLeave",
    "onPointerMove",
    "onPointerOut",
    "onPointerOver",
    "onPointerUp",
    "onGotPointerCapture",
    "onLostPointerCapture"
  ]);
  var baseElementProperties = toObjectMap([
    "accessKey",
    "children",
    "className",
    "contentEditable",
    "dir",
    "draggable",
    "hidden",
    "htmlFor",
    "id",
    "lang",
    "ref",
    "role",
    "style",
    "tabIndex",
    "title",
    "translate",
    "spellCheck",
    "name"
  ]);
  var microdataProperties = toObjectMap([
    "itemID",
    "itemProp",
    "itemRef",
    "itemScope",
    "itemType"
  ]);
  var htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents, microdataProperties);
  var labelProperties = toObjectMap(htmlElementProperties, [
    "form"
  ]);
  var audioProperties = toObjectMap(htmlElementProperties, [
    "height",
    "loop",
    "muted",
    "preload",
    "src",
    "width"
  ]);
  var videoProperties = toObjectMap(audioProperties, [
    "poster"
  ]);
  var olProperties = toObjectMap(htmlElementProperties, [
    "start"
  ]);
  var liProperties = toObjectMap(htmlElementProperties, [
    "value"
  ]);
  var anchorProperties = toObjectMap(htmlElementProperties, [
    "download",
    "href",
    "hrefLang",
    "media",
    "rel",
    "target",
    "type"
  ]);
  var timeProperties = toObjectMap(htmlElementProperties, [
    "dateTime"
  ]);
  var buttonProperties = toObjectMap(htmlElementProperties, [
    "autoFocus",
    "disabled",
    "form",
    "formAction",
    "formEncType",
    "formMethod",
    "formNoValidate",
    "formTarget",
    "type",
    "value"
  ]);
  var inputProperties = toObjectMap(buttonProperties, [
    "accept",
    "alt",
    "autoCorrect",
    "autoCapitalize",
    "autoComplete",
    "checked",
    "dirname",
    "form",
    "height",
    "inputMode",
    "list",
    "max",
    "maxLength",
    "min",
    "minLength",
    "multiple",
    "pattern",
    "placeholder",
    "readOnly",
    "required",
    "src",
    "step",
    "size",
    "type",
    "value",
    "width"
  ]);
  var textAreaProperties = toObjectMap(buttonProperties, [
    "autoCapitalize",
    "cols",
    "dirname",
    "form",
    "maxLength",
    "placeholder",
    "readOnly",
    "required",
    "rows",
    "wrap"
  ]);
  var selectProperties = toObjectMap(buttonProperties, [
    "form",
    "multiple",
    "required"
  ]);
  var optionProperties = toObjectMap(htmlElementProperties, [
    "selected",
    "value"
  ]);
  var tableProperties = toObjectMap(htmlElementProperties, [
    "cellPadding",
    "cellSpacing"
  ]);
  var trProperties = htmlElementProperties;
  var thProperties = toObjectMap(htmlElementProperties, [
    "colSpan",
    "rowSpan",
    "scope"
  ]);
  var tdProperties = toObjectMap(htmlElementProperties, [
    "colSpan",
    "headers",
    "rowSpan",
    "scope"
  ]);
  var colGroupProperties = toObjectMap(htmlElementProperties, [
    "span"
  ]);
  var colProperties = toObjectMap(htmlElementProperties, [
    "span"
  ]);
  var fieldsetProperties = toObjectMap(htmlElementProperties, [
    "disabled",
    "form"
  ]);
  var formProperties = toObjectMap(htmlElementProperties, [
    "acceptCharset",
    "action",
    "encType",
    "encType",
    "method",
    "noValidate",
    "target"
  ]);
  var iframeProperties = toObjectMap(htmlElementProperties, [
    "allow",
    "allowFullScreen",
    "allowPaymentRequest",
    "allowTransparency",
    "csp",
    "height",
    "importance",
    "referrerPolicy",
    "sandbox",
    "src",
    "srcDoc",
    "width"
  ]);
  var imgProperties = toObjectMap(htmlElementProperties, [
    "alt",
    "crossOrigin",
    "height",
    "src",
    "srcSet",
    "useMap",
    "width"
  ]);
  var dialogProperties = toObjectMap(htmlElementProperties, [
    "open",
    "onCancel",
    "onClose"
  ]);
  function getNativeProps(props, allowedPropNames, excludedPropNames) {
    const isArray2 = Array.isArray(allowedPropNames);
    const result = {};
    const keys = Object.keys(props);
    for (const key of keys) {
      const isNativeProp = !isArray2 && allowedPropNames[key] || isArray2 && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0;
      if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
        result[key] = props[key];
      }
    }
    return result;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
  var nativeElementMap = {
    label: labelProperties,
    audio: audioProperties,
    video: videoProperties,
    ol: olProperties,
    li: liProperties,
    a: anchorProperties,
    button: buttonProperties,
    input: inputProperties,
    textarea: textAreaProperties,
    select: selectProperties,
    option: optionProperties,
    table: tableProperties,
    tr: trProperties,
    th: thProperties,
    td: tdProperties,
    colGroup: colGroupProperties,
    col: colProperties,
    fieldset: fieldsetProperties,
    form: formProperties,
    iframe: iframeProperties,
    img: imgProperties,
    time: timeProperties,
    dialog: dialogProperties
  };
  function getNativeElementProps(tagName, props, excludedPropNames) {
    const allowedPropNames = tagName && nativeElementMap[tagName] || htmlElementProperties;
    allowedPropNames.as = 1;
    return getNativeProps(props, allowedPropNames, excludedPropNames);
  }
  var getPartitionedNativeProps = ({ primarySlotTagName, props, excludedPropNames }) => {
    return {
      root: {
        style: props.style,
        className: props.className
      },
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      primary: getNativeElementProps(primarySlotTagName, props, [
        ...excludedPropNames || [],
        "style",
        "className"
      ])
    };
  };

  // ../../node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
  var getIntrinsicElementProps = (tagName, props, excludedPropNames) => {
    var _props_as;
    return getNativeElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : tagName, props, excludedPropNames);
  };

  // ../../node_modules/@fluentui/react-utilities/lib/utils/omit.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function omit(obj, exclusions) {
    const result = {};
    for (const key in obj) {
      if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {
        result[key] = obj[key];
      }
    }
    return result;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useAnimationFrame.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useBrowserTimer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React22 = __toESM(require_react());
  function useBrowserTimer(setTimer, cancelTimer) {
    const id = React22.useRef(void 0);
    const set = React22.useCallback((fn, delay) => {
      if (id.current !== void 0) {
        cancelTimer(id.current);
      }
      id.current = setTimer(fn, delay);
      return id.current;
    }, [
      cancelTimer,
      setTimer
    ]);
    const cancel = React22.useCallback(() => {
      if (id.current !== void 0) {
        cancelTimer(id.current);
        id.current = void 0;
      }
    }, [
      cancelTimer
    ]);
    React22.useEffect(() => cancel, [
      cancel
    ]);
    return [
      set,
      cancel
    ];
  }

  // ../../node_modules/@fluentui/react-shared-contexts/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeContext/ThemeContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React23 = __toESM(require_react());
  var ThemeContext2 = React23.createContext(void 0);
  var ThemeProvider = ThemeContext2.Provider;

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext/ThemeClassNameContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React24 = __toESM(require_react());
  var ThemeClassNameContext = React24.createContext(void 0);
  var themeClassNameContextDefaultVaue = "";
  var ThemeClassNameProvider = ThemeClassNameContext.Provider;
  function useThemeClassName() {
    var _React_useContext;
    return (_React_useContext = React24.useContext(ThemeClassNameContext)) !== null && _React_useContext !== void 0 ? _React_useContext : themeClassNameContextDefaultVaue;
  }

  // ../../node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext/TooltipContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React25 = __toESM(require_react());
  var TooltipVisibilityContext = React25.createContext(void 0);
  var TooltipVisibilityProvider = TooltipVisibilityContext.Provider;

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ProviderContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/ProviderContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React26 = __toESM(require_react());
  var ProviderContext = React26.createContext(void 0);
  var providerContextDefaultValue = {
    // eslint-disable-next-line @nx/workspace-no-restricted-globals -- expected ignore ( SSR friendly acquisition of globals )
    targetDocument: typeof document === "object" ? document : void 0,
    dir: "ltr"
  };
  var Provider = ProviderContext.Provider;
  function useFluent() {
    var _React_useContext;
    return (_React_useContext = React26.useContext(ProviderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : providerContextDefaultValue;
  }

  // ../../node_modules/@fluentui/react-shared-contexts/lib/OverridesContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/OverridesContext/OverridesContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React27 = __toESM(require_react());
  var OverridesContext = React27.createContext(void 0);
  var OverridesProvider = OverridesContext.Provider;
  function useOverrides() {
    var _React_useContext;
    return (_React_useContext = React27.useContext(OverridesContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {};
  }

  // ../../node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext/CustomStyleHooksContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React28 = __toESM(require_react());
  var CustomStyleHooksContext = React28.createContext(void 0);
  var noop2 = () => {
  };
  var CustomStyleHooksProvider = CustomStyleHooksContext.Provider;
  var useCustomStyleHook = (hook) => {
    var _React_useContext;
    var _React_useContext_hook;
    return (_React_useContext_hook = (_React_useContext = React28.useContext(CustomStyleHooksContext)) === null || _React_useContext === void 0 ? void 0 : _React_useContext[hook]) !== null && _React_useContext_hook !== void 0 ? _React_useContext_hook : noop2;
  };

  // ../../node_modules/@fluentui/react-shared-contexts/lib/PortalMountNodeContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React29 = __toESM(require_react());
  var PortalMountNodeContext = React29.createContext(void 0);
  var PortalMountNodeProvider = PortalMountNodeContext.Provider;
  function usePortalMountNode() {
    return React29.useContext(PortalMountNodeContext);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useAnimationFrame.js
  var setAnimationFrameNoop = (callback) => {
    callback(0);
    return 0;
  };
  var cancelAnimationFrameNoop = (handle) => handle;
  function useAnimationFrame() {
    const { targetDocument } = useFluent();
    const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    const setAnimationFrame = win ? win.requestAnimationFrame : setAnimationFrameNoop;
    const clearAnimationFrame = win ? win.cancelAnimationFrame : cancelAnimationFrameNoop;
    return useBrowserTimer(setAnimationFrame, clearAnimationFrame);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useControllableState.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React30 = __toESM(require_react());
  function isFactoryDispatch(newState) {
    return typeof newState === "function";
  }
  var useControllableState = (options) => {
    "use no memo";
    if (false) {
      if (options.state !== void 0 && options.defaultState !== void 0) {
        console.error(`@fluentui/react-utilities [useControllableState]:
A component must be either controlled or uncontrolled (specify either the state or the defaultState, but not both).
Decide between using a controlled or uncontrolled component and remove one of this props.
More info: https://reactjs.org/link/controlled-components
${new Error().stack}`);
      }
    }
    const [internalState, setInternalState] = React30.useState(() => {
      if (options.defaultState === void 0) {
        return options.initialState;
      }
      return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;
    });
    const stateValueRef = React30.useRef(options.state);
    React30.useEffect(() => {
      stateValueRef.current = options.state;
    }, [
      options.state
    ]);
    const setControlledState = React30.useCallback((newState) => {
      if (isFactoryDispatch(newState)) {
        newState(stateValueRef.current);
      }
    }, []);
    return useIsControlled(options.state) ? [
      options.state,
      setControlledState
    ] : [
      internalState,
      setInternalState
    ];
  };
  function isInitializer(value) {
    return typeof value === "function";
  }
  var useIsControlled = (controlledValue) => {
    "use no memo";
    const [isControlled] = React30.useState(() => controlledValue !== void 0);
    if (false) {
      React30.useEffect(() => {
        if (isControlled !== (controlledValue !== void 0)) {
          const error = new Error();
          const controlWarning = isControlled ? "a controlled value to be uncontrolled" : "an uncontrolled value to be controlled";
          const undefinedWarning = isControlled ? "defined to an undefined" : "undefined to a defined";
          console.error(`@fluentui/react-utilities [useControllableState]:
A component is changing ${controlWarning}. This is likely caused by the value changing from ${undefinedWarning} value, which should not happen.
Decide between using a controlled or uncontrolled input element for the lifetime of the component.
More info: https://reactjs.org/link/controlled-components
${error.stack}`);
        }
      }, [
        isControlled,
        controlledValue
      ]);
    }
    return isControlled;
  };

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React33 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React32 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/ssr/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/ssr/canUseDOM.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function canUseDOM2() {
    return (
      /* eslint-disable @nx/workspace-no-restricted-globals -- expected ignore ( SSR friendly acquisition of globals )*/
      typeof window !== "undefined" && !!(window.document && // eslint-disable-next-line @typescript-eslint/no-deprecated
      window.document.createElement)
    );
  }

  // ../../node_modules/@fluentui/react-utilities/lib/ssr/SSRContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React31 = __toESM(require_react());
  var defaultSSRContextValue = {
    current: 0
  };
  var SSRContext = /* @__PURE__ */ React31.createContext(void 0);
  function useSSRContext() {
    var _React_useContext;
    return (_React_useContext = React31.useContext(SSRContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSSRContextValue;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
  var useIsomorphicLayoutEffect2 = canUseDOM2() ? React32.useLayoutEffect : React32.useEffect;

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
  var useEventCallback = (fn) => {
    const callbackRef = React33.useRef(() => {
      throw new Error("Cannot call an event handler while rendering");
    });
    useIsomorphicLayoutEffect2(() => {
      callbackRef.current = fn;
    }, [
      fn
    ]);
    return React33.useCallback((...args) => {
      const callback = callbackRef.current;
      return callback(...args);
    }, [
      callbackRef
    ]);
  };

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useFirstMount.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React34 = __toESM(require_react());
  function useFirstMount() {
    const isFirst = React34.useRef(true);
    if (isFirst.current) {
      isFirst.current = false;
      return true;
    }
    return isFirst.current;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useForceUpdate.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React35 = __toESM(require_react());
  function useForceUpdate() {
    return React35.useReducer((x) => x + 1, 0)[1];
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useId.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React36 = __toESM(require_react());
  var IdPrefixContext = React36.createContext(void 0);
  var IdPrefixProvider = IdPrefixContext.Provider;
  function useIdPrefix() {
    return React36.useContext(IdPrefixContext) || "";
  }
  function useId4(prefix = "fui-", providedId) {
    "use no memo";
    const contextValue = useSSRContext();
    const idPrefix = useIdPrefix();
    const _useId = React36["useId"];
    if (_useId) {
      const generatedId = _useId();
      const escapedId = React36.useMemo(() => generatedId.replace(/:/g, ""), [
        generatedId
      ]);
      return providedId || `${idPrefix}${prefix}${escapedId}`;
    }
    return React36.useMemo(() => {
      if (providedId) {
        return providedId;
      }
      return `${idPrefix}${prefix}${++contextValue.current}`;
    }, [
      idPrefix,
      prefix,
      providedId,
      contextValue
    ]);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useMergedRefs.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React37 = __toESM(require_react());
  function useMergedRefs(...refs) {
    "use no memo";
    const mergedCallback = React37.useCallback(
      (value) => {
        mergedCallback.current = value;
        for (const ref of refs) {
          if (typeof ref === "string" && false) {
            console.error(`@fluentui/react-utilities [useMergedRefs]:
This hook does not support the usage of string refs. Please use React.useRef instead.

For more info on 'React.useRef', see https://react.dev/reference/react/useRef.
For more info on string refs, see https://react.dev/blog/2024/04/25/react-19-upgrade-guide#removed-string-refs.`);
          }
          if (typeof ref === "function") {
            ref(value);
          } else if (ref) {
            ref.current = value;
          }
        }
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps -- already exhaustive
      [
        ...refs
      ]
    );
    return mergedCallback;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useTimeout.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var setTimeoutNoop = (_callback) => -1;
  var clearTimeoutNoop = (_handle) => void 0;
  function useTimeout() {
    const { targetDocument } = useFluent();
    const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    const setTimerFn = win ? win.setTimeout : setTimeoutNoop;
    const clearTimerFn = win ? win.clearTimeout : clearTimeoutNoop;
    return useBrowserTimer(setTimerFn, clearTimerFn);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/utils/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/utils/mergeCallbacks.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function mergeCallbacks(callback1, callback2) {
    return (...args) => {
      callback1 === null || callback1 === void 0 ? void 0 : callback1(...args);
      callback2 === null || callback2 === void 0 ? void 0 : callback2(...args);
    };
  }

  // ../../node_modules/@fluentui/react-utilities/lib/utils/isHTMLElement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function isHTMLElement(element, options) {
    var _typedElement_ownerDocument;
    const typedElement = element;
    var _options_constructorName;
    return Boolean((typedElement === null || typedElement === void 0 ? void 0 : (_typedElement_ownerDocument = typedElement.ownerDocument) === null || _typedElement_ownerDocument === void 0 ? void 0 : _typedElement_ownerDocument.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options_constructorName = options === null || options === void 0 ? void 0 : options.constructorName) !== null && _options_constructorName !== void 0 ? _options_constructorName : "HTMLElement"]);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React39 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/isFluentTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React38 = __toESM(require_react());
  function isFluentTrigger(element) {
    return Boolean(element.type.isFluentTriggerComponent);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
  function applyTriggerPropsToChildren(children, triggerChildProps) {
    if (typeof children === "function") {
      return children(triggerChildProps);
    } else if (children) {
      return cloneTriggerTree(children, triggerChildProps);
    }
    return children || null;
  }
  function cloneTriggerTree(child, triggerProps) {
    if (!React39.isValidElement(child) || child.type === React39.Fragment) {
      throw new Error("A trigger element must be a single element for this component. Please ensure that you're not using React Fragments.");
    }
    if (isFluentTrigger(child)) {
      const grandchild = cloneTriggerTree(child.props.children, triggerProps);
      return React39.cloneElement(child, void 0, grandchild);
    } else {
      return React39.cloneElement(child, triggerProps);
    }
  }

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/getTriggerChild.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React40 = __toESM(require_react());
  function getTriggerChild(children) {
    if (!React40.isValidElement(children)) {
      return null;
    }
    return isFluentTrigger(children) ? getTriggerChild(
      // FIXME: This casting should be unnecessary as isFluentTrigger is a guard type method,
      // but for some reason it's failing on build
      children.props.children
    ) : children;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/isVirtualElement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function isVirtualElement(element) {
    return element && !!element._virtual;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js
  function getVirtualParent(child) {
    return isVirtualElement(child) ? child._virtual.parent || null : null;
  }
  function getParent(child, options = {}) {
    if (!child) {
      return null;
    }
    if (!options.skipVirtual) {
      const virtualParent = getVirtualParent(child);
      if (virtualParent) {
        return virtualParent;
      }
    }
    const parent = child.parentNode;
    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      return parent.host;
    }
    return parent;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/setVirtualParent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function setVirtualParent(child, parent) {
    if (!child) {
      return;
    }
    const virtualChild = child;
    if (!virtualChild._virtual) {
      virtualChild._virtual = {};
    }
    virtualChild._virtual.parent = parent;
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
  var React43 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/utils/createCompatSlotComponent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React41 = __toESM(require_react());
  function createCompatSlotComponent(type, props) {
    return {
      ...props,
      [SLOT_ELEMENT_TYPE_SYMBOL]: type
    };
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/utils/warnIfElementTypeIsInvalid.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React42 = __toESM(require_react());
  var import_react_is = __toESM(require_react_is());
  function warnIfElementTypeIsInvalid(type) {
    if (false) {
      console.error(`@fluentui/react-jsx-runtime:
Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: ${type}.

If this happened in a slot of Fluent UI component, you might be facing package resolution issues.
Please make sure you don't have multiple versions of "@fluentui/react-utilities" installed in your dependencies or sub-dependencies.
You can check this by searching up for matching entries in a lockfile produced by your package manager (yarn.lock, pnpm-lock.yaml or package-lock.json).`);
    }
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
  function createJSX(runtime, slotRuntime) {
    return function jsx4(type, overrideProps, key, source, self) {
      if (isSlot(overrideProps)) {
        return slotRuntime(createCompatSlotComponent(type, overrideProps), null, key, source, self);
      }
      if (isSlot(type)) {
        return slotRuntime(type, overrideProps, key, source, self);
      }
      warnIfElementTypeIsInvalid(type);
      return runtime(type, overrideProps, key, source, self);
    };
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React44 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/utils/getMetadataFromSlotComponent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function getMetadataFromSlotComponent(type) {
    const { as, [SLOT_CLASS_NAME_PROP_SYMBOL]: _classNameProp, [SLOT_ELEMENT_TYPE_SYMBOL]: baseElementType, [SLOT_RENDER_FUNCTION_SYMBOL]: renderFunction, ...propsWithoutMetadata } = type;
    const props = propsWithoutMetadata;
    const elementType = typeof baseElementType === "string" ? as !== null && as !== void 0 ? as : baseElementType : baseElementType;
    if (typeof elementType !== "string" && as) {
      props.as = as;
    }
    return {
      elementType,
      props,
      renderFunction
    };
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/utils/Runtime.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var ReactRuntime = __toESM(require_jsx_runtime());
  var Runtime = ReactRuntime;

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
  var jsxSlot = (type, overrideProps, key) => {
    const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
    const props = {
      ...slotProps,
      ...overrideProps
    };
    if (renderFunction) {
      return Runtime.jsx(React44.Fragment, {
        children: renderFunction(elementType, props)
      }, key);
    }
    return Runtime.jsx(elementType, props, key);
  };

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxsSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React45 = __toESM(require_react());
  var jsxsSlot = (type, overrideProps, key) => {
    const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
    const props = {
      ...slotProps,
      ...overrideProps
    };
    if (renderFunction) {
      return Runtime.jsx(React45.Fragment, {
        children: renderFunction(elementType, {
          ...props,
          children: Runtime.jsxs(React45.Fragment, {
            children: props.children
          }, void 0)
        })
      }, key);
    }
    return Runtime.jsxs(elementType, props, key);
  };

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx-runtime.js
  var import_react19 = __toESM(require_react());
  var jsx = createJSX(Runtime.jsx, jsxSlot);
  var jsxs = createJSX(Runtime.jsxs, jsxsSlot);

  // ../../node_modules/@fluentui/react-icons/lib/providers.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-icons/lib/contexts/IconDirectionContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React46 = __toESM(require_react());
  var IconDirectionContext = React46.createContext(void 0);
  var IconDirectionContextDefaultValue = {};
  var IconDirectionContextProvider = IconDirectionContext.Provider;
  var useIconContext = () => React46.useContext(IconDirectionContext) ? React46.useContext(IconDirectionContext) : IconDirectionContextDefaultValue;

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/renderFluentProvider.js
  var renderFluentProvider_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx(Provider, {
      value: contextValues.provider,
      children: /* @__PURE__ */ jsx(ThemeProvider, {
        value: contextValues.theme,
        children: /* @__PURE__ */ jsx(ThemeClassNameProvider, {
          value: contextValues.themeClassName,
          children: /* @__PURE__ */ jsx(CustomStyleHooksProvider, {
            value: contextValues.customStyleHooks_unstable,
            children: /* @__PURE__ */ jsx(TooltipVisibilityProvider, {
              value: contextValues.tooltip,
              children: /* @__PURE__ */ jsx(TextDirectionProvider, {
                dir: contextValues.textDirection,
                children: /* @__PURE__ */ jsx(IconDirectionContextProvider, {
                  value: contextValues.iconDirection,
                  children: /* @__PURE__ */ jsx(OverridesProvider, {
                    value: contextValues.overrides_unstable,
                    children: /* @__PURE__ */ jsxs(state.root, {
                      children: [
                        canUseDOM2() ? null : /* @__PURE__ */ jsx("style", {
                          // Using dangerous HTML because react can escape characters
                          // which can lead to invalid CSS.
                          // eslint-disable-next-line react/no-danger
                          dangerouslySetInnerHTML: {
                            __html: state.serverStyleProps.cssRule
                          },
                          ...state.serverStyleProps.attributes
                        }),
                        state.root.children
                      ]
                    })
                  })
                })
              })
            })
          })
        })
      })
    });
  };

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabster/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useArrowNavigationGroup.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/tabster/dist/tabster.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/keyborg/dist/esm/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var _canUseWeakRef = typeof WeakRef !== "undefined";
  var WeakRefInstance = class {
    constructor(instance) {
      if (_canUseWeakRef && typeof instance === "object") {
        this._weakRef = new WeakRef(instance);
      } else {
        this._instance = instance;
      }
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}
     */
    deref() {
      var _a, _b;
      let instance;
      if (this._weakRef) {
        instance = (_a = this._weakRef) == null ? void 0 : _a.deref();
        if (!instance) {
          delete this._weakRef;
        }
      } else {
        instance = this._instance;
        if ((_b = instance == null ? void 0 : instance.isDisposed) == null ? void 0 : _b.call(instance)) {
          delete this._instance;
        }
      }
      return instance;
    }
  };
  var KEYBORG_FOCUSIN = "keyborg:focusin";
  var KEYBORG_FOCUSOUT = "keyborg:focusout";
  function canOverrideNativeFocus(win) {
    const HTMLElement = win.HTMLElement;
    const origFocus = HTMLElement.prototype.focus;
    let isCustomFocusCalled = false;
    HTMLElement.prototype.focus = function focus() {
      isCustomFocusCalled = true;
    };
    const btn = win.document.createElement("button");
    btn.focus();
    HTMLElement.prototype.focus = origFocus;
    return isCustomFocusCalled;
  }
  var _canOverrideNativeFocus = false;
  function nativeFocus(element) {
    const focus = element.focus;
    if (focus.__keyborgNativeFocus) {
      focus.__keyborgNativeFocus.call(element);
    } else {
      element.focus();
    }
  }
  function setupFocusEvent(win) {
    const kwin = win;
    if (!_canOverrideNativeFocus) {
      _canOverrideNativeFocus = canOverrideNativeFocus(kwin);
    }
    const origFocus = kwin.HTMLElement.prototype.focus;
    if (origFocus.__keyborgNativeFocus) {
      return;
    }
    kwin.HTMLElement.prototype.focus = focus;
    const shadowTargets = /* @__PURE__ */ new Set();
    const focusOutHandler = (e) => {
      const target = e.target;
      if (!target) {
        return;
      }
      const event = new CustomEvent(KEYBORG_FOCUSOUT, {
        cancelable: true,
        bubbles: true,
        // Allows the event to bubble past an open shadow root
        composed: true,
        detail: {
          originalEvent: e
        }
      });
      target.dispatchEvent(event);
    };
    const focusInHandler = (e) => {
      const target = e.target;
      if (!target) {
        return;
      }
      let node = e.composedPath()[0];
      const currentShadows = /* @__PURE__ */ new Set();
      while (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          currentShadows.add(node);
          node = node.host;
        } else {
          node = node.parentNode;
        }
      }
      for (const shadowRootWeakRef of shadowTargets) {
        const shadowRoot = shadowRootWeakRef.deref();
        if (!shadowRoot || !currentShadows.has(shadowRoot)) {
          shadowTargets.delete(shadowRootWeakRef);
          if (shadowRoot) {
            shadowRoot.removeEventListener("focusin", focusInHandler, true);
            shadowRoot.removeEventListener("focusout", focusOutHandler, true);
          }
        }
      }
      onFocusIn(target, e.relatedTarget || void 0);
    };
    const onFocusIn = (target, relatedTarget, originalEvent) => {
      var _a;
      const shadowRoot = target.shadowRoot;
      if (shadowRoot) {
        for (const shadowRootWeakRef of shadowTargets) {
          if (shadowRootWeakRef.deref() === shadowRoot) {
            return;
          }
        }
        shadowRoot.addEventListener("focusin", focusInHandler, true);
        shadowRoot.addEventListener("focusout", focusOutHandler, true);
        shadowTargets.add(new WeakRefInstance(shadowRoot));
        return;
      }
      const details = {
        relatedTarget,
        originalEvent
      };
      const event = new CustomEvent(KEYBORG_FOCUSIN, {
        cancelable: true,
        bubbles: true,
        // Allows the event to bubble past an open shadow root
        composed: true,
        detail: details
      });
      event.details = details;
      if (_canOverrideNativeFocus || data2.lastFocusedProgrammatically) {
        details.isFocusedProgrammatically = target === ((_a = data2.lastFocusedProgrammatically) == null ? void 0 : _a.deref());
        data2.lastFocusedProgrammatically = void 0;
      }
      target.dispatchEvent(event);
    };
    const data2 = kwin.__keyborgData = {
      focusInHandler,
      focusOutHandler,
      shadowTargets
    };
    kwin.document.addEventListener(
      "focusin",
      kwin.__keyborgData.focusInHandler,
      true
    );
    kwin.document.addEventListener(
      "focusout",
      kwin.__keyborgData.focusOutHandler,
      true
    );
    function focus() {
      const keyborgNativeFocusEvent = kwin.__keyborgData;
      if (keyborgNativeFocusEvent) {
        keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(
          this
        );
      }
      return origFocus.apply(this, arguments);
    }
    let activeElement = kwin.document.activeElement;
    while (activeElement && activeElement.shadowRoot) {
      onFocusIn(activeElement);
      activeElement = activeElement.shadowRoot.activeElement;
    }
    focus.__keyborgNativeFocus = origFocus;
  }
  function disposeFocusEvent(win) {
    const kwin = win;
    const proto = kwin.HTMLElement.prototype;
    const origFocus = proto.focus.__keyborgNativeFocus;
    const keyborgNativeFocusEvent = kwin.__keyborgData;
    if (keyborgNativeFocusEvent) {
      kwin.document.removeEventListener(
        "focusin",
        keyborgNativeFocusEvent.focusInHandler,
        true
      );
      kwin.document.removeEventListener(
        "focusout",
        keyborgNativeFocusEvent.focusOutHandler,
        true
      );
      for (const shadowRootWeakRef of keyborgNativeFocusEvent.shadowTargets) {
        const shadowRoot = shadowRootWeakRef.deref();
        if (shadowRoot) {
          shadowRoot.removeEventListener(
            "focusin",
            keyborgNativeFocusEvent.focusInHandler,
            true
          );
          shadowRoot.removeEventListener(
            "focusout",
            keyborgNativeFocusEvent.focusOutHandler,
            true
          );
        }
      }
      keyborgNativeFocusEvent.shadowTargets.clear();
      delete kwin.__keyborgData;
    }
    if (origFocus) {
      proto.focus = origFocus;
    }
  }
  var _dismissTimeout = 500;
  var _lastId = 0;
  var KeyborgCore = class {
    constructor(win, props) {
      this._isNavigatingWithKeyboard_DO_NOT_USE = false;
      this._onFocusIn = (e) => {
        if (this._isMouseOrTouchUsedTimer) {
          return;
        }
        if (this.isNavigatingWithKeyboard) {
          return;
        }
        const details = e.detail;
        if (!details.relatedTarget) {
          return;
        }
        if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === void 0) {
          return;
        }
        this.isNavigatingWithKeyboard = true;
      };
      this._onMouseDown = (e) => {
        if (e.buttons === 0 || e.clientX === 0 && e.clientY === 0 && e.screenX === 0 && e.screenY === 0) {
          return;
        }
        this._onMouseOrTouch();
      };
      this._onMouseOrTouch = () => {
        const win2 = this._win;
        if (win2) {
          if (this._isMouseOrTouchUsedTimer) {
            win2.clearTimeout(this._isMouseOrTouchUsedTimer);
          }
          this._isMouseOrTouchUsedTimer = win2.setTimeout(() => {
            delete this._isMouseOrTouchUsedTimer;
          }, 1e3);
        }
        this.isNavigatingWithKeyboard = false;
      };
      this._onKeyDown = (e) => {
        const isNavigatingWithKeyboard = this.isNavigatingWithKeyboard;
        if (isNavigatingWithKeyboard) {
          if (this._shouldDismissKeyboardNavigation(e)) {
            this._scheduleDismiss();
          }
        } else {
          if (this._shouldTriggerKeyboardNavigation(e)) {
            this.isNavigatingWithKeyboard = true;
          }
        }
      };
      this.id = "c" + ++_lastId;
      this._win = win;
      const doc = win.document;
      if (props) {
        const triggerKeys = props.triggerKeys;
        const dismissKeys = props.dismissKeys;
        if (triggerKeys == null ? void 0 : triggerKeys.length) {
          this._triggerKeys = new Set(triggerKeys);
        }
        if (dismissKeys == null ? void 0 : dismissKeys.length) {
          this._dismissKeys = new Set(dismissKeys);
        }
      }
      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.addEventListener("mousedown", this._onMouseDown, true);
      win.addEventListener("keydown", this._onKeyDown, true);
      doc.addEventListener("touchstart", this._onMouseOrTouch, true);
      doc.addEventListener("touchend", this._onMouseOrTouch, true);
      doc.addEventListener("touchcancel", this._onMouseOrTouch, true);
      setupFocusEvent(win);
    }
    get isNavigatingWithKeyboard() {
      return this._isNavigatingWithKeyboard_DO_NOT_USE;
    }
    set isNavigatingWithKeyboard(val) {
      if (this._isNavigatingWithKeyboard_DO_NOT_USE !== val) {
        this._isNavigatingWithKeyboard_DO_NOT_USE = val;
        this.update();
      }
    }
    dispose() {
      const win = this._win;
      if (win) {
        if (this._isMouseOrTouchUsedTimer) {
          win.clearTimeout(this._isMouseOrTouchUsedTimer);
          this._isMouseOrTouchUsedTimer = void 0;
        }
        if (this._dismissTimer) {
          win.clearTimeout(this._dismissTimer);
          this._dismissTimer = void 0;
        }
        disposeFocusEvent(win);
        const doc = win.document;
        doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
        doc.removeEventListener("mousedown", this._onMouseDown, true);
        win.removeEventListener("keydown", this._onKeyDown, true);
        doc.removeEventListener("touchstart", this._onMouseOrTouch, true);
        doc.removeEventListener("touchend", this._onMouseOrTouch, true);
        doc.removeEventListener("touchcancel", this._onMouseOrTouch, true);
        delete this._win;
      }
    }
    isDisposed() {
      return !!this._win;
    }
    /**
     * Updates all keyborg instances with the keyboard navigation state
     */
    update() {
      var _a, _b;
      const keyborgs = (_b = (_a = this._win) == null ? void 0 : _a.__keyborg) == null ? void 0 : _b.refs;
      if (keyborgs) {
        for (const id of Object.keys(keyborgs)) {
          Keyborg.update(keyborgs[id], this.isNavigatingWithKeyboard);
        }
      }
    }
    /**
     * @returns whether the keyboard event should trigger keyboard navigation mode
     */
    _shouldTriggerKeyboardNavigation(e) {
      var _a;
      if (e.key === "Tab") {
        return true;
      }
      const activeElement = (_a = this._win) == null ? void 0 : _a.document.activeElement;
      const isTriggerKey = !this._triggerKeys || this._triggerKeys.has(e.keyCode);
      const isEditable = activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.isContentEditable);
      return isTriggerKey && !isEditable;
    }
    /**
     * @returns whether the keyboard event should dismiss keyboard navigation mode
     */
    _shouldDismissKeyboardNavigation(e) {
      var _a;
      return (_a = this._dismissKeys) == null ? void 0 : _a.has(e.keyCode);
    }
    _scheduleDismiss() {
      const win = this._win;
      if (win) {
        if (this._dismissTimer) {
          win.clearTimeout(this._dismissTimer);
          this._dismissTimer = void 0;
        }
        const was = win.document.activeElement;
        this._dismissTimer = win.setTimeout(() => {
          this._dismissTimer = void 0;
          const cur = win.document.activeElement;
          if (was && cur && was === cur) {
            this.isNavigatingWithKeyboard = false;
          }
        }, _dismissTimeout);
      }
    }
  };
  var Keyborg = class _Keyborg {
    constructor(win, props) {
      this._cb = [];
      this._id = "k" + ++_lastId;
      this._win = win;
      const current = win.__keyborg;
      if (current) {
        this._core = current.core;
        current.refs[this._id] = this;
      } else {
        this._core = new KeyborgCore(win, props);
        win.__keyborg = {
          core: this._core,
          refs: { [this._id]: this }
        };
      }
    }
    static create(win, props) {
      return new _Keyborg(win, props);
    }
    static dispose(instance) {
      instance.dispose();
    }
    /**
     * Updates all subscribed callbacks with the keyboard navigation state
     */
    static update(instance, isNavigatingWithKeyboard) {
      instance._cb.forEach((callback) => callback(isNavigatingWithKeyboard));
    }
    dispose() {
      var _a;
      const current = (_a = this._win) == null ? void 0 : _a.__keyborg;
      if (current == null ? void 0 : current.refs[this._id]) {
        delete current.refs[this._id];
        if (Object.keys(current.refs).length === 0) {
          current.core.dispose();
          delete this._win.__keyborg;
        }
      } else if (false) {
        console.error(
          `Keyborg instance ${this._id} is being disposed incorrectly.`
        );
      }
      this._cb = [];
      delete this._core;
      delete this._win;
    }
    /**
     * @returns Whether the user is navigating with keyboard
     */
    isNavigatingWithKeyboard() {
      var _a;
      return !!((_a = this._core) == null ? void 0 : _a.isNavigatingWithKeyboard);
    }
    /**
     * @param callback - Called when the keyboard navigation state changes
     */
    subscribe(callback) {
      this._cb.push(callback);
    }
    /**
     * @param callback - Registered with subscribe
     */
    unsubscribe(callback) {
      const index = this._cb.indexOf(callback);
      if (index >= 0) {
        this._cb.splice(index, 1);
      }
    }
    /**
     * Manually set the keyboard navigtion state
     */
    setVal(isNavigatingWithKeyboard) {
      if (this._core) {
        this._core.isNavigatingWithKeyboard = isNavigatingWithKeyboard;
      }
    }
  };
  function createKeyborg(win, props) {
    return Keyborg.create(win, props);
  }
  function disposeKeyborg(instance) {
    Keyborg.dispose(instance);
  }

  // ../../node_modules/tabster/dist/tabster.esm.js
  var TABSTER_ATTRIBUTE_NAME = "data-tabster";
  var TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME = "data-tabster-dummy";
  var FOCUSABLE_SELECTOR = /* @__PURE__ */ ["a[href]", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "*[tabindex]", "*[contenteditable]", "details > summary", "audio[controls]", "video[controls]"].join(", ");
  var AsyncFocusSources = {
    EscapeGroupper: 1,
    Restorer: 2,
    Deloser: 3
  };
  var Visibilities = {
    Invisible: 0,
    PartiallyVisible: 1,
    Visible: 2
  };
  var RestorerTypes = {
    Source: 0,
    Target: 1
  };
  var MoverDirections = {
    Both: 0,
    // Default, both left/up keys move to the previous, right/down move to the next.
    Vertical: 1,
    // Only up/down arrows move to the next/previous.
    Horizontal: 2,
    // Only left/right arrows move to the next/previous.
    Grid: 3,
    // Two-dimentional movement depending on the visual placement.
    GridLinear: 4
    // Two-dimentional movement depending on the visual placement. Allows linear movement.
  };
  var MoverKeys = {
    ArrowUp: 1,
    ArrowDown: 2,
    ArrowLeft: 3,
    ArrowRight: 4,
    PageUp: 5,
    PageDown: 6,
    Home: 7,
    End: 8
  };
  var GroupperTabbabilities = {
    Unlimited: 0,
    Limited: 1,
    // The tabbability is limited to the container and explicit Enter is needed to go inside.
    LimitedTrapFocus: 2
    // The focus is limited as above, plus trapped when inside.
  };
  var GroupperMoveFocusActions = {
    Enter: 1,
    Escape: 2
  };
  var SysDummyInputsPositions = {
    Auto: 0,
    // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.
    Inside: 1,
    // Tabster will always place dummy inputs inside the container.
    Outside: 2
    // Tabster will always place dummy inputs outside of the container.
  };
  function getTabsterOnElement(tabster, element) {
    var _a;
    return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;
  }
  function updateTabsterByAttribute(tabster, element, dispose) {
    var _a, _b;
    const newAttrValue = dispose || tabster._noop ? void 0 : element.getAttribute(TABSTER_ATTRIBUTE_NAME);
    let entry = tabster.storageEntry(element);
    let newAttr;
    if (newAttrValue) {
      if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {
        try {
          const newValue = JSON.parse(newAttrValue);
          if (typeof newValue !== "object") {
            throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);
          }
          newAttr = {
            string: newAttrValue,
            object: newValue
          };
        } catch (e) {
          if (false) {
            console.error(`data-tabster attribute error: ${e}`, element);
          }
        }
      } else {
        return;
      }
    } else if (!entry) {
      return;
    }
    if (!entry) {
      entry = tabster.storageEntry(element, true);
    }
    if (!entry.tabster) {
      entry.tabster = {};
    }
    const tabsterOnElement = entry.tabster || {};
    const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};
    const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};
    for (const key of Object.keys(oldTabsterProps)) {
      if (!newTabsterProps[key]) {
        if (key === "root") {
          const root = tabsterOnElement[key];
          if (root) {
            tabster.root.onRoot(root, true);
          }
        }
        switch (key) {
          case "deloser":
          case "root":
          case "groupper":
          case "modalizer":
          case "restorer":
          case "mover":
            const part = tabsterOnElement[key];
            if (part) {
              part.dispose();
              delete tabsterOnElement[key];
            }
            break;
          case "observed":
            delete tabsterOnElement[key];
            if (tabster.observedElement) {
              tabster.observedElement.onObservedElementUpdate(element);
            }
            break;
          case "focusable":
          case "outline":
          case "uncontrolled":
          case "sys":
            delete tabsterOnElement[key];
            break;
        }
      }
    }
    for (const key of Object.keys(newTabsterProps)) {
      const sys = newTabsterProps.sys;
      switch (key) {
        case "deloser":
          if (tabsterOnElement.deloser) {
            tabsterOnElement.deloser.setProps(newTabsterProps.deloser);
          } else {
            if (tabster.deloser) {
              tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);
            } else if (false) {
              console.error("Deloser API used before initialization, please call `getDeloser()`");
            }
          }
          break;
        case "root":
          if (tabsterOnElement.root) {
            tabsterOnElement.root.setProps(newTabsterProps.root);
          } else {
            tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);
          }
          tabster.root.onRoot(tabsterOnElement.root);
          break;
        case "modalizer":
          if (tabsterOnElement.modalizer) {
            tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);
          } else {
            if (tabster.modalizer) {
              tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element, newTabsterProps.modalizer, sys);
            } else if (false) {
              console.error("Modalizer API used before initialization, please call `getModalizer()`");
            }
          }
          break;
        case "restorer":
          if (tabsterOnElement.restorer) {
            tabsterOnElement.restorer.setProps(newTabsterProps.restorer);
          } else {
            if (tabster.restorer) {
              if (newTabsterProps.restorer) {
                tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);
              }
            } else if (false) {
              console.error("Restorer API used before initialization, please call `getRestorer()`");
            }
          }
          break;
        case "focusable":
          tabsterOnElement.focusable = newTabsterProps.focusable;
          break;
        case "groupper":
          if (tabsterOnElement.groupper) {
            tabsterOnElement.groupper.setProps(newTabsterProps.groupper);
          } else {
            if (tabster.groupper) {
              tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);
            } else if (false) {
              console.error("Groupper API used before initialization, please call `getGroupper()`");
            }
          }
          break;
        case "mover":
          if (tabsterOnElement.mover) {
            tabsterOnElement.mover.setProps(newTabsterProps.mover);
          } else {
            if (tabster.mover) {
              tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);
            } else if (false) {
              console.error("Mover API used before initialization, please call `getMover()`");
            }
          }
          break;
        case "observed":
          if (tabster.observedElement) {
            tabsterOnElement.observed = newTabsterProps.observed;
            tabster.observedElement.onObservedElementUpdate(element);
          } else if (false) {
            console.error("ObservedElement API used before initialization, please call `getObservedElement()`");
          }
          break;
        case "uncontrolled":
          tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;
          break;
        case "outline":
          if (tabster.outline) {
            tabsterOnElement.outline = newTabsterProps.outline;
          } else if (false) {
            console.error("Outline API used before initialization, please call `getOutline()`");
          }
          break;
        case "sys":
          tabsterOnElement.sys = newTabsterProps.sys;
          break;
        default:
          console.error(`Unknown key '${key}' in data-tabster attribute value.`);
      }
    }
    if (newAttr) {
      entry.attr = newAttr;
    } else {
      if (Object.keys(tabsterOnElement).length === 0) {
        delete entry.tabster;
        delete entry.attr;
      }
      tabster.storageEntry(element, false);
    }
  }
  var TabsterFocusInEventName = "tabster:focusin";
  var TabsterFocusOutEventName = "tabster:focusout";
  var TabsterMoveFocusEventName = "tabster:movefocus";
  var ModalizerActiveEventName = "tabster:modalizer:active";
  var ModalizerInactiveEventName = "tabster:modalizer:inactive";
  var MoverStateEventName = "tabster:mover:state";
  var MoverMoveFocusEventName = "tabster:mover:movefocus";
  var MoverMemorizedElementEventName = "tabster:mover:memorized-element";
  var GroupperMoveFocusEventName = "tabster:groupper:movefocus";
  var RestorerRestoreFocusEventName = "tabster:restorer:restore-focus";
  var RootFocusEventName = "tabster:root:focus";
  var RootBlurEventName = "tabster:root:blur";
  var CustomEvent_ = typeof CustomEvent !== "undefined" ? CustomEvent : function() {
  };
  var TabsterCustomEvent = class extends CustomEvent_ {
    constructor(type, detail) {
      super(type, {
        bubbles: true,
        cancelable: true,
        composed: true,
        detail
      });
      this.details = detail;
    }
  };
  var TabsterFocusInEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(TabsterFocusInEventName, detail);
    }
  };
  var TabsterFocusOutEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(TabsterFocusOutEventName, detail);
    }
  };
  var TabsterMoveFocusEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(TabsterMoveFocusEventName, detail);
    }
  };
  var MoverStateEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(MoverStateEventName, detail);
    }
  };
  var ModalizerActiveEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(ModalizerActiveEventName, detail);
    }
  };
  var ModalizerInactiveEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(ModalizerInactiveEventName, detail);
    }
  };
  var RestorerRestoreFocusEvent = class extends TabsterCustomEvent {
    constructor() {
      super(RestorerRestoreFocusEventName);
    }
  };
  var RootFocusEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(RootFocusEventName, detail);
    }
  };
  var RootBlurEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(RootBlurEventName, detail);
    }
  };
  var _createMutationObserver = (callback) => new MutationObserver(callback);
  var _createTreeWalker = (doc, root, whatToShow, filter) => doc.createTreeWalker(root, whatToShow, filter);
  var _getParentNode = (node) => node ? node.parentNode : null;
  var _getParentElement = (element) => element ? element.parentElement : null;
  var _nodeContains = (parent, child) => !!(child && (parent === null || parent === void 0 ? void 0 : parent.contains(child)));
  var _getActiveElement = (doc) => doc.activeElement;
  var _querySelector = (element, selector) => element.querySelector(selector);
  var _querySelectorAll = (element, selector) => Array.prototype.slice.call(element.querySelectorAll(selector), 0);
  var _getElementById = (doc, id) => doc.getElementById(id);
  var _getFirstChild = (node) => (node === null || node === void 0 ? void 0 : node.firstChild) || null;
  var _getLastChild = (node) => (node === null || node === void 0 ? void 0 : node.lastChild) || null;
  var _getNextSibling = (node) => (node === null || node === void 0 ? void 0 : node.nextSibling) || null;
  var _getPreviousSibling = (node) => (node === null || node === void 0 ? void 0 : node.previousSibling) || null;
  var _getFirstElementChild = (element) => (element === null || element === void 0 ? void 0 : element.firstElementChild) || null;
  var _getLastElementChild = (element) => (element === null || element === void 0 ? void 0 : element.lastElementChild) || null;
  var _getNextElementSibling = (element) => (element === null || element === void 0 ? void 0 : element.nextElementSibling) || null;
  var _getPreviousElementSibling = (element) => (element === null || element === void 0 ? void 0 : element.previousElementSibling) || null;
  var _appendChild = (parent, child) => parent.appendChild(child);
  var _insertBefore = (parent, child, referenceChild) => parent.insertBefore(child, referenceChild);
  var _getSelection = (ref) => {
    var _a;
    return ((_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.getSelection()) || null;
  };
  var _getElementsByName = (referenceElement, name) => referenceElement.ownerDocument.getElementsByName(name);
  var dom = {
    createMutationObserver: _createMutationObserver,
    createTreeWalker: _createTreeWalker,
    getParentNode: _getParentNode,
    getParentElement: _getParentElement,
    nodeContains: _nodeContains,
    getActiveElement: _getActiveElement,
    querySelector: _querySelector,
    querySelectorAll: _querySelectorAll,
    getElementById: _getElementById,
    getFirstChild: _getFirstChild,
    getLastChild: _getLastChild,
    getNextSibling: _getNextSibling,
    getPreviousSibling: _getPreviousSibling,
    getFirstElementChild: _getFirstElementChild,
    getLastElementChild: _getLastElementChild,
    getNextElementSibling: _getNextElementSibling,
    getPreviousElementSibling: _getPreviousElementSibling,
    appendChild: _appendChild,
    insertBefore: _insertBefore,
    getSelection: _getSelection,
    getElementsByName: _getElementsByName
  };
  function setDOMAPI(domapi) {
    for (const key of Object.keys(domapi)) {
      dom[key] = domapi[key];
    }
  }
  var _isBrokenIE11;
  var _DOMRect = typeof DOMRect !== "undefined" ? DOMRect : class {
    constructor(x, y, width, height) {
      this.left = x || 0;
      this.top = y || 0;
      this.right = (x || 0) + (width || 0);
      this.bottom = (y || 0) + (height || 0);
    }
  };
  var _uidCounter = 0;
  try {
    document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);
    _isBrokenIE11 = false;
  } catch (e) {
    _isBrokenIE11 = true;
  }
  var _updateDummyInputsTimeout = 100;
  function getInstanceContext(getWindow) {
    const win = getWindow();
    let ctx = win.__tabsterInstanceContext;
    if (!ctx) {
      ctx = {
        elementByUId: {},
        basics: {
          Promise: win.Promise || void 0,
          WeakRef: win.WeakRef || void 0
        },
        containerBoundingRectCache: {},
        lastContainerBoundingRectCacheId: 0,
        fakeWeakRefs: [],
        fakeWeakRefsStarted: false
      };
      win.__tabsterInstanceContext = ctx;
    }
    return ctx;
  }
  function disposeInstanceContext(win) {
    const ctx = win.__tabsterInstanceContext;
    if (ctx) {
      ctx.elementByUId = {};
      delete ctx.WeakRef;
      ctx.containerBoundingRectCache = {};
      if (ctx.containerBoundingRectCacheTimer) {
        win.clearTimeout(ctx.containerBoundingRectCacheTimer);
      }
      if (ctx.fakeWeakRefsTimer) {
        win.clearTimeout(ctx.fakeWeakRefsTimer);
      }
      ctx.fakeWeakRefs = [];
      delete win.__tabsterInstanceContext;
    }
  }
  function createWeakMap(win) {
    const ctx = win.__tabsterInstanceContext;
    return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();
  }
  function hasSubFocusable(element) {
    return !!element.querySelector(FOCUSABLE_SELECTOR);
  }
  var FakeWeakRef = class {
    constructor(target) {
      this._target = target;
    }
    deref() {
      return this._target;
    }
    static cleanup(fwr, forceRemove) {
      if (!fwr._target) {
        return true;
      }
      if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {
        delete fwr._target;
        return true;
      }
      return false;
    }
  };
  var WeakHTMLElement = class {
    constructor(getWindow, element, data2) {
      const context = getInstanceContext(getWindow);
      let ref;
      if (context.WeakRef) {
        ref = new context.WeakRef(element);
      } else {
        ref = new FakeWeakRef(element);
        context.fakeWeakRefs.push(ref);
      }
      this._ref = ref;
      this._data = data2;
    }
    get() {
      const ref = this._ref;
      let element;
      if (ref) {
        element = ref.deref();
        if (!element) {
          delete this._ref;
        }
      }
      return element;
    }
    getData() {
      return this._data;
    }
  };
  function cleanupFakeWeakRefs(getWindow, forceRemove) {
    const context = getInstanceContext(getWindow);
    context.fakeWeakRefs = context.fakeWeakRefs.filter((e) => !FakeWeakRef.cleanup(e, forceRemove));
  }
  function startFakeWeakRefsCleanup(getWindow) {
    const context = getInstanceContext(getWindow);
    if (!context.fakeWeakRefsStarted) {
      context.fakeWeakRefsStarted = true;
      context.WeakRef = getWeakRef(context);
    }
    if (!context.fakeWeakRefsTimer) {
      context.fakeWeakRefsTimer = getWindow().setTimeout(() => {
        context.fakeWeakRefsTimer = void 0;
        cleanupFakeWeakRefs(getWindow);
        startFakeWeakRefsCleanup(getWindow);
      }, 2 * 60 * 1e3);
    }
  }
  function stopFakeWeakRefsCleanupAndClearStorage(getWindow) {
    const context = getInstanceContext(getWindow);
    context.fakeWeakRefsStarted = false;
    if (context.fakeWeakRefsTimer) {
      getWindow().clearTimeout(context.fakeWeakRefsTimer);
      context.fakeWeakRefsTimer = void 0;
      context.fakeWeakRefs = [];
    }
  }
  function createElementTreeWalker(doc, root, acceptNode) {
    if (root.nodeType !== Node.ELEMENT_NODE) {
      return void 0;
    }
    const filter = _isBrokenIE11 ? acceptNode : {
      acceptNode
    };
    return dom.createTreeWalker(
      doc,
      root,
      NodeFilter.SHOW_ELEMENT,
      filter,
      // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.
      false
      /* Last argument is not optional for IE11! */
    );
  }
  function getBoundingRect(getWindow, element) {
    let cacheId = element.__tabsterCacheId;
    const context = getInstanceContext(getWindow);
    const cached = cacheId ? context.containerBoundingRectCache[cacheId] : void 0;
    if (cached) {
      return cached.rect;
    }
    const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;
    if (!scrollingElement) {
      return new _DOMRect();
    }
    let left = 0;
    let top = 0;
    let right = scrollingElement.clientWidth;
    let bottom = scrollingElement.clientHeight;
    if (element !== scrollingElement) {
      const r = element.getBoundingClientRect();
      left = Math.max(left, r.left);
      top = Math.max(top, r.top);
      right = Math.min(right, r.right);
      bottom = Math.min(bottom, r.bottom);
    }
    const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);
    if (!cacheId) {
      cacheId = "r-" + ++context.lastContainerBoundingRectCacheId;
      element.__tabsterCacheId = cacheId;
    }
    context.containerBoundingRectCache[cacheId] = {
      rect,
      element
    };
    if (!context.containerBoundingRectCacheTimer) {
      context.containerBoundingRectCacheTimer = window.setTimeout(() => {
        context.containerBoundingRectCacheTimer = void 0;
        for (const cId of Object.keys(context.containerBoundingRectCache)) {
          delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;
        }
        context.containerBoundingRectCache = {};
      }, 50);
    }
    return rect;
  }
  function isElementVerticallyVisibleInContainer(getWindow, element, tolerance) {
    const container2 = getScrollableContainer(element);
    if (!container2) {
      return false;
    }
    const containerRect = getBoundingRect(getWindow, container2);
    const elementRect = element.getBoundingClientRect();
    const intersectionTolerance = elementRect.height * (1 - tolerance);
    const topIntersection = Math.max(0, containerRect.top - elementRect.top);
    const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);
    const totalIntersection = topIntersection + bottomIntersection;
    return totalIntersection === 0 || totalIntersection <= intersectionTolerance;
  }
  function scrollIntoView(getWindow, element, alignToTop) {
    const container2 = getScrollableContainer(element);
    if (container2) {
      const containerRect = getBoundingRect(getWindow, container2);
      const elementRect = element.getBoundingClientRect();
      if (alignToTop) {
        container2.scrollTop += elementRect.top - containerRect.top;
      } else {
        container2.scrollTop += elementRect.bottom - containerRect.bottom;
      }
    }
  }
  function getScrollableContainer(element) {
    const doc = element.ownerDocument;
    if (doc) {
      for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {
        if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
          return el;
        }
      }
      return doc.documentElement;
    }
    return null;
  }
  function makeFocusIgnored(element) {
    element.__shouldIgnoreFocus = true;
  }
  function shouldIgnoreFocus(element) {
    return !!element.__shouldIgnoreFocus;
  }
  function getUId(wnd) {
    const rnd = new Uint32Array(4);
    if (wnd.crypto && wnd.crypto.getRandomValues) {
      wnd.crypto.getRandomValues(rnd);
    } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {
      wnd.msCrypto.getRandomValues(rnd);
    } else {
      for (let i = 0; i < rnd.length; i++) {
        rnd[i] = 4294967295 * Math.random();
      }
    }
    const srnd = [];
    for (let i = 0; i < rnd.length; i++) {
      srnd.push(rnd[i].toString(36));
    }
    srnd.push("|");
    srnd.push((++_uidCounter).toString(36));
    srnd.push("|");
    srnd.push(Date.now().toString(36));
    return srnd.join("");
  }
  function getElementUId(getWindow, element) {
    const context = getInstanceContext(getWindow);
    let uid = element.__tabsterElementUID;
    if (!uid) {
      uid = element.__tabsterElementUID = getUId(getWindow());
    }
    if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {
      context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);
    }
    return uid;
  }
  function clearElementCache(getWindow, parent) {
    const context = getInstanceContext(getWindow);
    for (const key of Object.keys(context.elementByUId)) {
      const wel = context.elementByUId[key];
      const el = wel && wel.get();
      if (el && parent) {
        if (!dom.nodeContains(parent, el)) {
          continue;
        }
      }
      delete context.elementByUId[key];
    }
  }
  function documentContains(doc, element) {
    return dom.nodeContains(doc === null || doc === void 0 ? void 0 : doc.body, element);
  }
  function matchesSelector(element, selector) {
    const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;
    return matches && matches.call(element, selector);
  }
  function getPromise(getWindow) {
    const context = getInstanceContext(getWindow);
    if (context.basics.Promise) {
      return context.basics.Promise;
    }
    throw new Error("No Promise defined.");
  }
  function getWeakRef(context) {
    return context.basics.WeakRef;
  }
  var _lastTabsterPartId = 0;
  var TabsterPart = class {
    constructor(tabster, element, props) {
      const getWindow = tabster.getWindow;
      this._tabster = tabster;
      this._element = new WeakHTMLElement(getWindow, element);
      this._props = {
        ...props
      };
      this.id = "i" + ++_lastTabsterPartId;
    }
    getElement() {
      return this._element.get();
    }
    getProps() {
      return this._props;
    }
    setProps(props) {
      this._props = {
        ...props
      };
    }
  };
  var DummyInput = class {
    constructor(getWindow, isOutside, props, element, fixedTarget) {
      var _a;
      this._focusIn = (e) => {
        if (this._fixedTarget) {
          const target = this._fixedTarget.get();
          if (target) {
            nativeFocus(target);
          }
          return;
        }
        const input2 = this.input;
        if (this.onFocusIn && input2) {
          const relatedTarget = e.relatedTarget;
          this.onFocusIn(this, this._isBackward(true, input2, relatedTarget), relatedTarget);
        }
      };
      this._focusOut = (e) => {
        if (this._fixedTarget) {
          return;
        }
        this.useDefaultAction = false;
        const input2 = this.input;
        if (this.onFocusOut && input2) {
          const relatedTarget = e.relatedTarget;
          this.onFocusOut(this, this._isBackward(false, input2, relatedTarget), relatedTarget);
        }
      };
      const win = getWindow();
      const input = win.document.createElement("i");
      input.tabIndex = 0;
      input.setAttribute("role", "none");
      input.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, "");
      input.setAttribute("aria-hidden", "true");
      const style = input.style;
      style.position = "fixed";
      style.width = style.height = "1px";
      style.opacity = "0.001";
      style.zIndex = "-1";
      style.setProperty("content-visibility", "hidden");
      makeFocusIgnored(input);
      this.input = input;
      this.isFirst = props.isFirst;
      this.isOutside = isOutside;
      this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;
      this._fixedTarget = fixedTarget;
      input.addEventListener("focusin", this._focusIn);
      input.addEventListener("focusout", this._focusOut);
      input.__tabsterDummyContainer = element;
      if (this._isPhantom) {
        this._disposeTimer = win.setTimeout(() => {
          delete this._disposeTimer;
          this.dispose();
        }, 0);
        this._clearDisposeTimeout = () => {
          if (this._disposeTimer) {
            win.clearTimeout(this._disposeTimer);
            delete this._disposeTimer;
          }
          delete this._clearDisposeTimeout;
        };
      }
    }
    dispose() {
      var _a;
      if (this._clearDisposeTimeout) {
        this._clearDisposeTimeout();
      }
      const input = this.input;
      if (!input) {
        return;
      }
      delete this._fixedTarget;
      delete this.onFocusIn;
      delete this.onFocusOut;
      delete this.input;
      input.removeEventListener("focusin", this._focusIn);
      input.removeEventListener("focusout", this._focusOut);
      delete input.__tabsterDummyContainer;
      (_a = dom.getParentNode(input)) === null || _a === void 0 ? void 0 : _a.removeChild(input);
    }
    setTopLeft(top, left) {
      var _a;
      const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;
      if (style) {
        style.top = `${top}px`;
        style.left = `${left}px`;
      }
    }
    _isBackward(isIn, current, previous) {
      return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);
    }
  };
  var DummyInputManagerPriorities = {
    Root: 1,
    Modalizer: 2,
    Mover: 3,
    Groupper: 4
  };
  var DummyInputManager = class {
    constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {
      this._element = element;
      this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);
    }
    _setHandlers(onFocusIn, onFocusOut) {
      this._onFocusIn = onFocusIn;
      this._onFocusOut = onFocusOut;
    }
    moveOut(backwards) {
      var _a;
      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);
    }
    moveOutWithDefaultAction(backwards, relatedEvent) {
      var _a;
      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards, relatedEvent);
    }
    getHandler(isIn) {
      return isIn ? this._onFocusIn : this._onFocusOut;
    }
    setTabbable(tabbable) {
      var _a;
      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);
    }
    dispose() {
      if (this._instance) {
        this._instance.dispose(this);
        delete this._instance;
      }
      delete this._onFocusIn;
      delete this._onFocusOut;
    }
    static moveWithPhantomDummy(tabster, element, moveOutOfElement, isBackward, relatedEvent) {
      const dummy = new DummyInput(tabster.getWindow, true, {
        isPhantom: true,
        isFirst: true
      });
      const input = dummy.input;
      if (input) {
        let parent;
        let insertBefore;
        if (element.tagName === "BODY") {
          parent = element;
          insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getFirstElementChild(element) : null;
        } else {
          if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element, false, true, true))) {
            parent = element;
            insertBefore = isBackward ? element.firstElementChild : null;
          } else {
            parent = dom.getParentElement(element);
            insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element : dom.getNextElementSibling(element);
          }
          let potentialDummy;
          let dummyFor;
          do {
            potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getPreviousElementSibling(insertBefore) : insertBefore;
            dummyFor = getDummyInputContainer(potentialDummy);
            if (dummyFor === element) {
              insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : dom.getNextElementSibling(potentialDummy);
            } else {
              dummyFor = null;
            }
          } while (dummyFor);
        }
        if (parent === null || parent === void 0 ? void 0 : parent.dispatchEvent(new TabsterMoveFocusEvent({
          by: "root",
          owner: parent,
          next: null,
          relatedEvent
        }))) {
          dom.insertBefore(parent, input, insertBefore);
          nativeFocus(input);
        }
      }
    }
    static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {
      const dummy = new DummyInput(tabster.getWindow, true, {
        isPhantom: true,
        isFirst: true
      }, void 0, new WeakHTMLElement(tabster.getWindow, targetElement));
      const input = dummy.input;
      if (input) {
        let dummyParent;
        let insertBefore;
        if (hasSubFocusable(sourceElement) && !isBackward) {
          dummyParent = sourceElement;
          insertBefore = dom.getFirstElementChild(sourceElement);
        } else {
          dummyParent = dom.getParentElement(sourceElement);
          insertBefore = isBackward ? sourceElement : dom.getNextElementSibling(sourceElement);
        }
        if (dummyParent) {
          dom.insertBefore(dummyParent, input, insertBefore);
        }
      }
    }
  };
  var DummyInputObserver = class {
    constructor(win) {
      this._updateQueue = /* @__PURE__ */ new Set();
      this._lastUpdateQueueTime = 0;
      this._changedParents = /* @__PURE__ */ new WeakSet();
      this._dummyElements = [];
      this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
      this._domChanged = (parent) => {
        var _a;
        if (this._changedParents.has(parent)) {
          return;
        }
        this._changedParents.add(parent);
        if (this._updateDummyInputsTimer) {
          return;
        }
        this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
          delete this._updateDummyInputsTimer;
          for (const ref of this._dummyElements) {
            const dummyElement = ref.get();
            if (dummyElement) {
              const callback = this._dummyCallbacks.get(dummyElement);
              if (callback) {
                const dummyParent = dom.getParentNode(dummyElement);
                if (!dummyParent || this._changedParents.has(dummyParent)) {
                  callback();
                }
              }
            }
          }
          this._changedParents = /* @__PURE__ */ new WeakSet();
        }, _updateDummyInputsTimeout);
      };
      this._win = win;
    }
    add(dummy, callback) {
      if (!this._dummyCallbacks.has(dummy) && this._win) {
        this._dummyElements.push(new WeakHTMLElement(this._win, dummy));
        this._dummyCallbacks.set(dummy, callback);
        this.domChanged = this._domChanged;
      }
    }
    remove(dummy) {
      this._dummyElements = this._dummyElements.filter((ref) => {
        const element = ref.get();
        return element && element !== dummy;
      });
      this._dummyCallbacks.delete(dummy);
      if (this._dummyElements.length === 0) {
        delete this.domChanged;
      }
    }
    dispose() {
      var _a;
      const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);
      if (this._updateTimer) {
        win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);
        delete this._updateTimer;
      }
      if (this._updateDummyInputsTimer) {
        win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);
        delete this._updateDummyInputsTimer;
      }
      this._changedParents = /* @__PURE__ */ new WeakSet();
      this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
      this._dummyElements = [];
      this._updateQueue.clear();
      delete this.domChanged;
      delete this._win;
    }
    updatePositions(compute) {
      if (!this._win) {
        return;
      }
      this._updateQueue.add(compute);
      this._lastUpdateQueueTime = Date.now();
      this._scheduledUpdatePositions();
    }
    _scheduledUpdatePositions() {
      var _a;
      if (this._updateTimer) {
        return;
      }
      this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
        delete this._updateTimer;
        if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {
          const scrollTopLeftCache = /* @__PURE__ */ new Map();
          const setTopLeftCallbacks = [];
          for (const compute of this._updateQueue) {
            setTopLeftCallbacks.push(compute(scrollTopLeftCache));
          }
          this._updateQueue.clear();
          for (const setTopLeft of setTopLeftCallbacks) {
            setTopLeft();
          }
          scrollTopLeftCache.clear();
        } else {
          this._scheduledUpdatePositions();
        }
      }, _updateDummyInputsTimeout);
    }
  };
  var DummyInputManagerCore = class {
    constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {
      this._wrappers = [];
      this._isOutside = false;
      this._transformElements = /* @__PURE__ */ new Set();
      this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {
        this._onFocus(true, dummyInput, isBackward, relatedTarget);
      };
      this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {
        this._onFocus(false, dummyInput, isBackward, relatedTarget);
      };
      this.moveOut = (backwards) => {
        var _a;
        const first = this._firstDummy;
        const last = this._lastDummy;
        if (first && last) {
          this._ensurePosition();
          const firstInput = first.input;
          const lastInput = last.input;
          const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
          if (firstInput && lastInput && element2) {
            let toFocus;
            if (backwards) {
              firstInput.tabIndex = 0;
              toFocus = firstInput;
            } else {
              lastInput.tabIndex = 0;
              toFocus = lastInput;
            }
            if (toFocus) {
              nativeFocus(toFocus);
            }
          }
        }
      };
      this.moveOutWithDefaultAction = (backwards, relatedEvent) => {
        var _a;
        const first = this._firstDummy;
        const last = this._lastDummy;
        if (first && last) {
          this._ensurePosition();
          const firstInput = first.input;
          const lastInput = last.input;
          const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
          if (firstInput && lastInput && element2) {
            let toFocus;
            if (backwards) {
              if (!first.isOutside && this._tabster.focusable.isFocusable(element2, true, true, true)) {
                toFocus = element2;
              } else {
                first.useDefaultAction = true;
                firstInput.tabIndex = 0;
                toFocus = firstInput;
              }
            } else {
              last.useDefaultAction = true;
              lastInput.tabIndex = 0;
              toFocus = lastInput;
            }
            if (toFocus && element2.dispatchEvent(new TabsterMoveFocusEvent({
              by: "root",
              owner: element2,
              next: null,
              relatedEvent
            }))) {
              nativeFocus(toFocus);
            }
          }
        }
      };
      this.setTabbable = (manager2, tabbable) => {
        var _a, _b;
        for (const w of this._wrappers) {
          if (w.manager === manager2) {
            w.tabbable = tabbable;
            break;
          }
        }
        const wrapper = this._getCurrent();
        if (wrapper) {
          const tabIndex = wrapper.tabbable ? 0 : -1;
          let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;
          if (input) {
            input.tabIndex = tabIndex;
          }
          input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;
          if (input) {
            input.tabIndex = tabIndex;
          }
        }
        if (false) {
          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
        }
      };
      this._addDummyInputs = () => {
        if (this._addTimer) {
          return;
        }
        this._addTimer = this._getWindow().setTimeout(() => {
          delete this._addTimer;
          this._ensurePosition();
          if (false) {
            this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
            this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
          }
          this._addTransformOffsets();
        }, 0);
      };
      this._addTransformOffsets = () => {
        this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);
      };
      this._computeTransformOffsets = (scrollTopLeftCache) => {
        var _a, _b;
        const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);
        const transformElements = this._transformElements;
        const newTransformElements = /* @__PURE__ */ new Set();
        let scrollTop = 0;
        let scrollLeft = 0;
        const win = this._getWindow();
        for (let element2 = from; element2 && element2.nodeType === Node.ELEMENT_NODE; element2 = dom.getParentElement(element2)) {
          let scrollTopLeft = scrollTopLeftCache.get(element2);
          if (scrollTopLeft === void 0) {
            const transform = win.getComputedStyle(element2).transform;
            if (transform && transform !== "none") {
              scrollTopLeft = {
                scrollTop: element2.scrollTop,
                scrollLeft: element2.scrollLeft
              };
            }
            scrollTopLeftCache.set(element2, scrollTopLeft || null);
          }
          if (scrollTopLeft) {
            newTransformElements.add(element2);
            if (!transformElements.has(element2)) {
              element2.addEventListener("scroll", this._addTransformOffsets);
            }
            scrollTop += scrollTopLeft.scrollTop;
            scrollLeft += scrollTopLeft.scrollLeft;
          }
        }
        for (const el2 of transformElements) {
          if (!newTransformElements.has(el2)) {
            el2.removeEventListener("scroll", this._addTransformOffsets);
          }
        }
        this._transformElements = newTransformElements;
        return () => {
          var _a2, _b2;
          (_a2 = this._firstDummy) === null || _a2 === void 0 ? void 0 : _a2.setTopLeft(scrollTop, scrollLeft);
          (_b2 = this._lastDummy) === null || _b2 === void 0 ? void 0 : _b2.setTopLeft(scrollTop, scrollLeft);
        };
      };
      const el = element.get();
      if (!el) {
        throw new Error("No element");
      }
      this._tabster = tabster;
      this._getWindow = tabster.getWindow;
      this._callForDefaultAction = callForDefaultAction;
      const instance = el.__tabsterDummy;
      (instance || this)._wrappers.push({
        manager,
        priority,
        tabbable: true
      });
      if (instance) {
        if (false) {
          this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);
          this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);
        }
        return instance;
      }
      el.__tabsterDummy = this;
      const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;
      const tagName = el.tagName;
      this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === "UL" || tagName === "OL" || tagName === "TABLE") && !(tagName === "LI" || tagName === "TD" || tagName === "TH") : forcedDummyPosition === SysDummyInputsPositions.Outside;
      this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {
        isFirst: true
      }, element);
      this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {
        isFirst: false
      }, element);
      const dummyElement = this._firstDummy.input;
      dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);
      this._firstDummy.onFocusIn = this._onFocusIn;
      this._firstDummy.onFocusOut = this._onFocusOut;
      this._lastDummy.onFocusIn = this._onFocusIn;
      this._lastDummy.onFocusOut = this._onFocusOut;
      this._element = element;
      this._addDummyInputs();
    }
    dispose(manager, force) {
      var _a, _b, _c, _d;
      const wrappers = this._wrappers = this._wrappers.filter((w) => w.manager !== manager && !force);
      if (false) {
        this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);
        this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);
      }
      if (wrappers.length === 0) {
        delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;
        for (const el of this._transformElements) {
          el.removeEventListener("scroll", this._addTransformOffsets);
        }
        this._transformElements.clear();
        const win = this._getWindow();
        if (this._addTimer) {
          win.clearTimeout(this._addTimer);
          delete this._addTimer;
        }
        const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
        dummyElement && this._tabster._dummyObserver.remove(dummyElement);
        (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();
        (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();
      }
    }
    _onFocus(isIn, dummyInput, isBackward, relatedTarget) {
      var _a;
      const wrapper = this._getCurrent();
      if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {
        (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);
      }
    }
    _getCurrent() {
      this._wrappers.sort((a, b) => {
        if (a.tabbable !== b.tabbable) {
          return a.tabbable ? -1 : 1;
        }
        return a.priority - b.priority;
      });
      return this._wrappers[0];
    }
    _ensurePosition() {
      var _a, _b, _c;
      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
      const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
      const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;
      if (!element || !firstDummyInput || !lastDummyInput) {
        return;
      }
      if (this._isOutside) {
        const elementParent = dom.getParentNode(element);
        if (elementParent) {
          const nextSibling = dom.getNextSibling(element);
          if (nextSibling !== lastDummyInput) {
            dom.insertBefore(elementParent, lastDummyInput, nextSibling);
          }
          if (dom.getPreviousElementSibling(element) !== firstDummyInput) {
            dom.insertBefore(elementParent, firstDummyInput, element);
          }
        }
      } else {
        if (dom.getLastElementChild(element) !== lastDummyInput) {
          dom.appendChild(element, lastDummyInput);
        }
        const firstElementChild = dom.getFirstElementChild(element);
        if (firstElementChild && firstElementChild !== firstDummyInput && firstElementChild.parentNode) {
          dom.insertBefore(firstElementChild.parentNode, firstDummyInput, firstElementChild);
        }
      }
    }
  };
  function getLastChild$2(container2) {
    let lastChild = null;
    for (let i = dom.getLastElementChild(container2); i; i = dom.getLastElementChild(i)) {
      lastChild = i;
    }
    return lastChild || void 0;
  }
  function getAdjacentElement(from, prev) {
    let cur = from;
    let adjacent = null;
    while (cur && !adjacent) {
      adjacent = prev ? dom.getPreviousElementSibling(cur) : dom.getNextElementSibling(cur);
      cur = dom.getParentElement(cur);
    }
    return adjacent || void 0;
  }
  function augmentAttribute(tabster, element, name, value) {
    const entry = tabster.storageEntry(element, true);
    let ret = false;
    if (!entry.aug) {
      if (value === void 0) {
        return ret;
      }
      entry.aug = {};
    }
    if (value === void 0) {
      if (name in entry.aug) {
        const origVal = entry.aug[name];
        delete entry.aug[name];
        if (origVal === null) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, origVal);
        }
        ret = true;
      }
    } else {
      let origValue;
      if (!(name in entry.aug)) {
        origValue = element.getAttribute(name);
      }
      if (origValue !== void 0 && origValue !== value) {
        entry.aug[name] = origValue;
        if (value === null) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value);
        }
        ret = true;
      }
    }
    if (value === void 0 && Object.keys(entry.aug).length === 0) {
      delete entry.aug;
      tabster.storageEntry(element, false);
    }
    return ret;
  }
  function isDisplayNone(element) {
    var _a, _b;
    const elementDocument = element.ownerDocument;
    const computedStyle = (_a = elementDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(element);
    if (element.offsetParent === null && elementDocument.body !== element && (computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) !== "fixed") {
      return true;
    }
    if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.visibility) === "hidden") {
      return true;
    }
    if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) === "fixed") {
      if (computedStyle.display === "none") {
        return true;
      }
      if (((_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null && elementDocument.body !== element.parentElement) {
        return true;
      }
    }
    return false;
  }
  function isRadio(element) {
    return element.tagName === "INPUT" && !!element.name && element.type === "radio";
  }
  function getRadioButtonGroup(element) {
    if (!isRadio(element)) {
      return;
    }
    const name = element.name;
    let radioButtons = Array.from(dom.getElementsByName(element, name));
    let checked;
    radioButtons = radioButtons.filter((el) => {
      if (isRadio(el)) {
        if (el.checked) {
          checked = el;
        }
        return true;
      }
      return false;
    });
    return {
      name,
      buttons: new Set(radioButtons),
      checked
    };
  }
  function getDummyInputContainer(element) {
    var _a;
    return ((_a = element === null || element === void 0 ? void 0 : element.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) || null;
  }
  function getTabsterAttribute(props, plain) {
    const attr = JSON.stringify(props);
    if (plain === true) {
      return attr;
    }
    return {
      [TABSTER_ATTRIBUTE_NAME]: attr
    };
  }
  function mergeTabsterProps(props, newProps) {
    for (const key of Object.keys(newProps)) {
      const value = newProps[key];
      if (value) {
        props[key] = value;
      } else {
        delete props[key];
      }
    }
  }
  function setTabsterAttribute(element, newProps, update) {
    let props;
    if (update) {
      const attr = element.getAttribute(TABSTER_ATTRIBUTE_NAME);
      if (attr) {
        try {
          props = JSON.parse(attr);
        } catch (e) {
          if (false) {
            console.error(`data-tabster attribute error: ${e}`, element);
          }
        }
      }
    }
    if (!props) {
      props = {};
    }
    mergeTabsterProps(props, newProps);
    if (Object.keys(props).length > 0) {
      element.setAttribute(TABSTER_ATTRIBUTE_NAME, getTabsterAttribute(props, true));
    } else {
      element.removeAttribute(TABSTER_ATTRIBUTE_NAME);
    }
  }
  var RootDummyManager = class extends DummyInputManager {
    constructor(tabster, element, setFocused, sys) {
      super(tabster, element, DummyInputManagerPriorities.Root, sys, void 0, true);
      this._onDummyInputFocus = (dummyInput) => {
        var _a;
        if (dummyInput.useDefaultAction) {
          this._setFocused(false);
        } else {
          this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);
          const element2 = this._element.get();
          if (element2) {
            this._setFocused(true);
            const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {
              container: element2,
              ignoreAccessibility: true
            });
            if (toFocus) {
              nativeFocus(toFocus);
              return;
            }
          }
          (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();
        }
      };
      this._setHandlers(this._onDummyInputFocus);
      this._tabster = tabster;
      this._setFocused = setFocused;
    }
  };
  var Root = class extends TabsterPart {
    constructor(tabster, element, onDispose, props, sys) {
      super(tabster, element, props);
      this._isFocused = false;
      this._setFocused = (hasFocused) => {
        var _a;
        if (this._setFocusedTimer) {
          this._tabster.getWindow().clearTimeout(this._setFocusedTimer);
          delete this._setFocusedTimer;
        }
        if (this._isFocused === hasFocused) {
          return;
        }
        const element2 = this._element.get();
        if (element2) {
          if (hasFocused) {
            this._isFocused = true;
            (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);
            element2.dispatchEvent(new RootFocusEvent({
              element: element2
            }));
          } else {
            this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {
              var _a2;
              delete this._setFocusedTimer;
              this._isFocused = false;
              (_a2 = this._dummyManager) === null || _a2 === void 0 ? void 0 : _a2.setTabbable(true);
              element2.dispatchEvent(new RootBlurEvent({
                element: element2
              }));
            }, 0);
          }
        }
      };
      this._onFocusIn = (event) => {
        const getParent2 = this._tabster.getParent;
        const rootElement = this._element.get();
        let curElement = event.composedPath()[0];
        do {
          if (curElement === rootElement) {
            this._setFocused(true);
            return;
          }
          curElement = curElement && getParent2(curElement);
        } while (curElement);
      };
      this._onFocusOut = () => {
        this._setFocused(false);
      };
      this._onDispose = onDispose;
      const win = tabster.getWindow;
      this.uid = getElementUId(win, element);
      this._sys = sys;
      if (tabster.controlTab || tabster.rootDummyInputs) {
        this.addDummyInputs();
      }
      const w = win();
      const doc = w.document;
      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
      doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
      this._add();
    }
    addDummyInputs() {
      if (!this._dummyManager) {
        this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);
      }
    }
    dispose() {
      var _a;
      this._onDispose(this);
      const win = this._tabster.getWindow();
      const doc = win.document;
      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
      doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
      if (this._setFocusedTimer) {
        win.clearTimeout(this._setFocusedTimer);
        delete this._setFocusedTimer;
      }
      (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
      this._remove();
    }
    moveOutWithDefaultAction(isBackward, relatedEvent) {
      const dummyManager = this._dummyManager;
      if (dummyManager) {
        dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);
      } else {
        const el = this.getElement();
        if (el) {
          RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward, relatedEvent);
        }
      }
    }
    _add() {
      if (false) {
        _setInformativeStyle$3(this._element, false, this.uid);
      }
    }
    _remove() {
      if (false) {
        _setInformativeStyle$3(this._element, true);
      }
    }
  };
  var RootAPI = class {
    constructor(tabster, autoRoot) {
      this._autoRootWaiting = false;
      this._roots = {};
      this._forceDummy = false;
      this.rootById = {};
      this._autoRootCreate = () => {
        var _a;
        const doc = this._win().document;
        const body = doc.body;
        if (body) {
          this._autoRootUnwait(doc);
          const props = this._autoRoot;
          if (props) {
            setTabsterAttribute(body, {
              root: props
            }, true);
            updateTabsterByAttribute(this._tabster, body);
            return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;
          }
        } else if (!this._autoRootWaiting) {
          this._autoRootWaiting = true;
          doc.addEventListener("readystatechange", this._autoRootCreate);
        }
        return void 0;
      };
      this._onRootDispose = (root) => {
        delete this._roots[root.id];
      };
      this._tabster = tabster;
      this._win = tabster.getWindow;
      this._autoRoot = autoRoot;
      tabster.queueInit(() => {
        if (this._autoRoot) {
          this._autoRootCreate();
        }
      });
    }
    _autoRootUnwait(doc) {
      doc.removeEventListener("readystatechange", this._autoRootCreate);
      this._autoRootWaiting = false;
    }
    dispose() {
      const win = this._win();
      this._autoRootUnwait(win.document);
      delete this._autoRoot;
      Object.keys(this._roots).forEach((rootId) => {
        if (this._roots[rootId]) {
          this._roots[rootId].dispose();
          delete this._roots[rootId];
        }
      });
      this.rootById = {};
    }
    createRoot(element, props, sys) {
      if (false) ;
      const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);
      this._roots[newRoot.id] = newRoot;
      if (this._forceDummy) {
        newRoot.addDummyInputs();
      }
      return newRoot;
    }
    addDummyInputs() {
      this._forceDummy = true;
      const roots = this._roots;
      for (const id of Object.keys(roots)) {
        roots[id].addDummyInputs();
      }
    }
    static getRootByUId(getWindow, id) {
      const tabster = getWindow().__tabsterInstance;
      return tabster && tabster.root.rootById[id];
    }
    /**
     * Fetches the tabster context for an element walking up its ancestors
     *
     * @param tabster Tabster instance
     * @param element The element the tabster context should represent
     * @param options Additional options
     * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations
     */
    static getTabsterContext(tabster, element, options) {
      if (options === void 0) {
        options = {};
      }
      var _a, _b, _c, _d;
      if (!element.ownerDocument) {
        return void 0;
      }
      const {
        checkRtl,
        referenceElement
      } = options;
      const getParent2 = tabster.getParent;
      tabster.drainInitQueue();
      let root;
      let modalizer;
      let groupper;
      let mover;
      let excludedFromMover = false;
      let groupperBeforeMover;
      let modalizerInGroupper;
      let dirRightToLeft;
      let uncontrolled;
      let curElement = referenceElement || element;
      const ignoreKeydown = {};
      while (curElement && (!root || checkRtl)) {
        const tabsterOnElement = getTabsterOnElement(tabster, curElement);
        if (checkRtl && dirRightToLeft === void 0) {
          const dir = curElement.dir;
          if (dir) {
            dirRightToLeft = dir.toLowerCase() === "rtl";
          }
        }
        if (!tabsterOnElement) {
          curElement = getParent2(curElement);
          continue;
        }
        const tagName = curElement.tagName;
        if ((tabsterOnElement.uncontrolled || tagName === "IFRAME" || tagName === "WEBVIEW") && tabster.focusable.isVisible(curElement)) {
          uncontrolled = curElement;
        }
        if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {
          excludedFromMover = true;
        }
        const curModalizer = tabsterOnElement.modalizer;
        const curGroupper = tabsterOnElement.groupper;
        const curMover = tabsterOnElement.mover;
        if (!modalizer && curModalizer) {
          modalizer = curModalizer;
        }
        if (!groupper && curGroupper && (!modalizer || curModalizer)) {
          if (modalizer) {
            if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
              modalizer = void 0;
              groupper = curGroupper;
            }
            modalizerInGroupper = curGroupper;
          } else {
            groupper = curGroupper;
          }
        }
        if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element) && curElement.contains(element)) {
          mover = curMover;
          groupperBeforeMover = !!groupper && groupper !== curGroupper;
        }
        if (tabsterOnElement.root) {
          root = tabsterOnElement.root;
        }
        if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {
          Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);
        }
        curElement = getParent2(curElement);
      }
      if (!root) {
        const rootAPI = tabster.root;
        const autoRoot = rootAPI._autoRoot;
        if (autoRoot) {
          if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {
            root = rootAPI._autoRootCreate();
          }
        }
      }
      if (groupper && !mover) {
        groupperBeforeMover = true;
      }
      if (false) {
        if (modalizer || groupper || mover) {
          console.error("Tabster Root is required for Mover, Groupper and Modalizer to work.");
        }
      }
      const shouldIgnoreKeydown = (event) => !!ignoreKeydown[event.key];
      return root ? {
        root,
        modalizer,
        groupper,
        mover,
        groupperBeforeMover,
        modalizerInGroupper,
        rtl: checkRtl ? !!dirRightToLeft : void 0,
        uncontrolled,
        excludedFromMover,
        ignoreKeydown: shouldIgnoreKeydown
      } : void 0;
    }
    static getRoot(tabster, element) {
      var _a;
      const getParent2 = tabster.getParent;
      for (let el = element; el; el = getParent2(el)) {
        const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;
        if (root) {
          return root;
        }
      }
      return void 0;
    }
    onRoot(root, removed) {
      if (removed) {
        delete this.rootById[root.uid];
      } else {
        this.rootById[root.uid] = root;
      }
    }
  };
  var Subscribable = class {
    constructor() {
      this._callbacks = [];
    }
    dispose() {
      this._callbacks = [];
      delete this._val;
    }
    subscribe(callback) {
      const callbacks = this._callbacks;
      const index = callbacks.indexOf(callback);
      if (index < 0) {
        callbacks.push(callback);
      }
    }
    subscribeFirst(callback) {
      const callbacks = this._callbacks;
      const index = callbacks.indexOf(callback);
      if (index >= 0) {
        callbacks.splice(index, 1);
      }
      callbacks.unshift(callback);
    }
    unsubscribe(callback) {
      const index = this._callbacks.indexOf(callback);
      if (index >= 0) {
        this._callbacks.splice(index, 1);
      }
    }
    setVal(val, detail) {
      if (this._val === val) {
        return;
      }
      this._val = val;
      this._callCallbacks(val, detail);
    }
    getVal() {
      return this._val;
    }
    trigger(val, detail) {
      this._callCallbacks(val, detail);
    }
    _callCallbacks(val, detail) {
      this._callbacks.forEach((callback) => callback(val, detail));
    }
  };
  var FocusableAPI = class {
    constructor(tabster) {
      this._tabster = tabster;
    }
    dispose() {
    }
    getProps(element) {
      const tabsterOnElement = getTabsterOnElement(this._tabster, element);
      return tabsterOnElement && tabsterOnElement.focusable || {};
    }
    isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {
      if (matchesSelector(el, FOCUSABLE_SELECTOR) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {
        return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));
      }
      return false;
    }
    isVisible(el) {
      if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {
        return false;
      }
      if (isDisplayNone(el)) {
        return false;
      }
      const rect = el.ownerDocument.body.getBoundingClientRect();
      if (rect.width === 0 && rect.height === 0) {
        return false;
      }
      return true;
    }
    isAccessible(el) {
      var _a;
      for (let e = el; e; e = dom.getParentElement(e)) {
        const tabsterOnElement = getTabsterOnElement(this._tabster, e);
        if (this._isHidden(e)) {
          return false;
        }
        const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;
        if (!ignoreDisabled && this._isDisabled(e)) {
          return false;
        }
      }
      return true;
    }
    _isDisabled(el) {
      return el.hasAttribute("disabled");
    }
    _isHidden(el) {
      var _a;
      const attrVal = el.getAttribute("aria-hidden");
      if (attrVal && attrVal.toLowerCase() === "true") {
        if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {
          return true;
        }
      }
      return false;
    }
    findFirst(options, out) {
      return this.findElement({
        ...options
      }, out);
    }
    findLast(options, out) {
      return this.findElement({
        isBackward: true,
        ...options
      }, out);
    }
    findNext(options, out) {
      return this.findElement({
        ...options
      }, out);
    }
    findPrev(options, out) {
      return this.findElement({
        ...options,
        isBackward: true
      }, out);
    }
    findDefault(options, out) {
      return this.findElement({
        ...options,
        acceptCondition: (el) => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault
      }, out) || null;
    }
    findAll(options) {
      return this._findElements(true, options) || [];
    }
    findElement(options, out) {
      const found = this._findElements(false, options, out);
      return found ? found[0] : found;
    }
    _findElements(isFindAll, options, out) {
      var _a, _b, _c;
      const {
        container: container2,
        currentElement = null,
        includeProgrammaticallyFocusable,
        useActiveModalizer,
        ignoreAccessibility,
        modalizerId,
        isBackward,
        onElement
      } = options;
      if (!out) {
        out = {};
      }
      const elements = [];
      let {
        acceptCondition
      } = options;
      const hasCustomCondition = !!acceptCondition;
      if (!container2) {
        return null;
      }
      if (!acceptCondition) {
        acceptCondition = (el) => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);
      }
      const acceptElementState = {
        container: container2,
        modalizerUserId: modalizerId === void 0 && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container2)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),
        from: currentElement || container2,
        isBackward,
        isFindAll,
        acceptCondition,
        hasCustomCondition,
        includeProgrammaticallyFocusable,
        ignoreAccessibility,
        cachedGrouppers: {},
        cachedRadioGroups: {}
      };
      const walker = createElementTreeWalker(container2.ownerDocument, container2, (node) => this._acceptElement(node, acceptElementState));
      if (!walker) {
        return null;
      }
      const prepareForNextElement = (shouldContinueIfNotFound) => {
        var _a2, _b2;
        const foundElement = (_a2 = acceptElementState.foundElement) !== null && _a2 !== void 0 ? _a2 : acceptElementState.foundBackward;
        if (foundElement) {
          elements.push(foundElement);
        }
        if (isFindAll) {
          if (foundElement) {
            acceptElementState.found = false;
            delete acceptElementState.foundElement;
            delete acceptElementState.foundBackward;
            delete acceptElementState.fromCtx;
            acceptElementState.from = foundElement;
            if (onElement && !onElement(foundElement)) {
              return false;
            }
          }
          return !!(foundElement || shouldContinueIfNotFound);
        } else {
          if (foundElement && out) {
            out.uncontrolled = (_b2 = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b2 === void 0 ? void 0 : _b2.uncontrolled;
          }
          return !!(shouldContinueIfNotFound && !foundElement);
        }
      };
      if (!currentElement) {
        out.outOfDOMOrder = true;
      }
      if (currentElement && dom.nodeContains(container2, currentElement)) {
        walker.currentNode = currentElement;
      } else if (isBackward) {
        const lastChild = getLastChild$2(container2);
        if (!lastChild) {
          return null;
        }
        if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {
          if (acceptElementState.skippedFocusable) {
            out.outOfDOMOrder = true;
          }
          return elements;
        }
        walker.currentNode = lastChild;
      }
      do {
        if (isBackward) {
          walker.previousNode();
        } else {
          walker.nextNode();
        }
      } while (prepareForNextElement());
      if (acceptElementState.skippedFocusable) {
        out.outOfDOMOrder = true;
      }
      return elements.length ? elements : null;
    }
    _acceptElement(element, state) {
      var _a, _b, _c;
      if (state.found) {
        return NodeFilter.FILTER_ACCEPT;
      }
      const foundBackward = state.foundBackward;
      if (foundBackward && (element === foundBackward || !dom.nodeContains(foundBackward, element))) {
        state.found = true;
        state.foundElement = foundBackward;
        return NodeFilter.FILTER_ACCEPT;
      }
      const container2 = state.container;
      if (element === container2) {
        return NodeFilter.FILTER_SKIP;
      }
      if (!dom.nodeContains(container2, element)) {
        return NodeFilter.FILTER_REJECT;
      }
      if (getDummyInputContainer(element)) {
        return NodeFilter.FILTER_REJECT;
      }
      if (dom.nodeContains(state.rejectElementsFrom, element)) {
        return NodeFilter.FILTER_REJECT;
      }
      const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element);
      if (!ctx) {
        return NodeFilter.FILTER_SKIP;
      }
      if (shouldIgnoreFocus(element)) {
        if (this.isFocusable(element, void 0, true, true)) {
          state.skippedFocusable = true;
        }
        return NodeFilter.FILTER_SKIP;
      }
      if (!state.hasCustomCondition && (element.tagName === "IFRAME" || element.tagName === "WEBVIEW")) {
        if (this.isVisible(element) && ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
          state.found = true;
          state.rejectElementsFrom = state.foundElement = element;
          return NodeFilter.FILTER_ACCEPT;
        } else {
          return NodeFilter.FILTER_REJECT;
        }
      }
      if (!state.ignoreAccessibility && !this.isAccessible(element)) {
        if (this.isFocusable(element, false, true, true)) {
          state.skippedFocusable = true;
        }
        return NodeFilter.FILTER_REJECT;
      }
      let result;
      let fromCtx = state.fromCtx;
      if (!fromCtx) {
        fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);
      }
      const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;
      let groupper = ctx.groupper;
      let mover = ctx.mover;
      result = (_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.acceptElement(element, state);
      if (result !== void 0) {
        state.skippedFocusable = true;
      }
      if (result === void 0 && (groupper || mover || fromMover)) {
        const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
        const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();
        let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();
        if (moverElement && dom.nodeContains(fromMoverElement, moverElement) && dom.nodeContains(container2, fromMoverElement) && (!groupperElement || !mover || dom.nodeContains(fromMoverElement, groupperElement))) {
          mover = fromMover;
          moverElement = fromMoverElement;
        }
        if (groupperElement) {
          if (groupperElement === container2 || !dom.nodeContains(container2, groupperElement)) {
            groupper = void 0;
          } else if (!dom.nodeContains(groupperElement, element)) {
            return NodeFilter.FILTER_REJECT;
          }
        }
        if (moverElement) {
          if (!dom.nodeContains(container2, moverElement)) {
            mover = void 0;
          } else if (!dom.nodeContains(moverElement, element)) {
            return NodeFilter.FILTER_REJECT;
          }
        }
        if (groupper && mover) {
          if (moverElement && groupperElement && !dom.nodeContains(groupperElement, moverElement)) {
            mover = void 0;
          } else {
            groupper = void 0;
          }
        }
        if (groupper) {
          result = groupper.acceptElement(element, state);
        }
        if (mover) {
          result = mover.acceptElement(element, state);
        }
      }
      if (result === void 0) {
        result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element, false, true, true)) {
          state.skippedFocusable = true;
        }
      }
      if (result === NodeFilter.FILTER_ACCEPT && !state.found) {
        if (!state.isFindAll && isRadio(element) && !element.checked) {
          const radioGroupName = element.name;
          let radioGroup = state.cachedRadioGroups[radioGroupName];
          if (!radioGroup) {
            radioGroup = getRadioButtonGroup(element);
            if (radioGroup) {
              state.cachedRadioGroups[radioGroupName] = radioGroup;
            }
          }
          if ((radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.checked) && radioGroup.checked !== element) {
            return NodeFilter.FILTER_SKIP;
          }
        }
        if (state.isBackward) {
          state.foundBackward = element;
          result = NodeFilter.FILTER_SKIP;
        } else {
          state.found = true;
          state.foundElement = element;
        }
      }
      return result;
    }
  };
  var Keys = {
    Tab: "Tab",
    Enter: "Enter",
    Escape: "Escape",
    PageUp: "PageUp",
    PageDown: "PageDown",
    End: "End",
    Home: "Home",
    ArrowLeft: "ArrowLeft",
    ArrowUp: "ArrowUp",
    ArrowRight: "ArrowRight",
    ArrowDown: "ArrowDown"
  };
  function getUncontrolledCompletelyContainer(tabster, element) {
    var _a;
    const getParent2 = tabster.getParent;
    let el = element;
    do {
      const uncontrolledOnElement = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.uncontrolled;
      if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) {
        return el;
      }
      el = getParent2(el);
    } while (el);
    return void 0;
  }
  var AsyncFocusIntentPriorityBySource = {
    [AsyncFocusSources.Restorer]: 0,
    [AsyncFocusSources.Deloser]: 1,
    [AsyncFocusSources.EscapeGroupper]: 2
  };
  var FocusedElementState = class _FocusedElementState extends Subscribable {
    constructor(tabster, getWindow) {
      super();
      this._init = () => {
        const win = this._win();
        const doc = win.document;
        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
        doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
        win.addEventListener("keydown", this._onKeyDown, true);
        const activeElement = dom.getActiveElement(doc);
        if (activeElement && activeElement !== doc.body) {
          this._setFocusedElement(activeElement);
        }
        this.subscribe(this._onChanged);
      };
      this._onFocusIn = (e) => {
        const target = e.composedPath()[0];
        if (target) {
          this._setFocusedElement(target, e.detail.relatedTarget, e.detail.isFocusedProgrammatically);
        }
      };
      this._onFocusOut = (e) => {
        var _a;
        this._setFocusedElement(void 0, (_a = e.detail) === null || _a === void 0 ? void 0 : _a.originalEvent.relatedTarget);
      };
      this._validateFocusedElement = (element) => {
      };
      this._onKeyDown = (event) => {
        if (event.key !== Keys.Tab || event.ctrlKey) {
          return;
        }
        const currentElement = this.getVal();
        if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === "true") {
          return;
        }
        const tabster2 = this._tabster;
        const controlTab = tabster2.controlTab;
        const ctx = RootAPI.getTabsterContext(tabster2, currentElement);
        if (!ctx || ctx.ignoreKeydown(event)) {
          return;
        }
        const isBackward = event.shiftKey;
        const next = _FocusedElementState.findNextTabbable(tabster2, ctx, void 0, currentElement, void 0, isBackward, true);
        const rootElement = ctx.root.getElement();
        if (!rootElement) {
          return;
        }
        const nextElement = next === null || next === void 0 ? void 0 : next.element;
        const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster2, currentElement);
        if (nextElement) {
          const nextUncontrolled = next.uncontrolled;
          if (ctx.uncontrolled || dom.nodeContains(nextUncontrolled, currentElement)) {
            if (!next.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !dom.nodeContains(uncontrolledCompletelyContainer, nextElement)) {
              return;
            }
            DummyInputManager.addPhantomDummyWithTarget(tabster2, currentElement, isBackward, nextElement);
            return;
          }
          if (nextUncontrolled && tabster2.focusable.isVisible(nextUncontrolled) || nextElement.tagName === "IFRAME" && tabster2.focusable.isVisible(nextElement)) {
            if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
              by: "root",
              owner: rootElement,
              next: nextElement,
              relatedEvent: event
            }))) {
              DummyInputManager.moveWithPhantomDummy(tabster2, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward, event);
            }
            return;
          }
          if (controlTab || (next === null || next === void 0 ? void 0 : next.outOfDOMOrder)) {
            if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
              by: "root",
              owner: rootElement,
              next: nextElement,
              relatedEvent: event
            }))) {
              event.preventDefault();
              event.stopImmediatePropagation();
              nativeFocus(nextElement);
            }
          }
        } else {
          if (!uncontrolledCompletelyContainer && rootElement.dispatchEvent(new TabsterMoveFocusEvent({
            by: "root",
            owner: rootElement,
            next: null,
            relatedEvent: event
          }))) {
            ctx.root.moveOutWithDefaultAction(isBackward, event);
          }
        }
      };
      this._onChanged = (element, detail) => {
        var _a, _b;
        if (element) {
          element.dispatchEvent(new TabsterFocusInEvent(detail));
        } else {
          const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
          if (last) {
            const d = {
              ...detail
            };
            const lastCtx = RootAPI.getTabsterContext(this._tabster, last);
            const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
            if (modalizerId) {
              d.modalizerId = modalizerId;
            }
            last.dispatchEvent(new TabsterFocusOutEvent(d));
          }
        }
      };
      this._tabster = tabster;
      this._win = getWindow;
      tabster.queueInit(this._init);
    }
    dispose() {
      super.dispose();
      const win = this._win();
      const doc = win.document;
      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
      win.removeEventListener("keydown", this._onKeyDown, true);
      this.unsubscribe(this._onChanged);
      const asyncFocus = this._asyncFocus;
      if (asyncFocus) {
        win.clearTimeout(asyncFocus.timeout);
        delete this._asyncFocus;
      }
      delete _FocusedElementState._lastResetElement;
      delete this._nextVal;
      delete this._lastVal;
    }
    static forgetMemorized(instance, parent) {
      var _a, _b;
      let wel = _FocusedElementState._lastResetElement;
      let el = wel && wel.get();
      if (el && dom.nodeContains(parent, el)) {
        delete _FocusedElementState._lastResetElement;
      }
      el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();
      if (el && dom.nodeContains(parent, el)) {
        delete instance._nextVal;
      }
      wel = instance._lastVal;
      el = wel && wel.get();
      if (el && dom.nodeContains(parent, el)) {
        delete instance._lastVal;
      }
    }
    getFocusedElement() {
      return this.getVal();
    }
    getLastFocusedElement() {
      var _a;
      let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
      if (!el || el && !documentContains(el.ownerDocument, el)) {
        this._lastVal = el = void 0;
      }
      return el;
    }
    focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck, preventScroll) {
      if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {
        return false;
      }
      element.focus({
        preventScroll
      });
      return true;
    }
    focusDefault(container2) {
      const el = this._tabster.focusable.findDefault({
        container: container2
      });
      if (el) {
        this._tabster.focusedElement.focus(el);
        return true;
      }
      return false;
    }
    getFirstOrLastTabbable(isFirst, props) {
      var _a;
      const {
        container: container2,
        ignoreAccessibility
      } = props;
      let toFocus;
      if (container2) {
        const ctx = RootAPI.getTabsterContext(this._tabster, container2);
        if (ctx) {
          toFocus = (_a = _FocusedElementState.findNextTabbable(this._tabster, ctx, container2, void 0, void 0, !isFirst, ignoreAccessibility)) === null || _a === void 0 ? void 0 : _a.element;
        }
      }
      if (toFocus && !dom.nodeContains(container2, toFocus)) {
        toFocus = void 0;
      }
      return toFocus || void 0;
    }
    _focusFirstOrLast(isFirst, props) {
      const toFocus = this.getFirstOrLastTabbable(isFirst, props);
      if (toFocus) {
        this.focus(toFocus, false, true);
        return true;
      }
      return false;
    }
    focusFirst(props) {
      return this._focusFirstOrLast(true, props);
    }
    focusLast(props) {
      return this._focusFirstOrLast(false, props);
    }
    resetFocus(container2) {
      if (!this._tabster.focusable.isVisible(container2)) {
        return false;
      }
      if (!this._tabster.focusable.isFocusable(container2, true, true, true)) {
        const prevTabIndex = container2.getAttribute("tabindex");
        const prevAriaHidden = container2.getAttribute("aria-hidden");
        container2.tabIndex = -1;
        container2.setAttribute("aria-hidden", "true");
        _FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container2);
        this.focus(container2, true, true);
        this._setOrRemoveAttribute(container2, "tabindex", prevTabIndex);
        this._setOrRemoveAttribute(container2, "aria-hidden", prevAriaHidden);
      } else {
        this.focus(container2);
      }
      return true;
    }
    requestAsyncFocus(source, callback, delay) {
      const win = this._tabster.getWindow();
      const currentAsyncFocus = this._asyncFocus;
      if (currentAsyncFocus) {
        if (AsyncFocusIntentPriorityBySource[source] > AsyncFocusIntentPriorityBySource[currentAsyncFocus.source]) {
          return;
        }
        win.clearTimeout(currentAsyncFocus.timeout);
      }
      this._asyncFocus = {
        source,
        callback,
        timeout: win.setTimeout(() => {
          this._asyncFocus = void 0;
          callback();
        }, delay)
      };
    }
    cancelAsyncFocus(source) {
      const asyncFocus = this._asyncFocus;
      if ((asyncFocus === null || asyncFocus === void 0 ? void 0 : asyncFocus.source) === source) {
        this._tabster.getWindow().clearTimeout(asyncFocus.timeout);
        this._asyncFocus = void 0;
      }
    }
    _setOrRemoveAttribute(element, name, value) {
      if (value === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value);
      }
    }
    _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {
      var _a, _b;
      if (this._tabster._noop) {
        return;
      }
      const detail = {
        relatedTarget
      };
      if (element) {
        const lastResetElement = (_a = _FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();
        _FocusedElementState._lastResetElement = void 0;
        if (lastResetElement === element || shouldIgnoreFocus(element)) {
          return;
        }
        detail.isFocusedProgrammatically = isFocusedProgrammatically;
        const ctx = RootAPI.getTabsterContext(this._tabster, element);
        const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
        if (modalizerId) {
          detail.modalizerId = modalizerId;
        }
      }
      const nextVal = this._nextVal = {
        element: element ? new WeakHTMLElement(this._win, element) : void 0,
        detail
      };
      if (element && element !== this._val) {
        this._validateFocusedElement(element);
      }
      if (this._nextVal === nextVal) {
        this.setVal(element, detail);
      }
      this._nextVal = void 0;
    }
    setVal(val, detail) {
      super.setVal(val, detail);
      if (val) {
        this._lastVal = new WeakHTMLElement(this._win, val);
      }
    }
    static findNextTabbable(tabster, ctx, container2, currentElement, referenceElement, isBackward, ignoreAccessibility) {
      const actualContainer = container2 || ctx.root.getElement();
      if (!actualContainer) {
        return null;
      }
      let next = null;
      const isTabbingTimer = _FocusedElementState._isTabbingTimer;
      const win = tabster.getWindow();
      if (isTabbingTimer) {
        win.clearTimeout(isTabbingTimer);
      }
      _FocusedElementState.isTabbing = true;
      _FocusedElementState._isTabbingTimer = win.setTimeout(() => {
        delete _FocusedElementState._isTabbingTimer;
        _FocusedElementState.isTabbing = false;
      }, 0);
      const modalizer = ctx.modalizer;
      const groupper = ctx.groupper;
      const mover = ctx.mover;
      const callFindNext = (what) => {
        next = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);
        if (currentElement && !(next === null || next === void 0 ? void 0 : next.element)) {
          const parentElement = what !== modalizer && dom.getParentElement(what.getElement());
          if (parentElement) {
            const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {
              referenceElement: parentElement
            });
            if (parentCtx) {
              const currentScopeElement = what.getElement();
              const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild$2(currentScopeElement) || currentScopeElement;
              if (newCurrent) {
                next = _FocusedElementState.findNextTabbable(tabster, parentCtx, container2, newCurrent, parentElement, isBackward, ignoreAccessibility);
                if (next) {
                  next.outOfDOMOrder = true;
                }
              }
            }
          }
        }
      };
      if (groupper && mover) {
        callFindNext(ctx.groupperBeforeMover ? groupper : mover);
      } else if (groupper) {
        callFindNext(groupper);
      } else if (mover) {
        callFindNext(mover);
      } else if (modalizer) {
        callFindNext(modalizer);
      } else {
        const findProps = {
          container: actualContainer,
          currentElement,
          referenceElement,
          ignoreAccessibility,
          useActiveModalizer: true
        };
        const findPropsOut = {};
        const nextElement = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
        next = {
          element: nextElement,
          outOfDOMOrder: findPropsOut.outOfDOMOrder,
          uncontrolled: findPropsOut.uncontrolled
        };
      }
      return next;
    }
  };
  FocusedElementState.isTabbing = false;
  var GroupperDummyManager = class extends DummyInputManager {
    constructor(element, groupper, tabster, sys) {
      super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);
      this._setHandlers((dummyInput, isBackward, relatedTarget) => {
        var _a, _b;
        const container2 = element.get();
        const input = dummyInput.input;
        if (container2 && input) {
          const ctx = RootAPI.getTabsterContext(tabster, input);
          if (ctx) {
            let next;
            next = (_a = groupper.findNextTabbable(relatedTarget || void 0, void 0, isBackward, true)) === null || _a === void 0 ? void 0 : _a.element;
            if (!next) {
              next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, void 0, dummyInput.isOutside ? input : getAdjacentElement(container2, !isBackward), void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
            }
            if (next) {
              nativeFocus(next);
            }
          }
        }
      });
    }
  };
  var Groupper = class extends TabsterPart {
    constructor(tabster, element, onDispose, props, sys) {
      super(tabster, element, props);
      this._shouldTabInside = false;
      this.makeTabbable(false);
      this._onDispose = onDispose;
      if (!tabster.controlTab) {
        this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);
      }
    }
    dispose() {
      var _a;
      this._onDispose(this);
      const element = this._element.get();
      (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
      delete this.dummyManager;
      if (element) {
        if (false) {
          _setInformativeStyle$1(this._element, true);
        }
      }
      delete this._first;
    }
    findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
      const groupperElement = this.getElement();
      if (!groupperElement) {
        return null;
      }
      const currentIsDummy = getDummyInputContainer(currentElement) === groupperElement;
      if (!this._shouldTabInside && currentElement && dom.nodeContains(groupperElement, currentElement) && !currentIsDummy) {
        return {
          element: void 0,
          outOfDOMOrder: true
        };
      }
      const groupperFirstFocusable = this.getFirst(true);
      if (!currentElement || !dom.nodeContains(groupperElement, currentElement) || currentIsDummy) {
        return {
          element: groupperFirstFocusable,
          outOfDOMOrder: true
        };
      }
      const tabster = this._tabster;
      let next = null;
      let outOfDOMOrder = false;
      let uncontrolled;
      if (this._shouldTabInside && groupperFirstFocusable) {
        const findProps = {
          container: groupperElement,
          currentElement,
          referenceElement,
          ignoreAccessibility,
          useActiveModalizer: true
        };
        const findPropsOut = {};
        next = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
        if (!next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {
          next = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
            container: groupperElement,
            ignoreAccessibility,
            useActiveModalizer: true
          }, findPropsOut);
          outOfDOMOrder = true;
        }
        uncontrolled = findPropsOut.uncontrolled;
      }
      return {
        element: next,
        uncontrolled,
        outOfDOMOrder
      };
    }
    makeTabbable(isTabbable) {
      this._shouldTabInside = isTabbable || !this._props.tabbability;
      if (false) {
        _setInformativeStyle$1(this._element, !this._shouldTabInside);
      }
    }
    isActive(noIfFirstIsFocused) {
      var _a;
      const element = this.getElement() || null;
      let isParentActive = true;
      for (let e = dom.getParentElement(element); e; e = dom.getParentElement(e)) {
        const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;
        if (g) {
          if (!g._shouldTabInside) {
            isParentActive = false;
          }
        }
      }
      let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : void 0;
      if (ret && noIfFirstIsFocused) {
        const focused = this._tabster.focusedElement.getFocusedElement();
        if (focused) {
          ret = focused !== this.getFirst(true);
        }
      }
      return ret;
    }
    getFirst(orContainer) {
      var _a;
      const groupperElement = this.getElement();
      let first;
      if (groupperElement) {
        if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {
          return groupperElement;
        }
        first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();
        if (!first) {
          first = this._tabster.focusable.findFirst({
            container: groupperElement,
            useActiveModalizer: true
          }) || void 0;
          if (first) {
            this.setFirst(first);
          }
        }
      }
      return first;
    }
    setFirst(element) {
      if (element) {
        this._first = new WeakHTMLElement(this._tabster.getWindow, element);
      } else {
        delete this._first;
      }
    }
    acceptElement(element, state) {
      const cachedGrouppers = state.cachedGrouppers;
      const parentElement = dom.getParentElement(this.getElement());
      const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);
      const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
      const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupperBeforeMover) ? parentCtxGroupper : void 0;
      let parentGroupperElement;
      const getIsActive = (groupper) => {
        let cached = cachedGrouppers[groupper.id];
        let isActive2;
        if (cached) {
          isActive2 = cached.isActive;
        } else {
          isActive2 = this.isActive(true);
          cached = cachedGrouppers[groupper.id] = {
            isActive: isActive2
          };
        }
        return isActive2;
      };
      if (parentGroupper) {
        parentGroupperElement = parentGroupper.getElement();
        if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && dom.nodeContains(state.container, parentGroupperElement)) {
          state.skippedFocusable = true;
          return NodeFilter.FILTER_REJECT;
        }
      }
      const isActive = getIsActive(this);
      const groupperElement = this.getElement();
      if (groupperElement) {
        if (isActive !== true) {
          if (groupperElement === element && parentCtxGroupper) {
            if (!parentGroupperElement) {
              parentGroupperElement = parentCtxGroupper.getElement();
            }
            if (parentGroupperElement && !getIsActive(parentCtxGroupper) && dom.nodeContains(state.container, parentGroupperElement) && parentGroupperElement !== state.container) {
              state.skippedFocusable = true;
              return NodeFilter.FILTER_REJECT;
            }
          }
          if (groupperElement !== element && dom.nodeContains(groupperElement, element)) {
            state.skippedFocusable = true;
            return NodeFilter.FILTER_REJECT;
          }
          const cached = cachedGrouppers[this.id];
          let first;
          if ("first" in cached) {
            first = cached.first;
          } else {
            first = cached.first = this.getFirst(true);
          }
          if (first && state.acceptCondition(first)) {
            state.rejectElementsFrom = groupperElement;
            state.skippedFocusable = true;
            if (first !== state.from) {
              state.found = true;
              state.foundElement = first;
              return NodeFilter.FILTER_ACCEPT;
            } else {
              return NodeFilter.FILTER_REJECT;
            }
          }
        }
      }
      return void 0;
    }
  };
  var GroupperAPI = class {
    constructor(tabster, getWindow) {
      this._current = {};
      this._grouppers = {};
      this._init = () => {
        const win = this._win();
        this._tabster.focusedElement.subscribeFirst(this._onFocus);
        const doc = win.document;
        const activeElement = dom.getActiveElement(doc);
        if (activeElement) {
          this._onFocus(activeElement);
        }
        doc.addEventListener("mousedown", this._onMouseDown, true);
        win.addEventListener("keydown", this._onKeyDown, true);
        win.addEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
      };
      this._onGroupperDispose = (groupper) => {
        delete this._grouppers[groupper.id];
      };
      this._onFocus = (element) => {
        if (element) {
          this._updateCurrent(element);
        }
      };
      this._onMouseDown = (e) => {
        let target = e.target;
        while (target && !this._tabster.focusable.isFocusable(target)) {
          target = this._tabster.getParent(target);
        }
        if (target) {
          this._updateCurrent(target);
        }
      };
      this._onKeyDown = (event) => {
        if (event.key !== Keys.Enter && event.key !== Keys.Escape) {
          return;
        }
        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
          return;
        }
        const element = this._tabster.focusedElement.getFocusedElement();
        if (element) {
          this.handleKeyPress(element, event);
        }
      };
      this._onMoveFocus = (e) => {
        var _a;
        const element = e.composedPath()[0];
        const action = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.action;
        if (element && action !== void 0 && !e.defaultPrevented) {
          if (action === GroupperMoveFocusActions.Enter) {
            this._enterGroupper(element);
          } else {
            this._escapeGroupper(element);
          }
          e.stopImmediatePropagation();
        }
      };
      this._tabster = tabster;
      this._win = getWindow;
      tabster.queueInit(this._init);
    }
    dispose() {
      const win = this._win();
      this._tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
      this._current = {};
      if (this._updateTimer) {
        win.clearTimeout(this._updateTimer);
        delete this._updateTimer;
      }
      this._tabster.focusedElement.unsubscribe(this._onFocus);
      win.document.removeEventListener("mousedown", this._onMouseDown, true);
      win.removeEventListener("keydown", this._onKeyDown, true);
      win.removeEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
      Object.keys(this._grouppers).forEach((groupperId) => {
        if (this._grouppers[groupperId]) {
          this._grouppers[groupperId].dispose();
          delete this._grouppers[groupperId];
        }
      });
    }
    createGroupper(element, props, sys) {
      if (false) ;
      const tabster = this._tabster;
      const newGroupper = new Groupper(tabster, element, this._onGroupperDispose, props, sys);
      this._grouppers[newGroupper.id] = newGroupper;
      const focusedElement = tabster.focusedElement.getFocusedElement();
      if (focusedElement && dom.nodeContains(element, focusedElement) && !this._updateTimer) {
        this._updateTimer = this._win().setTimeout(() => {
          delete this._updateTimer;
          if (focusedElement === tabster.focusedElement.getFocusedElement()) {
            this._updateCurrent(focusedElement);
          }
        }, 0);
      }
      return newGroupper;
    }
    forgetCurrentGrouppers() {
      this._current = {};
    }
    _updateCurrent(element) {
      var _a;
      if (this._updateTimer) {
        this._win().clearTimeout(this._updateTimer);
        delete this._updateTimer;
      }
      const tabster = this._tabster;
      const newIds = {};
      for (let el = tabster.getParent(element); el; el = tabster.getParent(el)) {
        const groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;
        if (groupper) {
          newIds[groupper.id] = true;
          this._current[groupper.id] = groupper;
          const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);
          groupper.makeTabbable(isTabbable);
        }
      }
      for (const id of Object.keys(this._current)) {
        const groupper = this._current[id];
        if (!(groupper.id in newIds)) {
          groupper.makeTabbable(false);
          groupper.setFirst(void 0);
          delete this._current[id];
        }
      }
    }
    _enterGroupper(element, relatedEvent) {
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, element);
      const groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
      if (groupper && groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {
        const next = tabster.focusable.findNext({
          container: groupperElement,
          currentElement: element,
          useActiveModalizer: true
        });
        if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
          by: "groupper",
          owner: groupperElement,
          next,
          relatedEvent
        })))) {
          if (relatedEvent) {
            relatedEvent.preventDefault();
            relatedEvent.stopImmediatePropagation();
          }
          next.focus();
          return next;
        }
      }
      return null;
    }
    _escapeGroupper(element, relatedEvent, fromModalizer) {
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, element);
      let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
      if (groupper && groupperElement && dom.nodeContains(groupperElement, element)) {
        let next;
        if (element !== groupperElement || fromModalizer) {
          next = groupper.getFirst(true);
        } else {
          const parentElement = dom.getParentElement(groupperElement);
          const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : void 0;
          groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
          next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
        }
        if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
          by: "groupper",
          owner: groupperElement,
          next,
          relatedEvent
        })))) {
          if (groupper) {
            groupper.makeTabbable(false);
          }
          next.focus();
          return next;
        }
      }
      return null;
    }
    moveFocus(element, action) {
      return action === GroupperMoveFocusActions.Enter ? this._enterGroupper(element) : this._escapeGroupper(element);
    }
    handleKeyPress(element, event, fromModalizer) {
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, element);
      if (ctx && ((ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper))) {
        tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
        if (ctx.ignoreKeydown(event)) {
          return;
        }
        if (event.key === Keys.Enter) {
          this._enterGroupper(element, event);
        } else if (event.key === Keys.Escape) {
          const focusedElement = tabster.focusedElement.getFocusedElement();
          tabster.focusedElement.requestAsyncFocus(AsyncFocusSources.EscapeGroupper, () => {
            if (focusedElement !== tabster.focusedElement.getFocusedElement() && // A part of Modalizer that has called this handler to escape the active groupper
            // might have been removed from DOM, if the focus is on body, we still want to handle Esc.
            (fromModalizer && !focusedElement || !fromModalizer)) {
              return;
            }
            this._escapeGroupper(element, event, fromModalizer);
          }, 0);
        }
      }
    }
  };
  var KeyboardNavigationState = class extends Subscribable {
    constructor(getWindow) {
      super();
      this._onChange = (isNavigatingWithKeyboard) => {
        this.setVal(isNavigatingWithKeyboard, void 0);
      };
      this._keyborg = createKeyborg(getWindow());
      this._keyborg.subscribe(this._onChange);
    }
    dispose() {
      super.dispose();
      if (this._keyborg) {
        this._keyborg.unsubscribe(this._onChange);
        disposeKeyborg(this._keyborg);
        delete this._keyborg;
      }
    }
    setNavigatingWithKeyboard(isNavigatingWithKeyboard) {
      var _a;
      (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);
    }
    isNavigatingWithKeyboard() {
      var _a;
      return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());
    }
  };
  var _wasFocusedCounter = 0;
  var _ariaHidden = "aria-hidden";
  var ModalizerDummyManager = class extends DummyInputManager {
    constructor(element, tabster, sys) {
      super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);
      this._setHandlers((dummyInput, isBackward) => {
        var _a, _b;
        const el = element.get();
        const container2 = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());
        const input = dummyInput.input;
        let toFocus;
        if (container2 && input) {
          const dummyContainer = getDummyInputContainer(input);
          const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);
          if (ctx) {
            toFocus = (_b = FocusedElementState.findNextTabbable(tabster, ctx, container2, input, void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
          }
          if (toFocus) {
            nativeFocus(toFocus);
          }
        }
      });
    }
  };
  var Modalizer = class extends TabsterPart {
    constructor(tabster, element, onDispose, props, sys, activeElements) {
      super(tabster, element, props);
      this._wasFocused = 0;
      this.userId = props.id;
      this._onDispose = onDispose;
      this._activeElements = activeElements;
      if (!tabster.controlTab) {
        this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);
      }
      if (false) {
        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
      }
    }
    makeActive(isActive) {
      if (this._isActive !== isActive) {
        this._isActive = isActive;
        const element = this.getElement();
        if (element) {
          const activeElements = this._activeElements;
          const index = activeElements.map((e) => e.get()).indexOf(element);
          if (isActive) {
            if (index < 0) {
              activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element));
            }
          } else {
            if (index >= 0) {
              activeElements.splice(index, 1);
            }
          }
        }
        if (false) {
          _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
        }
        this._dispatchEvent(isActive);
      }
    }
    focused(noIncrement) {
      if (!noIncrement) {
        this._wasFocused = ++_wasFocusedCounter;
      }
      return this._wasFocused;
    }
    setProps(props) {
      if (props.id) {
        this.userId = props.id;
      }
      this._props = {
        ...props
      };
    }
    dispose() {
      var _a;
      this.makeActive(false);
      this._onDispose(this);
      (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
      delete this.dummyManager;
      this._activeElements = [];
      this._remove();
    }
    isActive() {
      return !!this._isActive;
    }
    contains(element) {
      return dom.nodeContains(this.getElement(), element);
    }
    findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
      var _a, _b;
      const modalizerElement = this.getElement();
      if (!modalizerElement) {
        return null;
      }
      const tabster = this._tabster;
      let next = null;
      let outOfDOMOrder = false;
      let uncontrolled;
      const container2 = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());
      if (container2) {
        const findProps = {
          container: container2,
          currentElement,
          referenceElement,
          ignoreAccessibility,
          useActiveModalizer: true
        };
        const findPropsOut = {};
        next = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
        if (!next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
          next = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
            container: container2,
            ignoreAccessibility,
            useActiveModalizer: true
          }, findPropsOut);
          if (next === null) {
            next = currentElement;
          }
          outOfDOMOrder = true;
        } else {
          outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
        }
        uncontrolled = findPropsOut.uncontrolled;
      }
      return {
        element: next,
        uncontrolled,
        outOfDOMOrder
      };
    }
    _dispatchEvent(isActive, allElements) {
      const element = this.getElement();
      let defaultPrevented = false;
      if (element) {
        const elements = allElements ? this._activeElements.map((e) => e.get()) : [element];
        for (const el of elements) {
          if (el) {
            const eventDetail = {
              id: this.userId,
              element
            };
            const event = isActive ? new ModalizerActiveEvent(eventDetail) : new ModalizerInactiveEvent(eventDetail);
            el.dispatchEvent(event);
            if (event.defaultPrevented) {
              defaultPrevented = true;
            }
          }
        }
      }
      return defaultPrevented;
    }
    _remove() {
      if (false) {
        _setInformativeStyle(this._element, true);
      }
    }
  };
  var ModalizerAPI = class {
    constructor(tabster, alwaysAccessibleSelector, accessibleCheck) {
      this._onModalizerDispose = (modalizer) => {
        const id = modalizer.id;
        const userId = modalizer.userId;
        const part = this._parts[userId];
        delete this._modalizers[id];
        if (part) {
          delete part[id];
          if (Object.keys(part).length === 0) {
            delete this._parts[userId];
            const activationHistory = this._activationHistory;
            const cleanActivationHistory = [];
            let prevHistoryItem;
            for (let i = activationHistory.length; i--; ) {
              const modalizerUserIdFromHistory = activationHistory[i];
              if (modalizerUserIdFromHistory === userId) {
                continue;
              }
              if (modalizerUserIdFromHistory !== prevHistoryItem) {
                prevHistoryItem = modalizerUserIdFromHistory;
                if (modalizerUserIdFromHistory || cleanActivationHistory.length > 0) {
                  cleanActivationHistory.unshift(modalizerUserIdFromHistory);
                }
              }
            }
            this._activationHistory = cleanActivationHistory;
            if (this.activeId === userId) {
              const prevActiveId = cleanActivationHistory[0];
              const prevActive = prevActiveId ? Object.values(this._parts[prevActiveId])[0] : void 0;
              this.setActive(prevActive);
            }
          }
        }
      };
      this._onKeyDown = (event) => {
        var _a;
        if (event.key !== Keys.Escape) {
          return;
        }
        const tabster2 = this._tabster;
        const element = tabster2.focusedElement.getFocusedElement();
        if (element) {
          const ctx = RootAPI.getTabsterContext(tabster2, element);
          const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
          if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {
            const activeId = modalizer.userId;
            if (activeId) {
              const part = this._parts[activeId];
              if (part) {
                const focusedSince = Object.keys(part).map((id) => {
                  var _a2;
                  const m = part[id];
                  const el = m.getElement();
                  let groupper;
                  if (el) {
                    groupper = (_a2 = getTabsterOnElement(tabster2, el)) === null || _a2 === void 0 ? void 0 : _a2.groupper;
                  }
                  return m && el && groupper ? {
                    el,
                    focusedSince: m.focused(true)
                  } : {
                    focusedSince: 0
                  };
                }).filter((f) => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);
                if (focusedSince.length) {
                  const groupperElement = focusedSince[0].el;
                  if (groupperElement) {
                    (_a = tabster2.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);
                  }
                }
              }
            }
          }
        }
      };
      this._onFocus = (focusedElement, detail) => {
        var _a;
        const tabster2 = this._tabster;
        const ctx = focusedElement && RootAPI.getTabsterContext(tabster2, focusedElement);
        if (!ctx || !focusedElement) {
          return;
        }
        const augmentedMap = this._augMap;
        for (let e = focusedElement; e; e = dom.getParentElement(e)) {
          if (augmentedMap.has(e)) {
            augmentedMap.delete(e);
            augmentAttribute(tabster2, e, _ariaHidden);
          }
        }
        let modalizer = ctx.modalizer;
        const tabsterOnFocusedElement = getTabsterOnElement(tabster2, focusedElement);
        const modalizerOnFocusedElement = tabsterOnFocusedElement === null || tabsterOnFocusedElement === void 0 ? void 0 : tabsterOnFocusedElement.modalizer;
        if (modalizerOnFocusedElement) {
          modalizerOnFocusedElement.focused();
          if (modalizerOnFocusedElement.userId === this.activeId && tabsterOnFocusedElement.groupper) {
            const parentElement = tabster2.getParent(focusedElement);
            const parentModalizer = parentElement && ((_a = RootAPI.getTabsterContext(tabster2, parentElement)) === null || _a === void 0 ? void 0 : _a.modalizer);
            if (parentModalizer) {
              modalizer = parentModalizer;
            } else {
              this.setActive(void 0);
              return;
            }
          }
        }
        modalizer === null || modalizer === void 0 ? void 0 : modalizer.focused();
        if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {
          this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
          return;
        }
        if (detail.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {
          this.setActive(modalizer);
        } else {
          const win2 = this._win();
          win2.clearTimeout(this._restoreModalizerFocusTimer);
          this._restoreModalizerFocusTimer = win2.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);
        }
      };
      this._tabster = tabster;
      this._win = tabster.getWindow;
      this._modalizers = {};
      this._parts = {};
      this._augMap = /* @__PURE__ */ new WeakMap();
      this._aug = [];
      this._alwaysAccessibleSelector = alwaysAccessibleSelector;
      this._accessibleCheck = accessibleCheck;
      this._activationHistory = [];
      this.activeElements = [];
      if (!tabster.controlTab) {
        tabster.root.addDummyInputs();
      }
      const win = this._win();
      win.addEventListener("keydown", this._onKeyDown, true);
      tabster.queueInit(() => {
        this._tabster.focusedElement.subscribe(this._onFocus);
      });
    }
    dispose() {
      const win = this._win();
      win.removeEventListener("keydown", this._onKeyDown, true);
      Object.keys(this._modalizers).forEach((modalizerId) => {
        if (this._modalizers[modalizerId]) {
          this._modalizers[modalizerId].dispose();
          delete this._modalizers[modalizerId];
        }
      });
      win.clearTimeout(this._restoreModalizerFocusTimer);
      win.clearTimeout(this._hiddenUpdateTimer);
      this._parts = {};
      delete this.activeId;
      this.activeElements = [];
      this._augMap = /* @__PURE__ */ new WeakMap();
      this._aug = [];
      this._tabster.focusedElement.unsubscribe(this._onFocus);
    }
    createModalizer(element, props, sys) {
      var _a;
      if (false) ;
      const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);
      const id = modalizer.id;
      const userId = props.id;
      this._modalizers[id] = modalizer;
      let part = this._parts[userId];
      if (!part) {
        part = this._parts[userId] = {};
      }
      part[id] = modalizer;
      const focusedElement = (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null;
      if (element !== focusedElement && dom.nodeContains(element, focusedElement)) {
        if (userId !== this.activeId) {
          this.setActive(modalizer);
        } else {
          modalizer.makeActive(true);
        }
      }
      return modalizer;
    }
    isAugmented(element) {
      return this._augMap.has(element);
    }
    hiddenUpdate() {
      if (this._hiddenUpdateTimer) {
        return;
      }
      this._hiddenUpdateTimer = this._win().setTimeout(() => {
        delete this._hiddenUpdateTimer;
        this._hiddenUpdate();
      }, 250);
    }
    setActive(modalizer) {
      const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;
      const activeId = this.activeId;
      if (activeId === userId) {
        return;
      }
      this.activeId = userId;
      if (activeId) {
        const part = this._parts[activeId];
        if (part) {
          for (const id of Object.keys(part)) {
            part[id].makeActive(false);
          }
        }
      }
      if (userId) {
        const part = this._parts[userId];
        if (part) {
          for (const id of Object.keys(part)) {
            part[id].makeActive(true);
          }
        }
      }
      this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
      this.hiddenUpdate();
      const activationHistory = this._activationHistory;
      if (activationHistory[0] !== userId && (userId !== void 0 || activationHistory.length > 0)) {
        activationHistory.unshift(userId);
      }
    }
    focus(elementFromModalizer, noFocusFirst, noFocusDefault) {
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, elementFromModalizer);
      const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
      if (modalizer) {
        this.setActive(modalizer);
        const props = modalizer.getProps();
        const modalizerRoot = modalizer.getElement();
        if (modalizerRoot) {
          if (noFocusFirst === void 0) {
            noFocusFirst = props.isNoFocusFirst;
          }
          if (!noFocusFirst && tabster.keyboardNavigation.isNavigatingWithKeyboard() && tabster.focusedElement.focusFirst({
            container: modalizerRoot
          })) {
            return true;
          }
          if (noFocusDefault === void 0) {
            noFocusDefault = props.isNoFocusDefault;
          }
          if (!noFocusDefault && tabster.focusedElement.focusDefault(modalizerRoot)) {
            return true;
          }
          tabster.focusedElement.resetFocus(modalizerRoot);
        }
      } else if (false) {
        console.error("Element is not in Modalizer.", elementFromModalizer);
      }
      return false;
    }
    activate(modalizerElementOrContainer) {
      var _a;
      const modalizerToActivate = modalizerElementOrContainer ? (_a = RootAPI.getTabsterContext(this._tabster, modalizerElementOrContainer)) === null || _a === void 0 ? void 0 : _a.modalizer : void 0;
      if (!modalizerElementOrContainer || modalizerToActivate) {
        this.setActive(modalizerToActivate);
        return true;
      }
      return false;
    }
    acceptElement(element, state) {
      var _a;
      const modalizerUserId = state.modalizerUserId;
      const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;
      if (modalizerUserId) {
        for (const e of this.activeElements) {
          const el = e.get();
          if (el && (dom.nodeContains(element, el) || el === element)) {
            return NodeFilter.FILTER_SKIP;
          }
        }
      }
      const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? void 0 : NodeFilter.FILTER_SKIP;
      if (ret !== void 0) {
        state.skippedFocusable = true;
      }
      return ret;
    }
    _hiddenUpdate() {
      var _a;
      const tabster = this._tabster;
      const body = tabster.getWindow().document.body;
      const activeId = this.activeId;
      const parts = this._parts;
      const visibleElements = [];
      const hiddenElements = [];
      const alwaysAccessibleSelector = this._alwaysAccessibleSelector;
      const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(dom.querySelectorAll(body, alwaysAccessibleSelector)) : [];
      const activeModalizerElements = [];
      for (const userId of Object.keys(parts)) {
        const modalizerParts = parts[userId];
        for (const id of Object.keys(modalizerParts)) {
          const modalizer = modalizerParts[id];
          const el = modalizer.getElement();
          const props = modalizer.getProps();
          const isAlwaysAccessible = props.isAlwaysAccessible;
          if (el) {
            if (userId === activeId) {
              activeModalizerElements.push(el);
              if (!this.currentIsOthersAccessible) {
                visibleElements.push(el);
              }
            } else if (isAlwaysAccessible) {
              alwaysAccessibleElements.push(el);
            } else {
              hiddenElements.push(el);
            }
          }
        }
      }
      const augmentedMap = this._augMap;
      const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : void 0;
      const newAugmented = [];
      const newAugmentedMap = /* @__PURE__ */ new WeakMap();
      const toggle = (element, hide) => {
        var _a2;
        const tagName = element.tagName;
        if (tagName === "SCRIPT" || tagName === "STYLE") {
          return;
        }
        let isAugmented = false;
        if (augmentedMap.has(element)) {
          if (hide) {
            isAugmented = true;
          } else {
            augmentedMap.delete(element);
            augmentAttribute(tabster, element, _ariaHidden);
          }
        } else if (hide && !((_a2 = this._accessibleCheck) === null || _a2 === void 0 ? void 0 : _a2.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, "true")) {
          augmentedMap.set(element, true);
          isAugmented = true;
        }
        if (isAugmented) {
          newAugmented.push(new WeakHTMLElement(tabster.getWindow, element));
          newAugmentedMap.set(element, true);
        }
      };
      const walk = (element) => {
        var _a2;
        for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {
          let skip = false;
          let containsModalizer = false;
          let containedByModalizer = false;
          if (allVisibleElements) {
            const elParent = tabster.getParent(el);
            for (const c of allVisibleElements) {
              if (el === c) {
                skip = true;
                break;
              }
              if (dom.nodeContains(el, c)) {
                containsModalizer = true;
                break;
              } else if (dom.nodeContains(c, elParent)) {
                containedByModalizer = true;
              }
            }
            if (containsModalizer || ((_a2 = el.__tabsterElementFlags) === null || _a2 === void 0 ? void 0 : _a2.noDirectAriaHidden)) {
              walk(el);
            } else if (!skip && !containedByModalizer) {
              toggle(el, true);
            }
          } else {
            toggle(el, false);
          }
        }
      };
      if (!allVisibleElements) {
        alwaysAccessibleElements.forEach((e) => toggle(e, false));
      }
      hiddenElements.forEach((e) => toggle(e, true));
      if (body) {
        walk(body);
      }
      (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map((e) => e.get()).forEach((e) => {
        if (e && !newAugmentedMap.get(e)) {
          toggle(e, false);
        }
      });
      this._aug = newAugmented;
      this._augMap = newAugmentedMap;
    }
    /**
     * Called when an element is focused outside of an active modalizer.
     * Attempts to pull focus back into the active modalizer
     * @param outsideElement - An element being focused outside of the modalizer
     */
    _restoreModalizerFocus(outsideElement) {
      var _a;
      const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;
      if (!outsideElement || !ownerDocument) {
        return;
      }
      const focusedElement = this._tabster.focusedElement.getFocusedElement();
      const focusedElementModalizer = focusedElement && ((_a = RootAPI.getTabsterContext(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer);
      if (!focusedElement || focusedElement && (focusedElementModalizer === null || focusedElementModalizer === void 0 ? void 0 : focusedElementModalizer.userId) === this.activeId) {
        return;
      }
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, outsideElement);
      const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
      const activeId = this.activeId;
      if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {
        return;
      }
      const container2 = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();
      if (container2) {
        let toFocus = tabster.focusable.findFirst({
          container: container2,
          useActiveModalizer: true
        });
        if (toFocus) {
          if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {
            toFocus = tabster.focusable.findLast({
              container: container2,
              useActiveModalizer: true
            });
            if (!toFocus) {
              throw new Error("Something went wrong.");
            }
          }
          tabster.focusedElement.focus(toFocus);
          return;
        }
      }
      outsideElement.blur();
    }
  };
  var _inputSelector = /* @__PURE__ */ ["input", "textarea", "*[contenteditable]"].join(", ");
  var MoverDummyManager = class extends DummyInputManager {
    constructor(element, tabster, getMemorized, sys) {
      super(tabster, element, DummyInputManagerPriorities.Mover, sys);
      this._onFocusDummyInput = (dummyInput) => {
        var _a, _b;
        const container2 = this._element.get();
        const input = dummyInput.input;
        if (container2 && input) {
          const ctx = RootAPI.getTabsterContext(this._tabster, container2);
          let toFocus;
          if (ctx) {
            toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, void 0, input, void 0, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;
          }
          const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();
          if (memorized && this._tabster.focusable.isFocusable(memorized)) {
            toFocus = memorized;
          }
          if (toFocus) {
            nativeFocus(toFocus);
          }
        }
      };
      this._tabster = tabster;
      this._getMemorized = getMemorized;
      this._setHandlers(this._onFocusDummyInput);
    }
  };
  var _moverUpdateAdd = 1;
  var _moverUpdateAttr = 2;
  var _moverUpdateRemove = 3;
  var Mover = class extends TabsterPart {
    constructor(tabster, element, onDispose, props, sys) {
      var _a;
      super(tabster, element, props);
      this._visible = {};
      this._onIntersection = (entries) => {
        for (const entry of entries) {
          const el = entry.target;
          const id = getElementUId(this._win, el);
          let newVisibility;
          let fullyVisible = this._fullyVisible;
          if (entry.intersectionRatio >= 0.25) {
            newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;
            if (newVisibility === Visibilities.Visible) {
              fullyVisible = id;
            }
          } else {
            newVisibility = Visibilities.Invisible;
          }
          if (this._visible[id] !== newVisibility) {
            if (newVisibility === void 0) {
              delete this._visible[id];
              if (fullyVisible === id) {
                delete this._fullyVisible;
              }
            } else {
              this._visible[id] = newVisibility;
              this._fullyVisible = fullyVisible;
            }
            const state = this.getState(el);
            if (state) {
              el.dispatchEvent(new MoverStateEvent(state));
            }
          }
        }
      };
      this._win = tabster.getWindow;
      this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;
      if (this._props.trackState || this._props.visibilityAware) {
        this._intersectionObserver = new IntersectionObserver(this._onIntersection, {
          threshold: [0, 0.25, 0.5, 0.75, 1]
        });
        this._observeState();
      }
      this._onDispose = onDispose;
      const getMemorized = () => props.memorizeCurrent ? this._current : void 0;
      if (!tabster.controlTab) {
        this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);
      }
    }
    dispose() {
      var _a;
      this._onDispose(this);
      if (this._intersectionObserver) {
        this._intersectionObserver.disconnect();
        delete this._intersectionObserver;
      }
      delete this._current;
      delete this._fullyVisible;
      delete this._allElements;
      delete this._updateQueue;
      if (this._unobserve) {
        this._unobserve();
        delete this._unobserve;
      }
      const win = this._win();
      if (this._setCurrentTimer) {
        win.clearTimeout(this._setCurrentTimer);
        delete this._setCurrentTimer;
      }
      if (this._updateTimer) {
        win.clearTimeout(this._updateTimer);
        delete this._updateTimer;
      }
      (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
      delete this.dummyManager;
    }
    setCurrent(element) {
      if (element) {
        this._current = new WeakHTMLElement(this._win, element);
      } else {
        this._current = void 0;
      }
      if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {
        this._setCurrentTimer = this._win().setTimeout(() => {
          var _a;
          delete this._setCurrentTimer;
          const changed = [];
          if (this._current !== this._prevCurrent) {
            changed.push(this._current);
            changed.push(this._prevCurrent);
            this._prevCurrent = this._current;
          }
          for (const weak of changed) {
            const el = weak === null || weak === void 0 ? void 0 : weak.get();
            if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {
              const props = this._props;
              if (el && (props.visibilityAware !== void 0 || props.trackState)) {
                const state = this.getState(el);
                if (state) {
                  el.dispatchEvent(new MoverStateEvent(state));
                }
              }
            }
          }
        });
      }
    }
    getCurrent() {
      var _a;
      return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;
    }
    findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
      const container2 = this.getElement();
      const currentIsDummy = container2 && getDummyInputContainer(currentElement) === container2;
      if (!container2) {
        return null;
      }
      let next = null;
      let outOfDOMOrder = false;
      let uncontrolled;
      if (this._props.tabbable || currentIsDummy || currentElement && !dom.nodeContains(container2, currentElement)) {
        const findProps = {
          currentElement,
          referenceElement,
          container: container2,
          ignoreAccessibility,
          useActiveModalizer: true
        };
        const findPropsOut = {};
        next = this._tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
        uncontrolled = findPropsOut.uncontrolled;
      }
      return {
        element: next,
        uncontrolled,
        outOfDOMOrder
      };
    }
    acceptElement(element, state) {
      var _a, _b;
      if (!FocusedElementState.isTabbing) {
        return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.excludedFromMover) ? NodeFilter.FILTER_REJECT : void 0;
      }
      const {
        memorizeCurrent,
        visibilityAware,
        hasDefault = true
      } = this._props;
      const moverElement = this.getElement();
      if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!dom.nodeContains(moverElement, state.from) || getDummyInputContainer(state.from) === moverElement)) {
        let found;
        if (memorizeCurrent) {
          const current = (_b = this._current) === null || _b === void 0 ? void 0 : _b.get();
          if (current && state.acceptCondition(current)) {
            found = current;
          }
        }
        if (!found && hasDefault) {
          found = this._tabster.focusable.findDefault({
            container: moverElement,
            useActiveModalizer: true
          });
        }
        if (!found && visibilityAware) {
          found = this._tabster.focusable.findElement({
            container: moverElement,
            useActiveModalizer: true,
            isBackward: state.isBackward,
            acceptCondition: (el) => {
              var _a2;
              const id = getElementUId(this._win, el);
              const visibility = this._visible[id];
              return moverElement !== el && !!((_a2 = this._allElements) === null || _a2 === void 0 ? void 0 : _a2.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));
            }
          });
        }
        if (found) {
          state.found = true;
          state.foundElement = found;
          state.rejectElementsFrom = moverElement;
          state.skippedFocusable = true;
          return NodeFilter.FILTER_ACCEPT;
        }
      }
      return void 0;
    }
    _observeState() {
      const element = this.getElement();
      if (this._unobserve || !element || typeof MutationObserver === "undefined") {
        return;
      }
      const win = this._win();
      const allElements = this._allElements = /* @__PURE__ */ new WeakMap();
      const tabsterFocusable = this._tabster.focusable;
      let updateQueue = this._updateQueue = [];
      const observer = dom.createMutationObserver((mutations) => {
        for (const mutation of mutations) {
          const target = mutation.target;
          const removed = mutation.removedNodes;
          const added = mutation.addedNodes;
          if (mutation.type === "attributes") {
            if (mutation.attributeName === "tabindex") {
              updateQueue.push({
                element: target,
                type: _moverUpdateAttr
              });
            }
          } else {
            for (let i = 0; i < removed.length; i++) {
              updateQueue.push({
                element: removed[i],
                type: _moverUpdateRemove
              });
            }
            for (let i = 0; i < added.length; i++) {
              updateQueue.push({
                element: added[i],
                type: _moverUpdateAdd
              });
            }
          }
        }
        requestUpdate();
      });
      const setElement = (element2, remove) => {
        var _a, _b;
        const current = allElements.get(element2);
        if (current && remove) {
          (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element2);
          allElements.delete(element2);
        }
        if (!current && !remove) {
          allElements.set(element2, this);
          (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element2);
        }
      };
      const updateElement = (element2) => {
        const isFocusable = tabsterFocusable.isFocusable(element2);
        const current = allElements.get(element2);
        if (current) {
          if (!isFocusable) {
            setElement(element2, true);
          }
        } else {
          if (isFocusable) {
            setElement(element2);
          }
        }
      };
      const addNewElements = (element2) => {
        const {
          mover
        } = getMoverGroupper(element2);
        if (mover && mover !== this) {
          if (mover.getElement() === element2 && tabsterFocusable.isFocusable(element2)) {
            setElement(element2);
          } else {
            return;
          }
        }
        const walker = createElementTreeWalker(win.document, element2, (node) => {
          const {
            mover: mover2,
            groupper
          } = getMoverGroupper(node);
          if (mover2 && mover2 !== this) {
            return NodeFilter.FILTER_REJECT;
          }
          const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
          if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {
            return NodeFilter.FILTER_REJECT;
          }
          if (tabsterFocusable.isFocusable(node)) {
            setElement(node);
          }
          return NodeFilter.FILTER_SKIP;
        });
        if (walker) {
          walker.currentNode = element2;
          while (walker.nextNode()) {
          }
        }
      };
      const removeWalk = (element2) => {
        const current = allElements.get(element2);
        if (current) {
          setElement(element2, true);
        }
        for (let el = dom.getFirstElementChild(element2); el; el = dom.getNextElementSibling(el)) {
          removeWalk(el);
        }
      };
      const requestUpdate = () => {
        if (!this._updateTimer && updateQueue.length) {
          this._updateTimer = win.setTimeout(() => {
            delete this._updateTimer;
            for (const {
              element: element2,
              type
            } of updateQueue) {
              switch (type) {
                case _moverUpdateAttr:
                  updateElement(element2);
                  break;
                case _moverUpdateAdd:
                  addNewElements(element2);
                  break;
                case _moverUpdateRemove:
                  removeWalk(element2);
                  break;
              }
            }
            updateQueue = this._updateQueue = [];
          }, 0);
        }
      };
      const getMoverGroupper = (element2) => {
        const ret = {};
        for (let el = element2; el; el = dom.getParentElement(el)) {
          const toe = getTabsterOnElement(this._tabster, el);
          if (toe) {
            if (toe.groupper && !ret.groupper) {
              ret.groupper = toe.groupper;
            }
            if (toe.mover) {
              ret.mover = toe.mover;
              break;
            }
          }
        }
        return ret;
      };
      updateQueue.push({
        element,
        type: _moverUpdateAdd
      });
      requestUpdate();
      observer.observe(element, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["tabindex"]
      });
      this._unobserve = () => {
        observer.disconnect();
      };
    }
    getState(element) {
      const id = getElementUId(this._win, element);
      if (id in this._visible) {
        const visibility = this._visible[id] || Visibilities.Invisible;
        const isCurrent = this._current ? this._current.get() === element : void 0;
        return {
          isCurrent,
          visibility
        };
      }
      return void 0;
    }
  };
  function getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
    const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;
    const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;
    return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);
  }
  var MoverAPI = class {
    constructor(tabster, getWindow) {
      this._init = () => {
        const win = this._win();
        win.addEventListener("keydown", this._onKeyDown, true);
        win.addEventListener(MoverMoveFocusEventName, this._onMoveFocus);
        win.addEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
        this._tabster.focusedElement.subscribe(this._onFocus);
      };
      this._onMoverDispose = (mover) => {
        delete this._movers[mover.id];
      };
      this._onFocus = (element) => {
        var _a;
        let currentFocusableElement = element;
        let deepestFocusableElement = element;
        for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {
          const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;
          if (mover) {
            mover.setCurrent(deepestFocusableElement);
            currentFocusableElement = void 0;
          }
          if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) {
            currentFocusableElement = deepestFocusableElement = el;
          }
        }
      };
      this._onKeyDown = async (event) => {
        var _a;
        if (this._ignoredInputTimer) {
          this._win().clearTimeout(this._ignoredInputTimer);
          delete this._ignoredInputTimer;
        }
        (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
          return;
        }
        const key = event.key;
        let moverKey;
        if (key === Keys.ArrowDown) {
          moverKey = MoverKeys.ArrowDown;
        } else if (key === Keys.ArrowRight) {
          moverKey = MoverKeys.ArrowRight;
        } else if (key === Keys.ArrowUp) {
          moverKey = MoverKeys.ArrowUp;
        } else if (key === Keys.ArrowLeft) {
          moverKey = MoverKeys.ArrowLeft;
        } else if (key === Keys.PageDown) {
          moverKey = MoverKeys.PageDown;
        } else if (key === Keys.PageUp) {
          moverKey = MoverKeys.PageUp;
        } else if (key === Keys.Home) {
          moverKey = MoverKeys.Home;
        } else if (key === Keys.End) {
          moverKey = MoverKeys.End;
        }
        if (!moverKey) {
          return;
        }
        const focused = this._tabster.focusedElement.getFocusedElement();
        if (!focused || await this._isIgnoredInput(focused, key)) {
          return;
        }
        this._moveFocus(focused, moverKey, event);
      };
      this._onMoveFocus = (e) => {
        var _a;
        const element = e.composedPath()[0];
        const key = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.key;
        if (element && key !== void 0 && !e.defaultPrevented) {
          this._moveFocus(element, key);
          e.stopImmediatePropagation();
        }
      };
      this._onMemorizedElement = (e) => {
        var _a;
        const target = e.composedPath()[0];
        let memorizedElement = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.memorizedElement;
        if (target) {
          const ctx = RootAPI.getTabsterContext(this._tabster, target);
          const mover = ctx === null || ctx === void 0 ? void 0 : ctx.mover;
          if (mover) {
            if (memorizedElement && !dom.nodeContains(mover.getElement(), memorizedElement)) {
              memorizedElement = void 0;
            }
            mover.setCurrent(memorizedElement);
            e.stopImmediatePropagation();
          }
        }
      };
      this._tabster = tabster;
      this._win = getWindow;
      this._movers = {};
      tabster.queueInit(this._init);
    }
    dispose() {
      var _a;
      const win = this._win();
      this._tabster.focusedElement.unsubscribe(this._onFocus);
      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
      if (this._ignoredInputTimer) {
        win.clearTimeout(this._ignoredInputTimer);
        delete this._ignoredInputTimer;
      }
      win.removeEventListener("keydown", this._onKeyDown, true);
      win.removeEventListener(MoverMoveFocusEventName, this._onMoveFocus);
      win.removeEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
      Object.keys(this._movers).forEach((moverId) => {
        if (this._movers[moverId]) {
          this._movers[moverId].dispose();
          delete this._movers[moverId];
        }
      });
    }
    createMover(element, props, sys) {
      if (false) ;
      const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);
      this._movers[newMover.id] = newMover;
      return newMover;
    }
    moveFocus(fromElement, key) {
      return this._moveFocus(fromElement, key);
    }
    _moveFocus(fromElement, key, relatedEvent) {
      var _a, _b;
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, fromElement, {
        checkRtl: true
      });
      if (!ctx || !ctx.mover || ctx.excludedFromMover || relatedEvent && ctx.ignoreKeydown(relatedEvent)) {
        return null;
      }
      const mover = ctx.mover;
      const container2 = mover.getElement();
      if (ctx.groupperBeforeMover) {
        const groupper = ctx.groupper;
        if (groupper && !groupper.isActive(true)) {
          for (let el = dom.getParentElement(groupper.getElement()); el && el !== container2; el = dom.getParentElement(el)) {
            if ((_b = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper) === null || _b === void 0 ? void 0 : _b.isActive(true)) {
              return null;
            }
          }
        } else {
          return null;
        }
      }
      if (!container2) {
        return null;
      }
      const focusable = tabster.focusable;
      const moverProps = mover.getProps();
      const direction = moverProps.direction || MoverDirections.Both;
      const isBoth = direction === MoverDirections.Both;
      const isVertical = isBoth || direction === MoverDirections.Vertical;
      const isHorizontal = isBoth || direction === MoverDirections.Horizontal;
      const isGridLinear = direction === MoverDirections.GridLinear;
      const isGrid = isGridLinear || direction === MoverDirections.Grid;
      const isCyclic = moverProps.cyclic;
      let next;
      let scrollIntoViewArg;
      let focusedElementRect;
      let focusedElementX1 = 0;
      let focusedElementX2 = 0;
      if (isGrid) {
        focusedElementRect = fromElement.getBoundingClientRect();
        focusedElementX1 = Math.ceil(focusedElementRect.left);
        focusedElementX2 = Math.floor(focusedElementRect.right);
      }
      if (ctx.rtl) {
        if (key === MoverKeys.ArrowRight) {
          key = MoverKeys.ArrowLeft;
        } else if (key === MoverKeys.ArrowLeft) {
          key = MoverKeys.ArrowRight;
        }
      }
      if (key === MoverKeys.ArrowDown && isVertical || key === MoverKeys.ArrowRight && (isHorizontal || isGrid)) {
        next = focusable.findNext({
          currentElement: fromElement,
          container: container2,
          useActiveModalizer: true
        });
        if (next && isGrid) {
          const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);
          if (!isGridLinear && focusedElementX2 > nextElementX1) {
            next = void 0;
          }
        } else if (!next && isCyclic) {
          next = focusable.findFirst({
            container: container2,
            useActiveModalizer: true
          });
        }
      } else if (key === MoverKeys.ArrowUp && isVertical || key === MoverKeys.ArrowLeft && (isHorizontal || isGrid)) {
        next = focusable.findPrev({
          currentElement: fromElement,
          container: container2,
          useActiveModalizer: true
        });
        if (next && isGrid) {
          const nextElementX2 = Math.floor(next.getBoundingClientRect().right);
          if (!isGridLinear && nextElementX2 > focusedElementX1) {
            next = void 0;
          }
        } else if (!next && isCyclic) {
          next = focusable.findLast({
            container: container2,
            useActiveModalizer: true
          });
        }
      } else if (key === MoverKeys.Home) {
        if (isGrid) {
          focusable.findElement({
            container: container2,
            currentElement: fromElement,
            useActiveModalizer: true,
            isBackward: true,
            acceptCondition: (el) => {
              var _a2;
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil((_a2 = el.getBoundingClientRect().left) !== null && _a2 !== void 0 ? _a2 : 0);
              if (el !== fromElement && focusedElementX1 <= nextElementX1) {
                return true;
              }
              next = el;
              return false;
            }
          });
        } else {
          next = focusable.findFirst({
            container: container2,
            useActiveModalizer: true
          });
        }
      } else if (key === MoverKeys.End) {
        if (isGrid) {
          focusable.findElement({
            container: container2,
            currentElement: fromElement,
            useActiveModalizer: true,
            acceptCondition: (el) => {
              var _a2;
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil((_a2 = el.getBoundingClientRect().left) !== null && _a2 !== void 0 ? _a2 : 0);
              if (el !== fromElement && focusedElementX1 >= nextElementX1) {
                return true;
              }
              next = el;
              return false;
            }
          });
        } else {
          next = focusable.findLast({
            container: container2,
            useActiveModalizer: true
          });
        }
      } else if (key === MoverKeys.PageUp) {
        focusable.findElement({
          currentElement: fromElement,
          container: container2,
          useActiveModalizer: true,
          isBackward: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
              next = el;
              return false;
            }
            return true;
          }
        });
        if (isGrid && next) {
          const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);
          focusable.findElement({
            currentElement: next,
            container: container2,
            useActiveModalizer: true,
            acceptCondition: (el) => {
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
              if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {
                return true;
              }
              next = el;
              return false;
            }
          });
        }
        scrollIntoViewArg = false;
      } else if (key === MoverKeys.PageDown) {
        focusable.findElement({
          currentElement: fromElement,
          container: container2,
          useActiveModalizer: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
              next = el;
              return false;
            }
            return true;
          }
        });
        if (isGrid && next) {
          const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);
          focusable.findElement({
            currentElement: next,
            container: container2,
            useActiveModalizer: true,
            isBackward: true,
            acceptCondition: (el) => {
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
              if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {
                return true;
              }
              next = el;
              return false;
            }
          });
        }
        scrollIntoViewArg = true;
      } else if (isGrid) {
        const isBackward = key === MoverKeys.ArrowUp;
        const ax1 = focusedElementX1;
        const ay1 = Math.ceil(focusedElementRect.top);
        const ax2 = focusedElementX2;
        const ay2 = Math.floor(focusedElementRect.bottom);
        let targetElement;
        let lastDistance;
        let lastIntersection = 0;
        focusable.findAll({
          container: container2,
          currentElement: fromElement,
          isBackward,
          onElement: (el) => {
            const rect = el.getBoundingClientRect();
            const bx1 = Math.ceil(rect.left);
            const by1 = Math.ceil(rect.top);
            const bx2 = Math.floor(rect.right);
            const by2 = Math.floor(rect.bottom);
            if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {
              return true;
            }
            const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));
            const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));
            if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {
              const intersection = xIntersectionWidth / minWidth;
              if (intersection > lastIntersection) {
                targetElement = el;
                lastIntersection = intersection;
              }
            } else if (lastIntersection === 0) {
              const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
              if (lastDistance === void 0 || distance < lastDistance) {
                lastDistance = distance;
                targetElement = el;
              }
            } else if (lastIntersection > 0) {
              return false;
            }
            return true;
          }
        });
        next = targetElement;
      }
      if (next && (!relatedEvent || relatedEvent && container2.dispatchEvent(new TabsterMoveFocusEvent({
        by: "mover",
        owner: container2,
        next,
        relatedEvent
      })))) {
        if (scrollIntoViewArg !== void 0) {
          scrollIntoView(this._win, next, scrollIntoViewArg);
        }
        if (relatedEvent) {
          relatedEvent.preventDefault();
          relatedEvent.stopImmediatePropagation();
        }
        nativeFocus(next);
        return next;
      }
      return null;
    }
    async _isIgnoredInput(element, key) {
      if (element.getAttribute("aria-expanded") === "true" && element.hasAttribute("aria-activedescendant")) {
        return true;
      }
      if (matchesSelector(element, _inputSelector)) {
        let selectionStart = 0;
        let selectionEnd = 0;
        let textLength = 0;
        let asyncRet;
        if (element.tagName === "INPUT" || element.tagName === "TEXTAREA") {
          const type = element.type;
          const value = element.value;
          textLength = (value || "").length;
          if (type === "email" || type === "number") {
            if (textLength) {
              const selection = dom.getSelection(element);
              if (selection) {
                const initialLength = selection.toString().length;
                const isBackward = key === Keys.ArrowLeft || key === Keys.ArrowUp;
                selection.modify("extend", isBackward ? "backward" : "forward", "character");
                if (initialLength !== selection.toString().length) {
                  selection.modify("extend", isBackward ? "forward" : "backward", "character");
                  return true;
                } else {
                  textLength = 0;
                }
              }
            }
          } else {
            const selStart = element.selectionStart;
            if (selStart === null) {
              return type === "hidden";
            }
            selectionStart = selStart || 0;
            selectionEnd = element.selectionEnd || 0;
          }
        } else if (element.contentEditable === "true") {
          asyncRet = new (getPromise(this._win))((resolve) => {
            this._ignoredInputResolve = (value) => {
              delete this._ignoredInputResolve;
              resolve(value);
            };
            const win = this._win();
            if (this._ignoredInputTimer) {
              win.clearTimeout(this._ignoredInputTimer);
            }
            const {
              anchorNode: prevAnchorNode,
              focusNode: prevFocusNode,
              anchorOffset: prevAnchorOffset,
              focusOffset: prevFocusOffset
            } = dom.getSelection(element) || {};
            this._ignoredInputTimer = win.setTimeout(() => {
              var _a, _b, _c;
              delete this._ignoredInputTimer;
              const {
                anchorNode,
                focusNode,
                anchorOffset,
                focusOffset
              } = dom.getSelection(element) || {};
              if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {
                (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
                return;
              }
              selectionStart = anchorOffset || 0;
              selectionEnd = focusOffset || 0;
              textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;
              if (anchorNode && focusNode) {
                if (dom.nodeContains(element, anchorNode) && dom.nodeContains(element, focusNode)) {
                  if (anchorNode !== element) {
                    let anchorFound = false;
                    const addOffsets = (node) => {
                      if (node === anchorNode) {
                        anchorFound = true;
                      } else if (node === focusNode) {
                        return true;
                      }
                      const nodeText = node.textContent;
                      if (nodeText && !dom.getFirstChild(node)) {
                        const len = nodeText.length;
                        if (anchorFound) {
                          if (focusNode !== anchorNode) {
                            selectionEnd += len;
                          }
                        } else {
                          selectionStart += len;
                          selectionEnd += len;
                        }
                      }
                      let stop = false;
                      for (let e = dom.getFirstChild(node); e && !stop; e = e.nextSibling) {
                        stop = addOffsets(e);
                      }
                      return stop;
                    };
                    addOffsets(element);
                  }
                }
              }
              (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);
            }, 0);
          });
        }
        if (asyncRet && !await asyncRet) {
          return true;
        }
        if (selectionStart !== selectionEnd) {
          return true;
        }
        if (selectionStart > 0 && (key === Keys.ArrowLeft || key === Keys.ArrowUp || key === Keys.Home)) {
          return true;
        }
        if (selectionStart < textLength && (key === Keys.ArrowRight || key === Keys.ArrowDown || key === Keys.End)) {
          return true;
        }
      }
      return false;
    }
  };
  function observeMutations(doc, tabster, updateTabsterByAttribute2, syncState) {
    if (typeof MutationObserver === "undefined") {
      return () => {
      };
    }
    const getWindow = tabster.getWindow;
    let elementByUId;
    const onMutation = (mutations) => {
      var _a, _b, _c, _d, _e;
      const removedNodes = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        const target = mutation.target;
        const removed = mutation.removedNodes;
        const added = mutation.addedNodes;
        if (mutation.type === "attributes") {
          if (mutation.attributeName === TABSTER_ATTRIBUTE_NAME) {
            if (!removedNodes.has(target)) {
              updateTabsterByAttribute2(tabster, target);
            }
          }
        } else {
          for (let i = 0; i < removed.length; i++) {
            const removedNode = removed[i];
            removedNodes.add(removedNode);
            updateTabsterElements(removedNode, true);
            (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);
          }
          for (let i = 0; i < added.length; i++) {
            updateTabsterElements(added[i]);
            (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);
          }
        }
      }
      removedNodes.clear();
      (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();
    };
    function updateTabsterElements(node, removed) {
      if (!elementByUId) {
        elementByUId = getInstanceContext(getWindow).elementByUId;
      }
      processNode(node, removed);
      const walker = createElementTreeWalker(doc, node, (element) => {
        return processNode(element, removed);
      });
      if (walker) {
        while (walker.nextNode()) {
        }
      }
    }
    function processNode(element, removed) {
      var _a;
      if (!element.getAttribute) {
        return NodeFilter.FILTER_SKIP;
      }
      const uid = element.__tabsterElementUID;
      if (uid && elementByUId) {
        if (removed) {
          delete elementByUId[uid];
        } else {
          (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow, element);
        }
      }
      if (getTabsterOnElement(tabster, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {
        updateTabsterByAttribute2(tabster, element, removed);
      }
      return NodeFilter.FILTER_SKIP;
    }
    const observer = dom.createMutationObserver(onMutation);
    if (syncState) {
      updateTabsterElements(getWindow().document.body);
    }
    observer.observe(doc, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [TABSTER_ATTRIBUTE_NAME]
    });
    return () => {
      observer.disconnect();
    };
  }
  var UncontrolledAPI = class {
    constructor(isUncontrolledCompletely) {
      this._isUncontrolledCompletely = isUncontrolledCompletely;
    }
    isUncontrolledCompletely(element, completely) {
      var _a;
      const isUncontrolledCompletely = (_a = this._isUncontrolledCompletely) === null || _a === void 0 ? void 0 : _a.call(this, element, completely);
      return isUncontrolledCompletely === void 0 ? completely : isUncontrolledCompletely;
    }
  };
  var Restorer = class extends TabsterPart {
    constructor(tabster, element, props) {
      var _a;
      super(tabster, element, props);
      this._hasFocus = false;
      this._onFocusOut = (e) => {
        var _a2;
        const element2 = (_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get();
        if (element2 && e.relatedTarget === null) {
          element2.dispatchEvent(new RestorerRestoreFocusEvent());
        }
        if (element2 && !dom.nodeContains(element2, e.relatedTarget)) {
          this._hasFocus = false;
        }
      };
      this._onFocusIn = () => {
        this._hasFocus = true;
      };
      if (this._props.type === RestorerTypes.Source) {
        const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
        element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("focusout", this._onFocusOut);
        element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("focusin", this._onFocusIn);
        this._hasFocus = dom.nodeContains(element2, element2 && dom.getActiveElement(element2.ownerDocument));
      }
    }
    dispose() {
      var _a;
      if (this._props.type === RestorerTypes.Source) {
        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
        element === null || element === void 0 ? void 0 : element.removeEventListener("focusout", this._onFocusOut);
        element === null || element === void 0 ? void 0 : element.removeEventListener("focusin", this._onFocusIn);
        if (this._hasFocus) {
          const doc = this._tabster.getWindow().document;
          doc.body.dispatchEvent(new RestorerRestoreFocusEvent());
        }
      }
    }
  };
  var History = class _History {
    constructor(getWindow) {
      this._stack = [];
      this._getWindow = getWindow;
    }
    /**
     * Push a weak element to the top of the history stack.
     * If the stack is full, the bottom weak element is removed.
     * If the element is already at the top of the stack, it is not duplicated.
     */
    push(element) {
      var _a;
      if (((_a = this._stack[this._stack.length - 1]) === null || _a === void 0 ? void 0 : _a.get()) === element) {
        return;
      }
      if (this._stack.length > _History.DEPTH) {
        this._stack.shift();
      }
      this._stack.push(new WeakHTMLElement(this._getWindow, element));
    }
    /**
     * Pop the first element from the history that satisfies the callback.
     * The history is searched from the top to the bottom (from the most recent to the least recent).
     *
     * If a weak reference to the element is broken,
     * or the element is no longer in the DOM,
     * the element is removed from the top of the stack while popping.
     *
     * If no matching element is found, undefined is returned.
     * If the stack is empty, undefined is returned.
     */
    pop(filter) {
      if (filter === void 0) {
        filter = () => true;
      }
      var _a;
      const doc = this._getWindow().document;
      for (let index = this._stack.length - 1; index >= 0; index--) {
        const maybeElement = (_a = this._stack.pop()) === null || _a === void 0 ? void 0 : _a.get();
        if (maybeElement && dom.nodeContains(doc.body, dom.getParentElement(maybeElement)) && filter(maybeElement)) {
          return maybeElement;
        }
      }
      return void 0;
    }
  };
  History.DEPTH = 10;
  var RestorerAPI = class {
    constructor(tabster) {
      this._onRestoreFocus = (e) => {
        var _a, _b;
        this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
        const source = e.composedPath()[0];
        if (source) {
          const sourceId = (_b = (_a = getTabsterOnElement(this._tabster, source)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps().id;
          this._focusedElementState.requestAsyncFocus(AsyncFocusSources.Restorer, () => this._restoreFocus(source, sourceId), 0);
        }
      };
      this._onFocusIn = (element) => {
        var _a;
        if (!element) {
          return;
        }
        const tabsterAttribute = getTabsterOnElement(this._tabster, element);
        if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) {
          return;
        }
        this._history.push(element);
      };
      this._restoreFocus = (source, sourceId) => {
        var _a;
        const doc = this._getWindow().document;
        if (dom.getActiveElement(doc) !== doc.body) {
          return;
        }
        if (
          // clicking on any empty space focuses body - this is can be a false positive
          !this._keyboardNavState.isNavigatingWithKeyboard() && // Source no longer exists on DOM - always restore focus
          dom.nodeContains(doc.body, source)
        ) {
          return;
        }
        const getId = (element) => {
          var _a2, _b;
          const restorerProps = (_b = (_a2 = getTabsterOnElement(this._tabster, element)) === null || _a2 === void 0 ? void 0 : _a2.restorer) === null || _b === void 0 ? void 0 : _b.getProps();
          return restorerProps ? restorerProps.id : null;
        };
        (_a = this._history.pop((target) => sourceId === getId(target))) === null || _a === void 0 ? void 0 : _a.focus();
      };
      this._tabster = tabster;
      this._getWindow = tabster.getWindow;
      this._getWindow().addEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
      this._history = new History(this._getWindow);
      this._keyboardNavState = tabster.keyboardNavigation;
      this._focusedElementState = tabster.focusedElement;
      this._focusedElementState.subscribe(this._onFocusIn);
    }
    dispose() {
      const win = this._getWindow();
      this._focusedElementState.unsubscribe(this._onFocusIn);
      this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
      win.removeEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
    }
    createRestorer(element, props) {
      const restorer = new Restorer(this._tabster, element, props);
      if (props.type === RestorerTypes.Target && dom.getActiveElement(element.ownerDocument) === element) {
        this._history.push(element);
      }
      return restorer;
    }
  };
  function nodeContains(node, otherNode) {
    var _a, _b;
    if (!node || !otherNode) {
      return false;
    }
    let currentNode = otherNode;
    while (currentNode) {
      if (currentNode === node) {
        return true;
      }
      if (typeof currentNode.assignedElements !== "function" && ((_a = currentNode.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentNode)) {
        currentNode = (_b = currentNode.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;
      } else if (currentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
        currentNode = currentNode.host;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return false;
  }
  var ShadowMutationObserver = class _ShadowMutationObserver {
    static _overrideAttachShadow(win) {
      const origAttachShadow = win.Element.prototype.attachShadow;
      if (origAttachShadow.__origAttachShadow) {
        return;
      }
      Element.prototype.attachShadow = function(options) {
        const shadowRoot = origAttachShadow.call(this, options);
        for (const shadowObserver of _ShadowMutationObserver._shadowObservers) {
          shadowObserver._addSubObserver(shadowRoot);
        }
        return shadowRoot;
      };
      Element.prototype.attachShadow.__origAttachShadow = origAttachShadow;
    }
    constructor(callback) {
      this._isObserving = false;
      this._callbackWrapper = (mutations, observer) => {
        for (const mutation of mutations) {
          if (mutation.type === "childList") {
            const removed = mutation.removedNodes;
            const added = mutation.addedNodes;
            for (let i = 0; i < removed.length; i++) {
              this._walkShadows(removed[i], true);
            }
            for (let i = 0; i < added.length; i++) {
              this._walkShadows(added[i]);
            }
          }
        }
        this._callback(mutations, observer);
      };
      this._callback = callback;
      this._observer = new MutationObserver(this._callbackWrapper);
      this._subObservers = /* @__PURE__ */ new Map();
    }
    _addSubObserver(shadowRoot) {
      if (!this._options || !this._callback || this._subObservers.has(shadowRoot)) {
        return;
      }
      if (this._options.subtree && nodeContains(this._root, shadowRoot)) {
        const subObserver = new MutationObserver(this._callbackWrapper);
        this._subObservers.set(shadowRoot, subObserver);
        if (this._isObserving) {
          subObserver.observe(shadowRoot, this._options);
        }
        this._walkShadows(shadowRoot);
      }
    }
    disconnect() {
      this._isObserving = false;
      delete this._options;
      _ShadowMutationObserver._shadowObservers.delete(this);
      for (const subObserver of this._subObservers.values()) {
        subObserver.disconnect();
      }
      this._subObservers.clear();
      this._observer.disconnect();
    }
    observe(target, options) {
      const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
      const win = doc === null || doc === void 0 ? void 0 : doc.defaultView;
      if (!doc || !win) {
        return;
      }
      _ShadowMutationObserver._overrideAttachShadow(win);
      _ShadowMutationObserver._shadowObservers.add(this);
      this._root = target;
      this._options = options;
      this._isObserving = true;
      this._observer.observe(target, options);
      this._walkShadows(target);
    }
    _walkShadows(target, remove) {
      const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
      if (!doc) {
        return;
      }
      if (target === doc) {
        target = doc.body;
      } else {
        const shadowRoot = target.shadowRoot;
        if (shadowRoot) {
          this._addSubObserver(shadowRoot);
          return;
        }
      }
      const walker = doc.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (remove) {
              const subObserver = this._subObservers.get(node);
              if (subObserver) {
                subObserver.disconnect();
                this._subObservers.delete(node);
              }
            } else {
              const shadowRoot = node.shadowRoot;
              if (shadowRoot) {
                this._addSubObserver(shadowRoot);
              }
            }
          }
          return NodeFilter.FILTER_SKIP;
        }
      });
      walker.nextNode();
    }
    takeRecords() {
      const records = this._observer.takeRecords();
      for (const subObserver of this._subObservers.values()) {
        records.push(...subObserver.takeRecords());
      }
      return records;
    }
  };
  ShadowMutationObserver._shadowObservers = /* @__PURE__ */ new Set();
  var Tabster = class {
    constructor(tabster) {
      this.keyboardNavigation = tabster.keyboardNavigation;
      this.focusedElement = tabster.focusedElement;
      this.focusable = tabster.focusable;
      this.root = tabster.root;
      this.uncontrolled = tabster.uncontrolled;
      this.core = tabster;
    }
  };
  var TabsterCore = class {
    constructor(win, props) {
      var _a, _b;
      this._forgetMemorizedElements = [];
      this._wrappers = /* @__PURE__ */ new Set();
      this._initQueue = [];
      this._version = "8.5.6";
      this._noop = false;
      this.getWindow = () => {
        if (!this._win) {
          throw new Error("Using disposed Tabster.");
        }
        return this._win;
      };
      this._storage = createWeakMap(win);
      this._win = win;
      const getWindow = this.getWindow;
      if (props === null || props === void 0 ? void 0 : props.DOMAPI) {
        setDOMAPI({
          ...props.DOMAPI
        });
      }
      this.keyboardNavigation = new KeyboardNavigationState(getWindow);
      this.focusedElement = new FocusedElementState(this, getWindow);
      this.focusable = new FocusableAPI(this);
      this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);
      this.uncontrolled = new UncontrolledAPI(
        // TODO: Remove checkUncontrolledTrappingFocus in the next major version.
        (props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus)
      );
      this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;
      this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);
      this._dummyObserver = new DummyInputObserver(getWindow);
      this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : dom.getParentNode;
      this.internal = {
        stopObserver: () => {
          if (this._unobserve) {
            this._unobserve();
            delete this._unobserve;
          }
        },
        resumeObserver: (syncState) => {
          if (!this._unobserve) {
            const doc = getWindow().document;
            this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);
          }
        }
      };
      startFakeWeakRefsCleanup(getWindow);
      this.queueInit(() => {
        this.internal.resumeObserver(true);
      });
    }
    /**
     * Merges external props with the current props. Not all
     * props can/should be mergeable, so let's add more as we move on.
     * @param props Tabster props
     */
    _mergeProps(props) {
      var _a;
      if (!props) {
        return;
      }
      this.getParent = (_a = props.getParent) !== null && _a !== void 0 ? _a : this.getParent;
    }
    createTabster(noRefCount, props) {
      const wrapper = new Tabster(this);
      if (!noRefCount) {
        this._wrappers.add(wrapper);
      }
      this._mergeProps(props);
      return wrapper;
    }
    disposeTabster(wrapper, allInstances) {
      if (allInstances) {
        this._wrappers.clear();
      } else {
        this._wrappers.delete(wrapper);
      }
      if (this._wrappers.size === 0) {
        this.dispose();
      }
    }
    dispose() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.internal.stopObserver();
      const win = this._win;
      win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);
      delete this._initTimer;
      this._initQueue = [];
      this._forgetMemorizedElements = [];
      if (win && this._forgetMemorizedTimer) {
        win.clearTimeout(this._forgetMemorizedTimer);
        delete this._forgetMemorizedTimer;
      }
      (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();
      (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();
      (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();
      (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();
      (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();
      (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();
      this.keyboardNavigation.dispose();
      this.focusable.dispose();
      this.focusedElement.dispose();
      this.root.dispose();
      this._dummyObserver.dispose();
      stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);
      clearElementCache(this.getWindow);
      this._storage = /* @__PURE__ */ new WeakMap();
      this._wrappers.clear();
      if (win) {
        disposeInstanceContext(win);
        delete win.__tabsterInstance;
        delete this._win;
      }
    }
    storageEntry(element, addremove) {
      const storage = this._storage;
      let entry = storage.get(element);
      if (entry) {
        if (addremove === false && Object.keys(entry).length === 0) {
          storage.delete(element);
        }
      } else if (addremove === true) {
        entry = {};
        storage.set(element, entry);
      }
      return entry;
    }
    forceCleanup() {
      if (!this._win) {
        return;
      }
      this._forgetMemorizedElements.push(this._win.document.body);
      if (this._forgetMemorizedTimer) {
        return;
      }
      this._forgetMemorizedTimer = this._win.setTimeout(() => {
        delete this._forgetMemorizedTimer;
        for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {
          clearElementCache(this.getWindow, el);
          FocusedElementState.forgetMemorized(this.focusedElement, el);
        }
      }, 0);
      cleanupFakeWeakRefs(this.getWindow, true);
    }
    queueInit(callback) {
      var _a;
      if (!this._win) {
        return;
      }
      this._initQueue.push(callback);
      if (!this._initTimer) {
        this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {
          delete this._initTimer;
          this.drainInitQueue();
        }, 0);
      }
    }
    drainInitQueue() {
      if (!this._win) {
        return;
      }
      const queue = this._initQueue;
      this._initQueue = [];
      queue.forEach((callback) => callback());
    }
  };
  function createTabster(win, props) {
    let tabster = getCurrentTabster(win);
    if (tabster) {
      return tabster.createTabster(false, props);
    }
    tabster = new TabsterCore(win, props);
    win.__tabsterInstance = tabster;
    return tabster.createTabster();
  }
  function getGroupper(tabster) {
    const tabsterCore = tabster.core;
    if (!tabsterCore.groupper) {
      tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);
    }
    return tabsterCore.groupper;
  }
  function getMover(tabster) {
    const tabsterCore = tabster.core;
    if (!tabsterCore.mover) {
      tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);
    }
    return tabsterCore.mover;
  }
  function getModalizer(tabster, alwaysAccessibleSelector, accessibleCheck) {
    const tabsterCore = tabster.core;
    if (!tabsterCore.modalizer) {
      tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);
    }
    return tabsterCore.modalizer;
  }
  function getRestorer(tabster) {
    const tabsterCore = tabster.core;
    if (!tabsterCore.restorer) {
      tabsterCore.restorer = new RestorerAPI(tabsterCore);
    }
    return tabsterCore.restorer;
  }
  function disposeTabster(tabster, allInstances) {
    tabster.core.disposeTabster(tabster, allInstances);
  }
  function getCurrentTabster(win) {
    return win.__tabsterInstance;
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useTabsterAttributes.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useTabster.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React47 = __toESM(require_react());
  var DEFAULT_FACTORY = (tabster) => {
    return tabster;
  };
  function createTabsterWithConfig(targetDocument) {
    const defaultView = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || void 0;
    const shadowDOMAPI = defaultView === null || defaultView === void 0 ? void 0 : defaultView.__tabsterShadowDOMAPI;
    if (defaultView) {
      return createTabster(defaultView, {
        autoRoot: {},
        controlTab: false,
        getParent,
        checkUncontrolledTrappingFocus: (element) => {
          var _element_firstElementChild;
          return !!((_element_firstElementChild = element.firstElementChild) === null || _element_firstElementChild === void 0 ? void 0 : _element_firstElementChild.hasAttribute("data-is-focus-trap-zone-bumper"));
        },
        DOMAPI: shadowDOMAPI
      });
    }
  }
  function useTabster(factory = DEFAULT_FACTORY) {
    const { targetDocument } = useFluent();
    const factoryResultRef = React47.useRef(null);
    useIsomorphicLayoutEffect2(() => {
      const tabster = createTabsterWithConfig(targetDocument);
      if (tabster) {
        factoryResultRef.current = factory(tabster);
        return () => {
          disposeTabster(tabster);
          factoryResultRef.current = null;
        };
      }
    }, [
      targetDocument,
      factory
    ]);
    if (false) {
      const previousFactory = usePrevious(factory);
      if (previousFactory !== null && previousFactory !== factory) {
        throw new Error([
          "@fluentui/react-tabster: ",
          "The factory function passed to useTabster has changed. This should not ever happen."
        ].join("\n"));
      }
    }
    return factoryResultRef;
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useTabsterAttributes.js
  var React48 = __toESM(require_react());
  var useTabsterAttributes = (props) => {
    useTabster();
    const strAttr = getTabsterAttribute(props, true);
    return React48.useMemo(() => ({
      [TABSTER_ATTRIBUTE_NAME]: strAttr
    }), [
      strAttr
    ]);
  };

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useArrowNavigationGroup.js
  var useArrowNavigationGroup = (options = {}) => {
    const {
      circular,
      axis,
      memorizeCurrent = true,
      tabbable,
      ignoreDefaultKeydown,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      unstable_hasDefault
    } = options;
    useTabster(getMover);
    return useTabsterAttributes({
      mover: {
        cyclic: !!circular,
        direction: axisToMoverDirection(axis !== null && axis !== void 0 ? axis : "vertical"),
        memorizeCurrent,
        tabbable,
        hasDefault: unstable_hasDefault
      },
      ...ignoreDefaultKeydown && {
        focusable: {
          ignoreKeydown: ignoreDefaultKeydown
        }
      }
    });
  };
  function axisToMoverDirection(axis) {
    switch (axis) {
      case "horizontal":
        return MoverDirections.Horizontal;
      case "grid":
        return MoverDirections.Grid;
      case "grid-linear":
        return MoverDirections.GridLinear;
      case "both":
        return MoverDirections.Both;
      case "vertical":
      default:
        return MoverDirections.Vertical;
    }
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusableGroup.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var useFocusableGroup = (options) => {
    useTabster(getGroupper);
    return useTabsterAttributes({
      groupper: {
        tabbability: getTabbability(options === null || options === void 0 ? void 0 : options.tabBehavior)
      },
      focusable: {
        ignoreKeydown: options === null || options === void 0 ? void 0 : options.ignoreDefaultKeydown
      }
    });
  };
  var getTabbability = (tabBehavior) => {
    switch (tabBehavior) {
      case "unlimited":
        return GroupperTabbabilities.Unlimited;
      case "limited":
        return GroupperTabbabilities.Limited;
      case "limited-trap-focus":
        return GroupperTabbabilities.LimitedTrapFocus;
      default:
        return void 0;
    }
  };

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusFinders.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React49 = __toESM(require_react());
  var useFocusFinders = () => {
    const tabsterRef = useTabster();
    const { targetDocument } = useFluent();
    const findAllFocusable = React49.useCallback((container2, acceptCondition) => {
      var _tabsterRef_current;
      return ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findAll({
        container: container2,
        acceptCondition
      })) || [];
    }, [
      tabsterRef
    ]);
    const findFirstFocusable = React49.useCallback((container2) => {
      var _tabsterRef_current;
      return (_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findFirst({
        container: container2
      });
    }, [
      tabsterRef
    ]);
    const findLastFocusable = React49.useCallback((container2) => {
      var _tabsterRef_current;
      return (_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findLast({
        container: container2
      });
    }, [
      tabsterRef
    ]);
    const findNextFocusable = React49.useCallback((currentElement, options = {}) => {
      if (!tabsterRef.current || !targetDocument) {
        return null;
      }
      const { container: container2 = targetDocument.body } = options;
      return tabsterRef.current.focusable.findNext({
        currentElement,
        container: container2
      });
    }, [
      tabsterRef,
      targetDocument
    ]);
    const findPrevFocusable = React49.useCallback((currentElement, options = {}) => {
      if (!tabsterRef.current || !targetDocument) {
        return null;
      }
      const { container: container2 = targetDocument.body } = options;
      return tabsterRef.current.focusable.findPrev({
        currentElement,
        container: container2
      });
    }, [
      tabsterRef,
      targetDocument
    ]);
    return {
      findAllFocusable,
      findFirstFocusable,
      findLastFocusable,
      findNextFocusable,
      findPrevFocusable
    };
  };

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React50 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabster/lib/focus/focusVisiblePolyfill.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabster/lib/focus/constants.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var KEYBOARD_NAV_ATTRIBUTE = "data-keyboard-nav";
  var KEYBOARD_NAV_SELECTOR = `:global([${KEYBOARD_NAV_ATTRIBUTE}])`;
  var FOCUS_VISIBLE_ATTR = "data-fui-focus-visible";
  var FOCUS_WITHIN_ATTR = "data-fui-focus-within";

  // ../../node_modules/@fluentui/react-tabster/lib/focus/focusVisiblePolyfill.js
  function applyFocusVisiblePolyfill(scope, targetWindow) {
    if (alreadyInScope(scope)) {
      return () => void 0;
    }
    const state = {
      current: void 0
    };
    const keyborg = createKeyborg(targetWindow);
    function registerElementIfNavigating(el) {
      if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(el)) {
        state.current = el;
        el.setAttribute(FOCUS_VISIBLE_ATTR, "");
      }
    }
    function disposeCurrentElement() {
      if (state.current) {
        state.current.removeAttribute(FOCUS_VISIBLE_ATTR);
        state.current = void 0;
      }
    }
    keyborg.subscribe((isNavigatingWithKeyboard) => {
      if (!isNavigatingWithKeyboard) {
        disposeCurrentElement();
      } else {
        registerElementIfNavigating(targetWindow.document.activeElement);
      }
    });
    const keyborgListener = (e) => {
      disposeCurrentElement();
      const target = e.composedPath()[0];
      registerElementIfNavigating(target);
    };
    const blurListener = (e) => {
      if (!e.relatedTarget || isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget)) {
        disposeCurrentElement();
      }
    };
    scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
    scope.addEventListener("focusout", blurListener);
    scope.focusVisible = true;
    if (scope.contains(targetWindow.document.activeElement)) {
      registerElementIfNavigating(targetWindow.document.activeElement);
    }
    return () => {
      disposeCurrentElement();
      scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
      scope.removeEventListener("focusout", blurListener);
      scope.focusVisible = void 0;
      disposeKeyborg(keyborg);
    };
  }
  function alreadyInScope(el) {
    if (!el) {
      return false;
    }
    if (el.focusVisible) {
      return true;
    }
    return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
  function useFocusVisible(options = {}) {
    const contextValue = useFluent();
    const scopeRef = React50.useRef(null);
    var _options_targetDocument;
    const targetDocument = (_options_targetDocument = options.targetDocument) !== null && _options_targetDocument !== void 0 ? _options_targetDocument : contextValue.targetDocument;
    React50.useEffect(() => {
      if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && scopeRef.current) {
        return applyFocusVisiblePolyfill(scopeRef.current, targetDocument.defaultView);
      }
    }, [
      scopeRef,
      targetDocument
    ]);
    return scopeRef;
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React51 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabster/lib/focus/focusWithinPolyfill.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function applyFocusWithinPolyfill(element, win) {
    const keyborg = createKeyborg(win);
    keyborg.subscribe((isNavigatingWithKeyboard) => {
      if (!isNavigatingWithKeyboard) {
        removeFocusWithinClass(element);
      }
    });
    const keyborgListener = (e) => {
      if (keyborg.isNavigatingWithKeyboard() && isHTMLElement2(e.target)) {
        applyFocusWithinClass(element);
      }
    };
    const blurListener = (e) => {
      if (!e.relatedTarget || isHTMLElement2(e.relatedTarget) && !element.contains(e.relatedTarget)) {
        removeFocusWithinClass(element);
      }
    };
    element.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
    element.addEventListener("focusout", blurListener);
    return () => {
      element.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
      element.removeEventListener("focusout", blurListener);
      disposeKeyborg(keyborg);
    };
  }
  function applyFocusWithinClass(el) {
    el.setAttribute(FOCUS_WITHIN_ATTR, "");
  }
  function removeFocusWithinClass(el) {
    el.removeAttribute(FOCUS_WITHIN_ATTR);
  }
  function isHTMLElement2(target) {
    if (!target) {
      return false;
    }
    return Boolean(target && typeof target === "object" && "classList" in target && "contains" in target);
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
  function useFocusWithin() {
    const { targetDocument } = useFluent();
    const elementRef = React51.useRef(null);
    React51.useEffect(() => {
      if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && elementRef.current) {
        return applyFocusWithinPolyfill(elementRef.current, targetDocument.defaultView);
      }
    }, [
      elementRef,
      targetDocument
    ]);
    return elementRef;
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useModalAttributes.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var DangerousNeverHiddenAttribute = "data-tabster-never-hide";
  var DangerousNeverHiddenPropObject = {
    [DangerousNeverHiddenAttribute]: ""
  };
  var tabsterAccessibleCheck = (element) => {
    return element.hasAttribute(DangerousNeverHiddenAttribute);
  };
  function initTabsterModules(tabster) {
    getModalizer(tabster, void 0, tabsterAccessibleCheck);
    getRestorer(tabster);
  }
  var useModalAttributes = (options = {}) => {
    const { trapFocus, alwaysFocusable, legacyTrapFocus } = options;
    useTabster(initTabsterModules);
    const id = useId4("modal-", options.id);
    const modalAttributes = useTabsterAttributes({
      restorer: {
        type: RestorerTypes.Source
      },
      ...trapFocus && {
        modalizer: {
          id,
          isOthersAccessible: !trapFocus,
          isAlwaysAccessible: alwaysFocusable,
          isTrapped: legacyTrapFocus && trapFocus
        }
      }
    });
    const triggerAttributes = useTabsterAttributes({
      restorer: {
        type: RestorerTypes.Target
      }
    });
    return {
      modalAttributes,
      triggerAttributes
    };
  };

  // ../../node_modules/@fluentui/react-theme/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/tokens/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/tokens/lib/themes/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/tokens/lib/utils/createLightTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/tokens/lib/alias/lightColorPalette.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/tokens/lib/global/colorPalette.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/tokens/lib/global/colors.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var grey = {
    "2": "#050505",
    "4": "#0a0a0a",
    "6": "#0f0f0f",
    "8": "#141414",
    "10": "#1a1a1a",
    "12": "#1f1f1f",
    "14": "#242424",
    "16": "#292929",
    "18": "#2e2e2e",
    "20": "#333333",
    "22": "#383838",
    "24": "#3d3d3d",
    "26": "#424242",
    "28": "#474747",
    "30": "#4d4d4d",
    "32": "#525252",
    "34": "#575757",
    "36": "#5c5c5c",
    "38": "#616161",
    "40": "#666666",
    "42": "#6b6b6b",
    "44": "#707070",
    "46": "#757575",
    "48": "#7a7a7a",
    "50": "#808080",
    "52": "#858585",
    "54": "#8a8a8a",
    "56": "#8f8f8f",
    "58": "#949494",
    "60": "#999999",
    "62": "#9e9e9e",
    "64": "#a3a3a3",
    "66": "#a8a8a8",
    "68": "#adadad",
    "70": "#b3b3b3",
    "72": "#b8b8b8",
    "74": "#bdbdbd",
    "76": "#c2c2c2",
    "78": "#c7c7c7",
    "80": "#cccccc",
    "82": "#d1d1d1",
    "84": "#d6d6d6",
    "86": "#dbdbdb",
    "88": "#e0e0e0",
    "90": "#e6e6e6",
    "92": "#ebebeb",
    "94": "#f0f0f0",
    "96": "#f5f5f5",
    "98": "#fafafa"
  };
  var whiteAlpha = {
    "5": "rgba(255, 255, 255, 0.05)",
    "10": "rgba(255, 255, 255, 0.1)",
    "20": "rgba(255, 255, 255, 0.2)",
    "30": "rgba(255, 255, 255, 0.3)",
    "40": "rgba(255, 255, 255, 0.4)",
    "50": "rgba(255, 255, 255, 0.5)",
    "60": "rgba(255, 255, 255, 0.6)",
    "70": "rgba(255, 255, 255, 0.7)",
    "80": "rgba(255, 255, 255, 0.8)",
    "90": "rgba(255, 255, 255, 0.9)"
  };
  var blackAlpha = {
    "5": "rgba(0, 0, 0, 0.05)",
    "10": "rgba(0, 0, 0, 0.1)",
    "20": "rgba(0, 0, 0, 0.2)",
    "30": "rgba(0, 0, 0, 0.3)",
    "40": "rgba(0, 0, 0, 0.4)",
    "50": "rgba(0, 0, 0, 0.5)",
    "60": "rgba(0, 0, 0, 0.6)",
    "70": "rgba(0, 0, 0, 0.7)",
    "80": "rgba(0, 0, 0, 0.8)",
    "90": "rgba(0, 0, 0, 0.9)"
  };
  var white = "#ffffff";
  var black = "#000000";
  var darkRed = {
    shade50: "#130204",
    shade40: "#230308",
    shade30: "#420610",
    shade20: "#590815",
    shade10: "#690a19",
    primary: "#750b1c",
    tint10: "#861b2c",
    tint20: "#962f3f",
    tint30: "#ac4f5e",
    tint40: "#d69ca5",
    tint50: "#e9c7cd",
    tint60: "#f9f0f2"
  };
  var cranberry = {
    shade50: "#200205",
    shade40: "#3b0509",
    shade30: "#6e0811",
    shade20: "#960b18",
    shade10: "#b10e1c",
    primary: "#c50f1f",
    tint10: "#cc2635",
    tint20: "#d33f4c",
    tint30: "#dc626d",
    tint40: "#eeacb2",
    tint50: "#f6d1d5",
    tint60: "#fdf3f4"
  };
  var red = {
    shade50: "#210809",
    shade40: "#3f1011",
    shade30: "#751d1f",
    shade20: "#9f282b",
    shade10: "#bc2f32",
    primary: "#d13438",
    tint10: "#d7494c",
    tint20: "#dc5e62",
    tint30: "#e37d80",
    tint40: "#f1bbbc",
    tint50: "#f8dadb",
    tint60: "#fdf6f6"
  };
  var darkOrange = {
    shade50: "#230900",
    shade40: "#411200",
    shade30: "#7a2101",
    shade20: "#a62d01",
    shade10: "#c43501",
    primary: "#da3b01",
    tint10: "#de501c",
    tint20: "#e36537",
    tint30: "#e9835e",
    tint40: "#f4bfab",
    tint50: "#f9dcd1",
    tint60: "#fdf6f3"
  };
  var pumpkin = {
    shade50: "#200d03",
    shade40: "#3d1805",
    shade30: "#712d09",
    shade20: "#9a3d0c",
    shade10: "#b6480e",
    primary: "#ca5010",
    tint10: "#d06228",
    tint20: "#d77440",
    tint30: "#df8e64",
    tint40: "#efc4ad",
    tint50: "#f7dfd2",
    tint60: "#fdf7f4"
  };
  var orange = {
    shade50: "#271002",
    shade40: "#4a1e04",
    shade30: "#8a3707",
    shade20: "#bc4b09",
    shade10: "#de590b",
    primary: "#f7630c",
    tint10: "#f87528",
    tint20: "#f98845",
    tint30: "#faa06b",
    tint40: "#fdcfb4",
    tint50: "#fee5d7",
    tint60: "#fff9f5"
  };
  var peach = {
    shade50: "#291600",
    shade40: "#4d2a00",
    shade30: "#8f4e00",
    shade20: "#c26a00",
    shade10: "#e67e00",
    primary: "#ff8c00",
    tint10: "#ff9a1f",
    tint20: "#ffa83d",
    tint30: "#ffba66",
    tint40: "#ffddb3",
    tint50: "#ffedd6",
    tint60: "#fffaf5"
  };
  var marigold = {
    shade50: "#251a00",
    shade40: "#463100",
    shade30: "#835b00",
    shade20: "#b27c00",
    shade10: "#d39300",
    primary: "#eaa300",
    tint10: "#edad1c",
    tint20: "#efb839",
    tint30: "#f2c661",
    tint40: "#f9e2ae",
    tint50: "#fcefd3",
    tint60: "#fefbf4"
  };
  var yellow = {
    shade50: "#282400",
    shade40: "#4c4400",
    shade30: "#817400",
    shade20: "#c0ad00",
    shade10: "#e4cc00",
    primary: "#fde300",
    tint10: "#fde61e",
    tint20: "#fdea3d",
    tint30: "#feee66",
    tint40: "#fef7b2",
    tint50: "#fffad6",
    tint60: "#fffef5"
  };
  var gold = {
    shade50: "#1f1900",
    shade40: "#3a2f00",
    shade30: "#6c5700",
    shade20: "#937700",
    shade10: "#ae8c00",
    primary: "#c19c00",
    tint10: "#c8a718",
    tint20: "#d0b232",
    tint30: "#dac157",
    tint40: "#ecdfa5",
    tint50: "#f5eece",
    tint60: "#fdfbf2"
  };
  var brass = {
    shade50: "#181202",
    shade40: "#2e2103",
    shade30: "#553e06",
    shade20: "#745408",
    shade10: "#89640a",
    primary: "#986f0b",
    tint10: "#a47d1e",
    tint20: "#b18c34",
    tint30: "#c1a256",
    tint40: "#e0cea2",
    tint50: "#efe4cb",
    tint60: "#fbf8f2"
  };
  var brown = {
    shade50: "#170e07",
    shade40: "#2b1a0e",
    shade30: "#50301a",
    shade20: "#6c4123",
    shade10: "#804d29",
    primary: "#8e562e",
    tint10: "#9c663f",
    tint20: "#a97652",
    tint30: "#bb8f6f",
    tint40: "#ddc3b0",
    tint50: "#edded3",
    tint60: "#faf7f4"
  };
  var forest = {
    shade50: "#0c1501",
    shade40: "#162702",
    shade30: "#294903",
    shade20: "#376304",
    shade10: "#427505",
    primary: "#498205",
    tint10: "#599116",
    tint20: "#6ba02b",
    tint30: "#85b44c",
    tint40: "#bdd99b",
    tint50: "#dbebc7",
    tint60: "#f6faf0"
  };
  var seafoam = {
    shade50: "#002111",
    shade40: "#003d20",
    shade30: "#00723b",
    shade20: "#009b51",
    shade10: "#00b85f",
    primary: "#00cc6a",
    tint10: "#19d279",
    tint20: "#34d889",
    tint30: "#5ae0a0",
    tint40: "#a8f0cd",
    tint50: "#cff7e4",
    tint60: "#f3fdf8"
  };
  var lightGreen = {
    shade50: "#031a02",
    shade40: "#063004",
    shade30: "#0b5a08",
    shade20: "#0e7a0b",
    shade10: "#11910d",
    primary: "#13a10e",
    tint10: "#27ac22",
    tint20: "#3db838",
    tint30: "#5ec75a",
    tint40: "#a7e3a5",
    tint50: "#cef0cd",
    tint60: "#f2fbf2"
  };
  var green = {
    shade50: "#031403",
    shade40: "#052505",
    shade30: "#094509",
    shade20: "#0c5e0c",
    shade10: "#0e700e",
    primary: "#107c10",
    tint10: "#218c21",
    tint20: "#359b35",
    tint30: "#54b054",
    tint40: "#9fd89f",
    tint50: "#c9eac9",
    tint60: "#f1faf1"
  };
  var darkGreen = {
    shade50: "#021102",
    shade40: "#032003",
    shade30: "#063b06",
    shade20: "#085108",
    shade10: "#0a5f0a",
    primary: "#0b6a0b",
    tint10: "#1a7c1a",
    tint20: "#2d8e2d",
    tint30: "#4da64d",
    tint40: "#9ad29a",
    tint50: "#c6e7c6",
    tint60: "#f0f9f0"
  };
  var lightTeal = {
    shade50: "#001d1f",
    shade40: "#00373a",
    shade30: "#00666d",
    shade20: "#008b94",
    shade10: "#00a5af",
    primary: "#00b7c3",
    tint10: "#18bfca",
    tint20: "#32c8d1",
    tint30: "#58d3db",
    tint40: "#a6e9ed",
    tint50: "#cef3f5",
    tint60: "#f2fcfd"
  };
  var teal = {
    shade50: "#001516",
    shade40: "#012728",
    shade30: "#02494c",
    shade20: "#026467",
    shade10: "#037679",
    primary: "#038387",
    tint10: "#159195",
    tint20: "#2aa0a4",
    tint30: "#4cb4b7",
    tint40: "#9bd9db",
    tint50: "#c7ebec",
    tint60: "#f0fafa"
  };
  var steel = {
    shade50: "#000f12",
    shade40: "#001b22",
    shade30: "#00333f",
    shade20: "#004555",
    shade10: "#005265",
    primary: "#005b70",
    tint10: "#0f6c81",
    tint20: "#237d92",
    tint30: "#4496a9",
    tint40: "#94c8d4",
    tint50: "#c3e1e8",
    tint60: "#eff7f9"
  };
  var blue = {
    shade50: "#001322",
    shade40: "#002440",
    shade30: "#004377",
    shade20: "#005ba1",
    shade10: "#006cbf",
    primary: "#0078d4",
    tint10: "#1a86d9",
    tint20: "#3595de",
    tint30: "#5caae5",
    tint40: "#a9d3f2",
    tint50: "#d0e7f8",
    tint60: "#f3f9fd"
  };
  var royalBlue = {
    shade50: "#000c16",
    shade40: "#00172a",
    shade30: "#002c4e",
    shade20: "#003b6a",
    shade10: "#00467e",
    primary: "#004e8c",
    tint10: "#125e9a",
    tint20: "#286fa8",
    tint30: "#4a89ba",
    tint40: "#9abfdc",
    tint50: "#c7dced",
    tint60: "#f0f6fa"
  };
  var cornflower = {
    shade50: "#0d1126",
    shade40: "#182047",
    shade30: "#2c3c85",
    shade20: "#3c51b4",
    shade10: "#4760d5",
    primary: "#4f6bed",
    tint10: "#637cef",
    tint20: "#778df1",
    tint30: "#93a4f4",
    tint40: "#c8d1fa",
    tint50: "#e1e6fc",
    tint60: "#f7f9fe"
  };
  var navy = {
    shade50: "#00061d",
    shade40: "#000c36",
    shade30: "#001665",
    shade20: "#001e89",
    shade10: "#0023a2",
    primary: "#0027b4",
    tint10: "#173bbd",
    tint20: "#3050c6",
    tint30: "#546fd2",
    tint40: "#a3b2e8",
    tint50: "#ccd5f3",
    tint60: "#f2f4fc"
  };
  var lavender = {
    shade50: "#120f25",
    shade40: "#221d46",
    shade30: "#3f3682",
    shade20: "#5649b0",
    shade10: "#6656d1",
    primary: "#7160e8",
    tint10: "#8172eb",
    tint20: "#9184ee",
    tint30: "#a79cf1",
    tint40: "#d2ccf8",
    tint50: "#e7e4fb",
    tint60: "#f9f8fe"
  };
  var purple = {
    shade50: "#0f0717",
    shade40: "#1c0e2b",
    shade30: "#341a51",
    shade20: "#46236e",
    shade10: "#532982",
    primary: "#5c2e91",
    tint10: "#6b3f9e",
    tint20: "#7c52ab",
    tint30: "#9470bd",
    tint40: "#c6b1de",
    tint50: "#e0d3ed",
    tint60: "#f7f4fb"
  };
  var grape = {
    shade50: "#160418",
    shade40: "#29072e",
    shade30: "#4c0d55",
    shade20: "#671174",
    shade10: "#7a1589",
    primary: "#881798",
    tint10: "#952aa4",
    tint20: "#a33fb1",
    tint30: "#b55fc1",
    tint40: "#d9a7e0",
    tint50: "#eaceef",
    tint60: "#faf2fb"
  };
  var berry = {
    shade50: "#1f091d",
    shade40: "#3a1136",
    shade30: "#6d2064",
    shade20: "#932b88",
    shade10: "#af33a1",
    primary: "#c239b3",
    tint10: "#c94cbc",
    tint20: "#d161c4",
    tint30: "#da7ed0",
    tint40: "#edbbe7",
    tint50: "#f5daf2",
    tint60: "#fdf5fc"
  };
  var lilac = {
    shade50: "#1c0b1f",
    shade40: "#35153a",
    shade30: "#63276d",
    shade20: "#863593",
    shade10: "#9f3faf",
    primary: "#b146c2",
    tint10: "#ba58c9",
    tint20: "#c36bd1",
    tint30: "#cf87da",
    tint40: "#e6bfed",
    tint50: "#f2dcf5",
    tint60: "#fcf6fd"
  };
  var pink = {
    shade50: "#24091b",
    shade40: "#441232",
    shade30: "#80215d",
    shade20: "#ad2d7e",
    shade10: "#cd3595",
    primary: "#e43ba6",
    tint10: "#e750b0",
    tint20: "#ea66ba",
    tint30: "#ef85c8",
    tint40: "#f7c0e3",
    tint50: "#fbddf0",
    tint60: "#fef6fb"
  };
  var magenta = {
    shade50: "#1f0013",
    shade40: "#390024",
    shade30: "#6b0043",
    shade20: "#91005a",
    shade10: "#ac006b",
    primary: "#bf0077",
    tint10: "#c71885",
    tint20: "#ce3293",
    tint30: "#d957a8",
    tint40: "#eca5d1",
    tint50: "#f5cee6",
    tint60: "#fcf2f9"
  };
  var plum = {
    shade50: "#13000c",
    shade40: "#240017",
    shade30: "#43002b",
    shade20: "#5a003b",
    shade10: "#6b0045",
    primary: "#77004d",
    tint10: "#87105d",
    tint20: "#98246f",
    tint30: "#ad4589",
    tint40: "#d696c0",
    tint50: "#e9c4dc",
    tint60: "#faf0f6"
  };
  var beige = {
    shade50: "#141313",
    shade40: "#252323",
    shade30: "#444241",
    shade20: "#5d5958",
    shade10: "#6e6968",
    primary: "#7a7574",
    tint10: "#8a8584",
    tint20: "#9a9594",
    tint30: "#afabaa",
    tint40: "#d7d4d4",
    tint50: "#eae8e8",
    tint60: "#faf9f9"
  };
  var mink = {
    shade50: "#0f0e0e",
    shade40: "#1c1b1a",
    shade30: "#343231",
    shade20: "#474443",
    shade10: "#54514f",
    primary: "#5d5a58",
    tint10: "#706d6b",
    tint20: "#84817e",
    tint30: "#9e9b99",
    tint40: "#cecccb",
    tint50: "#e5e4e3",
    tint60: "#f8f8f8"
  };
  var platinum = {
    shade50: "#111314",
    shade40: "#1f2426",
    shade30: "#3b4447",
    shade20: "#505c60",
    shade10: "#5f6d71",
    primary: "#69797e",
    tint10: "#79898d",
    tint20: "#89989d",
    tint30: "#a0adb2",
    tint40: "#cdd6d8",
    tint50: "#e4e9ea",
    tint60: "#f8f9fa"
  };
  var anchor = {
    shade50: "#090a0b",
    shade40: "#111315",
    shade30: "#202427",
    shade20: "#2b3135",
    shade10: "#333a3f",
    primary: "#394146",
    tint10: "#4d565c",
    tint20: "#626c72",
    tint30: "#808a90",
    tint40: "#bcc3c7",
    tint50: "#dbdfe1",
    tint60: "#f6f7f8"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/colorPalette.js
  var statusSharedColors = {
    red,
    green,
    darkOrange,
    yellow,
    berry,
    lightGreen,
    marigold
  };
  var personaSharedColors = {
    darkRed,
    cranberry,
    pumpkin,
    peach,
    gold,
    brass,
    brown,
    forest,
    seafoam,
    darkGreen,
    lightTeal,
    teal,
    steel,
    blue,
    royalBlue,
    cornflower,
    navy,
    lavender,
    purple,
    grape,
    lilac,
    pink,
    magenta,
    plum,
    beige,
    mink,
    platinum,
    anchor
  };
  var mappedStatusColors = {
    cranberry,
    green,
    orange
  };

  // ../../node_modules/@fluentui/tokens/lib/sharedColorNames.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var statusSharedColorNames = [
    "red",
    "green",
    "darkOrange",
    "yellow",
    "berry",
    "lightGreen",
    "marigold"
  ];
  var personaSharedColorNames = [
    "darkRed",
    "cranberry",
    "pumpkin",
    "peach",
    "gold",
    "brass",
    "brown",
    "forest",
    "seafoam",
    "darkGreen",
    "lightTeal",
    "teal",
    "steel",
    "blue",
    "royalBlue",
    "cornflower",
    "navy",
    "lavender",
    "purple",
    "grape",
    "lilac",
    "pink",
    "magenta",
    "plum",
    "beige",
    "mink",
    "platinum",
    "anchor"
  ];

  // ../../node_modules/@fluentui/tokens/lib/statusColorMapping.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var statusColorMapping = {
    success: "green",
    warning: "orange",
    danger: "cranberry"
  };

  // ../../node_modules/@fluentui/tokens/lib/alias/lightColorPalette.js
  var statusColorPaletteTokens = statusSharedColorNames.reduce((acc, sharedColor) => {
    const color = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
    const sharedColorTokens = {
      [`colorPalette${color}Background1`]: statusSharedColors[sharedColor].tint60,
      [`colorPalette${color}Background2`]: statusSharedColors[sharedColor].tint40,
      [`colorPalette${color}Background3`]: statusSharedColors[sharedColor].primary,
      [`colorPalette${color}Foreground1`]: statusSharedColors[sharedColor].shade10,
      [`colorPalette${color}Foreground2`]: statusSharedColors[sharedColor].shade30,
      [`colorPalette${color}Foreground3`]: statusSharedColors[sharedColor].primary,
      [`colorPalette${color}BorderActive`]: statusSharedColors[sharedColor].primary,
      [`colorPalette${color}Border1`]: statusSharedColors[sharedColor].tint40,
      [`colorPalette${color}Border2`]: statusSharedColors[sharedColor].primary
    };
    return Object.assign(acc, sharedColorTokens);
  }, {});
  statusColorPaletteTokens.colorPaletteYellowForeground1 = statusSharedColors.yellow.shade30;
  statusColorPaletteTokens.colorPaletteRedForegroundInverted = statusSharedColors.red.tint20;
  statusColorPaletteTokens.colorPaletteGreenForegroundInverted = statusSharedColors.green.tint20;
  statusColorPaletteTokens.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.tint40;
  var personaColorPaletteTokens = personaSharedColorNames.reduce((acc, sharedColor) => {
    const color = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
    const sharedColorTokens = {
      [`colorPalette${color}Background2`]: personaSharedColors[sharedColor].tint40,
      [`colorPalette${color}Foreground2`]: personaSharedColors[sharedColor].shade30,
      [`colorPalette${color}BorderActive`]: personaSharedColors[sharedColor].primary
    };
    return Object.assign(acc, sharedColorTokens);
  }, {});
  var colorPaletteTokens = {
    ...statusColorPaletteTokens,
    ...personaColorPaletteTokens
  };
  var colorStatusTokens = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
    const color = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
    const statusColorTokens = {
      [`colorStatus${color}Background1`]: mappedStatusColors[sharedColor].tint60,
      [`colorStatus${color}Background2`]: mappedStatusColors[sharedColor].tint40,
      [`colorStatus${color}Background3`]: mappedStatusColors[sharedColor].primary,
      [`colorStatus${color}Foreground1`]: mappedStatusColors[sharedColor].shade10,
      [`colorStatus${color}Foreground2`]: mappedStatusColors[sharedColor].shade30,
      [`colorStatus${color}Foreground3`]: mappedStatusColors[sharedColor].primary,
      [`colorStatus${color}ForegroundInverted`]: mappedStatusColors[sharedColor].tint30,
      [`colorStatus${color}BorderActive`]: mappedStatusColors[sharedColor].primary,
      [`colorStatus${color}Border1`]: mappedStatusColors[sharedColor].tint40,
      [`colorStatus${color}Border2`]: mappedStatusColors[sharedColor].primary
    };
    return Object.assign(acc, statusColorTokens);
  }, {});
  colorStatusTokens.colorStatusDangerBackground3Hover = mappedStatusColors[statusColorMapping.danger].shade10;
  colorStatusTokens.colorStatusDangerBackground3Pressed = mappedStatusColors[statusColorMapping.danger].shade20;
  colorStatusTokens.colorStatusWarningForeground1 = mappedStatusColors[statusColorMapping.warning].shade20;
  colorStatusTokens.colorStatusWarningForeground3 = mappedStatusColors[statusColorMapping.warning].shade20;
  colorStatusTokens.colorStatusWarningBorder2 = mappedStatusColors[statusColorMapping.warning].shade20;

  // ../../node_modules/@fluentui/tokens/lib/alias/lightColor.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var generateColorTokens = (brand) => ({
    colorNeutralForeground1: grey[14],
    colorNeutralForeground1Hover: grey[14],
    colorNeutralForeground1Pressed: grey[14],
    colorNeutralForeground1Selected: grey[14],
    colorNeutralForeground2: grey[26],
    colorNeutralForeground2Hover: grey[14],
    colorNeutralForeground2Pressed: grey[14],
    colorNeutralForeground2Selected: grey[14],
    colorNeutralForeground2BrandHover: brand[80],
    colorNeutralForeground2BrandPressed: brand[70],
    colorNeutralForeground2BrandSelected: brand[80],
    colorNeutralForeground3: grey[38],
    colorNeutralForeground3Hover: grey[26],
    colorNeutralForeground3Pressed: grey[26],
    colorNeutralForeground3Selected: grey[26],
    colorNeutralForeground3BrandHover: brand[80],
    colorNeutralForeground3BrandPressed: brand[70],
    colorNeutralForeground3BrandSelected: brand[80],
    colorNeutralForeground4: grey[44],
    colorNeutralForegroundDisabled: grey[74],
    colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
    colorBrandForegroundLink: brand[70],
    colorBrandForegroundLinkHover: brand[60],
    colorBrandForegroundLinkPressed: brand[40],
    colorBrandForegroundLinkSelected: brand[70],
    colorNeutralForeground2Link: grey[26],
    colorNeutralForeground2LinkHover: grey[14],
    colorNeutralForeground2LinkPressed: grey[14],
    colorNeutralForeground2LinkSelected: grey[14],
    colorCompoundBrandForeground1: brand[80],
    colorCompoundBrandForeground1Hover: brand[70],
    colorCompoundBrandForeground1Pressed: brand[60],
    colorBrandForeground1: brand[80],
    colorBrandForeground2: brand[70],
    colorBrandForeground2Hover: brand[60],
    colorBrandForeground2Pressed: brand[30],
    colorNeutralForeground1Static: grey[14],
    colorNeutralForegroundStaticInverted: white,
    colorNeutralForegroundInverted: white,
    colorNeutralForegroundInvertedHover: white,
    colorNeutralForegroundInvertedPressed: white,
    colorNeutralForegroundInvertedSelected: white,
    colorNeutralForegroundInverted2: white,
    colorNeutralForegroundOnBrand: white,
    colorNeutralForegroundInvertedLink: white,
    colorNeutralForegroundInvertedLinkHover: white,
    colorNeutralForegroundInvertedLinkPressed: white,
    colorNeutralForegroundInvertedLinkSelected: white,
    colorBrandForegroundInverted: brand[100],
    colorBrandForegroundInvertedHover: brand[110],
    colorBrandForegroundInvertedPressed: brand[100],
    colorBrandForegroundOnLight: brand[80],
    colorBrandForegroundOnLightHover: brand[70],
    colorBrandForegroundOnLightPressed: brand[50],
    colorBrandForegroundOnLightSelected: brand[60],
    colorNeutralBackground1: white,
    colorNeutralBackground1Hover: grey[96],
    colorNeutralBackground1Pressed: grey[88],
    colorNeutralBackground1Selected: grey[92],
    colorNeutralBackground2: grey[98],
    colorNeutralBackground2Hover: grey[94],
    colorNeutralBackground2Pressed: grey[86],
    colorNeutralBackground2Selected: grey[90],
    colorNeutralBackground3: grey[96],
    colorNeutralBackground3Hover: grey[92],
    colorNeutralBackground3Pressed: grey[84],
    colorNeutralBackground3Selected: grey[88],
    colorNeutralBackground4: grey[94],
    colorNeutralBackground4Hover: grey[98],
    colorNeutralBackground4Pressed: grey[96],
    colorNeutralBackground4Selected: white,
    colorNeutralBackground5: grey[92],
    colorNeutralBackground5Hover: grey[96],
    colorNeutralBackground5Pressed: grey[94],
    colorNeutralBackground5Selected: grey[98],
    colorNeutralBackground6: grey[90],
    colorNeutralBackgroundInverted: grey[16],
    colorNeutralBackgroundStatic: grey[20],
    colorNeutralBackgroundAlpha: whiteAlpha[50],
    colorNeutralBackgroundAlpha2: whiteAlpha[80],
    colorSubtleBackground: "transparent",
    colorSubtleBackgroundHover: grey[96],
    colorSubtleBackgroundPressed: grey[88],
    colorSubtleBackgroundSelected: grey[92],
    colorSubtleBackgroundLightAlphaHover: whiteAlpha[70],
    colorSubtleBackgroundLightAlphaPressed: whiteAlpha[50],
    colorSubtleBackgroundLightAlphaSelected: "transparent",
    colorSubtleBackgroundInverted: "transparent",
    colorSubtleBackgroundInvertedHover: blackAlpha[10],
    colorSubtleBackgroundInvertedPressed: blackAlpha[30],
    colorSubtleBackgroundInvertedSelected: blackAlpha[20],
    colorTransparentBackground: "transparent",
    colorTransparentBackgroundHover: "transparent",
    colorTransparentBackgroundPressed: "transparent",
    colorTransparentBackgroundSelected: "transparent",
    colorNeutralBackgroundDisabled: grey[94],
    colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
    colorNeutralStencil1: grey[90],
    colorNeutralStencil2: grey[98],
    colorNeutralStencil1Alpha: blackAlpha[10],
    colorNeutralStencil2Alpha: blackAlpha[5],
    colorBackgroundOverlay: blackAlpha[40],
    colorScrollbarOverlay: blackAlpha[50],
    colorBrandBackground: brand[80],
    colorBrandBackgroundHover: brand[70],
    colorBrandBackgroundPressed: brand[40],
    colorBrandBackgroundSelected: brand[60],
    colorCompoundBrandBackground: brand[80],
    colorCompoundBrandBackgroundHover: brand[70],
    colorCompoundBrandBackgroundPressed: brand[60],
    colorBrandBackgroundStatic: brand[80],
    colorBrandBackground2: brand[160],
    colorBrandBackground2Hover: brand[150],
    colorBrandBackground2Pressed: brand[130],
    colorBrandBackground3Static: brand[60],
    colorBrandBackground4Static: brand[40],
    colorBrandBackgroundInverted: white,
    colorBrandBackgroundInvertedHover: brand[160],
    colorBrandBackgroundInvertedPressed: brand[140],
    colorBrandBackgroundInvertedSelected: brand[150],
    colorNeutralCardBackground: grey[98],
    colorNeutralCardBackgroundHover: white,
    colorNeutralCardBackgroundPressed: grey[96],
    colorNeutralCardBackgroundSelected: grey[92],
    colorNeutralCardBackgroundDisabled: grey[94],
    colorNeutralStrokeAccessible: grey[38],
    colorNeutralStrokeAccessibleHover: grey[34],
    colorNeutralStrokeAccessiblePressed: grey[30],
    colorNeutralStrokeAccessibleSelected: brand[80],
    colorNeutralStroke1: grey[82],
    colorNeutralStroke1Hover: grey[78],
    colorNeutralStroke1Pressed: grey[70],
    colorNeutralStroke1Selected: grey[74],
    colorNeutralStroke2: grey[88],
    colorNeutralStroke3: grey[94],
    colorNeutralStrokeSubtle: grey[88],
    colorNeutralStrokeOnBrand: white,
    colorNeutralStrokeOnBrand2: white,
    colorNeutralStrokeOnBrand2Hover: white,
    colorNeutralStrokeOnBrand2Pressed: white,
    colorNeutralStrokeOnBrand2Selected: white,
    colorBrandStroke1: brand[80],
    colorBrandStroke2: brand[140],
    colorBrandStroke2Hover: brand[120],
    colorBrandStroke2Pressed: brand[80],
    colorBrandStroke2Contrast: brand[140],
    colorCompoundBrandStroke: brand[80],
    colorCompoundBrandStrokeHover: brand[70],
    colorCompoundBrandStrokePressed: brand[60],
    colorNeutralStrokeDisabled: grey[88],
    colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
    colorTransparentStroke: "transparent",
    colorTransparentStrokeInteractive: "transparent",
    colorTransparentStrokeDisabled: "transparent",
    colorNeutralStrokeAlpha: blackAlpha[5],
    colorNeutralStrokeAlpha2: whiteAlpha[20],
    colorStrokeFocus1: white,
    colorStrokeFocus2: black,
    colorNeutralShadowAmbient: "rgba(0,0,0,0.12)",
    colorNeutralShadowKey: "rgba(0,0,0,0.14)",
    colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.06)",
    colorNeutralShadowKeyLighter: "rgba(0,0,0,0.07)",
    colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.20)",
    colorNeutralShadowKeyDarker: "rgba(0,0,0,0.24)",
    colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
    colorBrandShadowKey: "rgba(0,0,0,0.25)"
  });

  // ../../node_modules/@fluentui/tokens/lib/global/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/tokens/lib/global/borderRadius.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var borderRadius = {
    borderRadiusNone: "0",
    borderRadiusSmall: "2px",
    borderRadiusMedium: "4px",
    borderRadiusLarge: "6px",
    borderRadiusXLarge: "8px",
    borderRadiusCircular: "10000px"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/curves.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var curves = {
    curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
    curveAccelerateMid: "cubic-bezier(1,0,1,1)",
    curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
    curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
    curveDecelerateMid: "cubic-bezier(0,0,0,1)",
    curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
    curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
    curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
    curveLinear: "cubic-bezier(0,0,1,1)"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/durations.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var durations = {
    durationUltraFast: "50ms",
    durationFaster: "100ms",
    durationFast: "150ms",
    durationNormal: "200ms",
    durationGentle: "250ms",
    durationSlow: "300ms",
    durationSlower: "400ms",
    durationUltraSlow: "500ms"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/fonts.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var fontSizes = {
    fontSizeBase100: "10px",
    fontSizeBase200: "12px",
    fontSizeBase300: "14px",
    fontSizeBase400: "16px",
    fontSizeBase500: "20px",
    fontSizeBase600: "24px",
    fontSizeHero700: "28px",
    fontSizeHero800: "32px",
    fontSizeHero900: "40px",
    fontSizeHero1000: "68px"
  };
  var lineHeights = {
    lineHeightBase100: "14px",
    lineHeightBase200: "16px",
    lineHeightBase300: "20px",
    lineHeightBase400: "22px",
    lineHeightBase500: "28px",
    lineHeightBase600: "32px",
    lineHeightHero700: "36px",
    lineHeightHero800: "40px",
    lineHeightHero900: "52px",
    lineHeightHero1000: "92px"
  };
  var fontWeights = {
    fontWeightRegular: 400,
    fontWeightMedium: 500,
    fontWeightSemibold: 600,
    fontWeightBold: 700
  };
  var fontFamilies = {
    fontFamilyBase: "'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif",
    fontFamilyMonospace: "Consolas, 'Courier New', Courier, monospace",
    fontFamilyNumeric: "Bahnschrift, 'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/spacings.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var spacings = {
    none: "0",
    xxs: "2px",
    xs: "4px",
    sNudge: "6px",
    s: "8px",
    mNudge: "10px",
    m: "12px",
    l: "16px",
    xl: "20px",
    xxl: "24px",
    xxxl: "32px"
  };
  var horizontalSpacings = {
    spacingHorizontalNone: spacings.none,
    spacingHorizontalXXS: spacings.xxs,
    spacingHorizontalXS: spacings.xs,
    spacingHorizontalSNudge: spacings.sNudge,
    spacingHorizontalS: spacings.s,
    spacingHorizontalMNudge: spacings.mNudge,
    spacingHorizontalM: spacings.m,
    spacingHorizontalL: spacings.l,
    spacingHorizontalXL: spacings.xl,
    spacingHorizontalXXL: spacings.xxl,
    spacingHorizontalXXXL: spacings.xxxl
  };
  var verticalSpacings = {
    spacingVerticalNone: spacings.none,
    spacingVerticalXXS: spacings.xxs,
    spacingVerticalXS: spacings.xs,
    spacingVerticalSNudge: spacings.sNudge,
    spacingVerticalS: spacings.s,
    spacingVerticalMNudge: spacings.mNudge,
    spacingVerticalM: spacings.m,
    spacingVerticalL: spacings.l,
    spacingVerticalXL: spacings.xl,
    spacingVerticalXXL: spacings.xxl,
    spacingVerticalXXXL: spacings.xxxl
  };

  // ../../node_modules/@fluentui/tokens/lib/global/strokeWidths.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var strokeWidths = {
    strokeWidthThin: "1px",
    strokeWidthThick: "2px",
    strokeWidthThicker: "3px",
    strokeWidthThickest: "4px"
  };

  // ../../node_modules/@fluentui/tokens/lib/tokens.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var tokens = {
    // Color tokens
    colorNeutralForeground1: "var(--colorNeutralForeground1)",
    colorNeutralForeground1Hover: "var(--colorNeutralForeground1Hover)",
    colorNeutralForeground1Pressed: "var(--colorNeutralForeground1Pressed)",
    colorNeutralForeground1Selected: "var(--colorNeutralForeground1Selected)",
    colorNeutralForeground2: "var(--colorNeutralForeground2)",
    colorNeutralForeground2Hover: "var(--colorNeutralForeground2Hover)",
    colorNeutralForeground2Pressed: "var(--colorNeutralForeground2Pressed)",
    colorNeutralForeground2Selected: "var(--colorNeutralForeground2Selected)",
    colorNeutralForeground2BrandHover: "var(--colorNeutralForeground2BrandHover)",
    colorNeutralForeground2BrandPressed: "var(--colorNeutralForeground2BrandPressed)",
    colorNeutralForeground2BrandSelected: "var(--colorNeutralForeground2BrandSelected)",
    colorNeutralForeground3: "var(--colorNeutralForeground3)",
    colorNeutralForeground3Hover: "var(--colorNeutralForeground3Hover)",
    colorNeutralForeground3Pressed: "var(--colorNeutralForeground3Pressed)",
    colorNeutralForeground3Selected: "var(--colorNeutralForeground3Selected)",
    colorNeutralForeground3BrandHover: "var(--colorNeutralForeground3BrandHover)",
    colorNeutralForeground3BrandPressed: "var(--colorNeutralForeground3BrandPressed)",
    colorNeutralForeground3BrandSelected: "var(--colorNeutralForeground3BrandSelected)",
    colorNeutralForeground4: "var(--colorNeutralForeground4)",
    colorNeutralForegroundDisabled: "var(--colorNeutralForegroundDisabled)",
    colorBrandForegroundLink: "var(--colorBrandForegroundLink)",
    colorBrandForegroundLinkHover: "var(--colorBrandForegroundLinkHover)",
    colorBrandForegroundLinkPressed: "var(--colorBrandForegroundLinkPressed)",
    colorBrandForegroundLinkSelected: "var(--colorBrandForegroundLinkSelected)",
    colorNeutralForeground2Link: "var(--colorNeutralForeground2Link)",
    colorNeutralForeground2LinkHover: "var(--colorNeutralForeground2LinkHover)",
    colorNeutralForeground2LinkPressed: "var(--colorNeutralForeground2LinkPressed)",
    colorNeutralForeground2LinkSelected: "var(--colorNeutralForeground2LinkSelected)",
    colorCompoundBrandForeground1: "var(--colorCompoundBrandForeground1)",
    colorCompoundBrandForeground1Hover: "var(--colorCompoundBrandForeground1Hover)",
    colorCompoundBrandForeground1Pressed: "var(--colorCompoundBrandForeground1Pressed)",
    colorNeutralForegroundOnBrand: "var(--colorNeutralForegroundOnBrand)",
    colorNeutralForegroundInverted: "var(--colorNeutralForegroundInverted)",
    colorNeutralForegroundInvertedHover: "var(--colorNeutralForegroundInvertedHover)",
    colorNeutralForegroundInvertedPressed: "var(--colorNeutralForegroundInvertedPressed)",
    colorNeutralForegroundInvertedSelected: "var(--colorNeutralForegroundInvertedSelected)",
    colorNeutralForegroundInverted2: "var(--colorNeutralForegroundInverted2)",
    colorNeutralForegroundStaticInverted: "var(--colorNeutralForegroundStaticInverted)",
    colorNeutralForegroundInvertedLink: "var(--colorNeutralForegroundInvertedLink)",
    colorNeutralForegroundInvertedLinkHover: "var(--colorNeutralForegroundInvertedLinkHover)",
    colorNeutralForegroundInvertedLinkPressed: "var(--colorNeutralForegroundInvertedLinkPressed)",
    colorNeutralForegroundInvertedLinkSelected: "var(--colorNeutralForegroundInvertedLinkSelected)",
    colorNeutralForegroundInvertedDisabled: "var(--colorNeutralForegroundInvertedDisabled)",
    colorBrandForeground1: "var(--colorBrandForeground1)",
    colorBrandForeground2: "var(--colorBrandForeground2)",
    colorBrandForeground2Hover: "var(--colorBrandForeground2Hover)",
    colorBrandForeground2Pressed: "var(--colorBrandForeground2Pressed)",
    colorNeutralForeground1Static: "var(--colorNeutralForeground1Static)",
    colorBrandForegroundInverted: "var(--colorBrandForegroundInverted)",
    colorBrandForegroundInvertedHover: "var(--colorBrandForegroundInvertedHover)",
    colorBrandForegroundInvertedPressed: "var(--colorBrandForegroundInvertedPressed)",
    colorBrandForegroundOnLight: "var(--colorBrandForegroundOnLight)",
    colorBrandForegroundOnLightHover: "var(--colorBrandForegroundOnLightHover)",
    colorBrandForegroundOnLightPressed: "var(--colorBrandForegroundOnLightPressed)",
    colorBrandForegroundOnLightSelected: "var(--colorBrandForegroundOnLightSelected)",
    colorNeutralBackground1: "var(--colorNeutralBackground1)",
    colorNeutralBackground1Hover: "var(--colorNeutralBackground1Hover)",
    colorNeutralBackground1Pressed: "var(--colorNeutralBackground1Pressed)",
    colorNeutralBackground1Selected: "var(--colorNeutralBackground1Selected)",
    colorNeutralBackground2: "var(--colorNeutralBackground2)",
    colorNeutralBackground2Hover: "var(--colorNeutralBackground2Hover)",
    colorNeutralBackground2Pressed: "var(--colorNeutralBackground2Pressed)",
    colorNeutralBackground2Selected: "var(--colorNeutralBackground2Selected)",
    colorNeutralBackground3: "var(--colorNeutralBackground3)",
    colorNeutralBackground3Hover: "var(--colorNeutralBackground3Hover)",
    colorNeutralBackground3Pressed: "var(--colorNeutralBackground3Pressed)",
    colorNeutralBackground3Selected: "var(--colorNeutralBackground3Selected)",
    colorNeutralBackground4: "var(--colorNeutralBackground4)",
    colorNeutralBackground4Hover: "var(--colorNeutralBackground4Hover)",
    colorNeutralBackground4Pressed: "var(--colorNeutralBackground4Pressed)",
    colorNeutralBackground4Selected: "var(--colorNeutralBackground4Selected)",
    colorNeutralBackground5: "var(--colorNeutralBackground5)",
    colorNeutralBackground5Hover: "var(--colorNeutralBackground5Hover)",
    colorNeutralBackground5Pressed: "var(--colorNeutralBackground5Pressed)",
    colorNeutralBackground5Selected: "var(--colorNeutralBackground5Selected)",
    colorNeutralBackground6: "var(--colorNeutralBackground6)",
    colorNeutralBackgroundInverted: "var(--colorNeutralBackgroundInverted)",
    colorNeutralBackgroundStatic: "var(--colorNeutralBackgroundStatic)",
    colorNeutralBackgroundAlpha: "var(--colorNeutralBackgroundAlpha)",
    colorNeutralBackgroundAlpha2: "var(--colorNeutralBackgroundAlpha2)",
    colorSubtleBackground: "var(--colorSubtleBackground)",
    colorSubtleBackgroundHover: "var(--colorSubtleBackgroundHover)",
    colorSubtleBackgroundPressed: "var(--colorSubtleBackgroundPressed)",
    colorSubtleBackgroundSelected: "var(--colorSubtleBackgroundSelected)",
    colorSubtleBackgroundLightAlphaHover: "var(--colorSubtleBackgroundLightAlphaHover)",
    colorSubtleBackgroundLightAlphaPressed: "var(--colorSubtleBackgroundLightAlphaPressed)",
    colorSubtleBackgroundLightAlphaSelected: "var(--colorSubtleBackgroundLightAlphaSelected)",
    colorSubtleBackgroundInverted: "var(--colorSubtleBackgroundInverted)",
    colorSubtleBackgroundInvertedHover: "var(--colorSubtleBackgroundInvertedHover)",
    colorSubtleBackgroundInvertedPressed: "var(--colorSubtleBackgroundInvertedPressed)",
    colorSubtleBackgroundInvertedSelected: "var(--colorSubtleBackgroundInvertedSelected)",
    colorTransparentBackground: "var(--colorTransparentBackground)",
    colorTransparentBackgroundHover: "var(--colorTransparentBackgroundHover)",
    colorTransparentBackgroundPressed: "var(--colorTransparentBackgroundPressed)",
    colorTransparentBackgroundSelected: "var(--colorTransparentBackgroundSelected)",
    colorNeutralBackgroundDisabled: "var(--colorNeutralBackgroundDisabled)",
    colorNeutralBackgroundInvertedDisabled: "var(--colorNeutralBackgroundInvertedDisabled)",
    colorNeutralStencil1: "var(--colorNeutralStencil1)",
    colorNeutralStencil2: "var(--colorNeutralStencil2)",
    colorNeutralStencil1Alpha: "var(--colorNeutralStencil1Alpha)",
    colorNeutralStencil2Alpha: "var(--colorNeutralStencil2Alpha)",
    colorBackgroundOverlay: "var(--colorBackgroundOverlay)",
    colorScrollbarOverlay: "var(--colorScrollbarOverlay)",
    colorBrandBackground: "var(--colorBrandBackground)",
    colorBrandBackgroundHover: "var(--colorBrandBackgroundHover)",
    colorBrandBackgroundPressed: "var(--colorBrandBackgroundPressed)",
    colorBrandBackgroundSelected: "var(--colorBrandBackgroundSelected)",
    colorCompoundBrandBackground: "var(--colorCompoundBrandBackground)",
    colorCompoundBrandBackgroundHover: "var(--colorCompoundBrandBackgroundHover)",
    colorCompoundBrandBackgroundPressed: "var(--colorCompoundBrandBackgroundPressed)",
    colorBrandBackgroundStatic: "var(--colorBrandBackgroundStatic)",
    colorBrandBackground2: "var(--colorBrandBackground2)",
    colorBrandBackground2Hover: "var(--colorBrandBackground2Hover)",
    colorBrandBackground2Pressed: "var(--colorBrandBackground2Pressed)",
    colorBrandBackground3Static: "var(--colorBrandBackground3Static)",
    colorBrandBackground4Static: "var(--colorBrandBackground4Static)",
    colorBrandBackgroundInverted: "var(--colorBrandBackgroundInverted)",
    colorBrandBackgroundInvertedHover: "var(--colorBrandBackgroundInvertedHover)",
    colorBrandBackgroundInvertedPressed: "var(--colorBrandBackgroundInvertedPressed)",
    colorBrandBackgroundInvertedSelected: "var(--colorBrandBackgroundInvertedSelected)",
    colorNeutralCardBackground: "var(--colorNeutralCardBackground)",
    colorNeutralCardBackgroundHover: "var(--colorNeutralCardBackgroundHover)",
    colorNeutralCardBackgroundPressed: "var(--colorNeutralCardBackgroundPressed)",
    colorNeutralCardBackgroundSelected: "var(--colorNeutralCardBackgroundSelected)",
    colorNeutralCardBackgroundDisabled: "var(--colorNeutralCardBackgroundDisabled)",
    colorNeutralStrokeAccessible: "var(--colorNeutralStrokeAccessible)",
    colorNeutralStrokeAccessibleHover: "var(--colorNeutralStrokeAccessibleHover)",
    colorNeutralStrokeAccessiblePressed: "var(--colorNeutralStrokeAccessiblePressed)",
    colorNeutralStrokeAccessibleSelected: "var(--colorNeutralStrokeAccessibleSelected)",
    colorNeutralStroke1: "var(--colorNeutralStroke1)",
    colorNeutralStroke1Hover: "var(--colorNeutralStroke1Hover)",
    colorNeutralStroke1Pressed: "var(--colorNeutralStroke1Pressed)",
    colorNeutralStroke1Selected: "var(--colorNeutralStroke1Selected)",
    colorNeutralStroke2: "var(--colorNeutralStroke2)",
    colorNeutralStroke3: "var(--colorNeutralStroke3)",
    colorNeutralStrokeSubtle: "var(--colorNeutralStrokeSubtle)",
    colorNeutralStrokeOnBrand: "var(--colorNeutralStrokeOnBrand)",
    colorNeutralStrokeOnBrand2: "var(--colorNeutralStrokeOnBrand2)",
    colorNeutralStrokeOnBrand2Hover: "var(--colorNeutralStrokeOnBrand2Hover)",
    colorNeutralStrokeOnBrand2Pressed: "var(--colorNeutralStrokeOnBrand2Pressed)",
    colorNeutralStrokeOnBrand2Selected: "var(--colorNeutralStrokeOnBrand2Selected)",
    colorBrandStroke1: "var(--colorBrandStroke1)",
    colorBrandStroke2: "var(--colorBrandStroke2)",
    colorBrandStroke2Hover: "var(--colorBrandStroke2Hover)",
    colorBrandStroke2Pressed: "var(--colorBrandStroke2Pressed)",
    colorBrandStroke2Contrast: "var(--colorBrandStroke2Contrast)",
    colorCompoundBrandStroke: "var(--colorCompoundBrandStroke)",
    colorCompoundBrandStrokeHover: "var(--colorCompoundBrandStrokeHover)",
    colorCompoundBrandStrokePressed: "var(--colorCompoundBrandStrokePressed)",
    colorNeutralStrokeDisabled: "var(--colorNeutralStrokeDisabled)",
    colorNeutralStrokeInvertedDisabled: "var(--colorNeutralStrokeInvertedDisabled)",
    colorTransparentStroke: "var(--colorTransparentStroke)",
    colorTransparentStrokeInteractive: "var(--colorTransparentStrokeInteractive)",
    colorTransparentStrokeDisabled: "var(--colorTransparentStrokeDisabled)",
    colorNeutralStrokeAlpha: "var(--colorNeutralStrokeAlpha)",
    colorNeutralStrokeAlpha2: "var(--colorNeutralStrokeAlpha2)",
    colorStrokeFocus1: "var(--colorStrokeFocus1)",
    colorStrokeFocus2: "var(--colorStrokeFocus2)",
    colorNeutralShadowAmbient: "var(--colorNeutralShadowAmbient)",
    colorNeutralShadowKey: "var(--colorNeutralShadowKey)",
    colorNeutralShadowAmbientLighter: "var(--colorNeutralShadowAmbientLighter)",
    colorNeutralShadowKeyLighter: "var(--colorNeutralShadowKeyLighter)",
    colorNeutralShadowAmbientDarker: "var(--colorNeutralShadowAmbientDarker)",
    colorNeutralShadowKeyDarker: "var(--colorNeutralShadowKeyDarker)",
    colorBrandShadowAmbient: "var(--colorBrandShadowAmbient)",
    colorBrandShadowKey: "var(--colorBrandShadowKey)",
    // Color palette tokens
    // Color palette red tokens
    colorPaletteRedBackground1: "var(--colorPaletteRedBackground1)",
    colorPaletteRedBackground2: "var(--colorPaletteRedBackground2)",
    colorPaletteRedBackground3: "var(--colorPaletteRedBackground3)",
    colorPaletteRedBorderActive: "var(--colorPaletteRedBorderActive)",
    colorPaletteRedBorder1: "var(--colorPaletteRedBorder1)",
    colorPaletteRedBorder2: "var(--colorPaletteRedBorder2)",
    colorPaletteRedForeground1: "var(--colorPaletteRedForeground1)",
    colorPaletteRedForeground2: "var(--colorPaletteRedForeground2)",
    colorPaletteRedForeground3: "var(--colorPaletteRedForeground3)",
    colorPaletteRedForegroundInverted: "var(--colorPaletteRedForegroundInverted)",
    // Color palette green tokens
    colorPaletteGreenBackground1: "var(--colorPaletteGreenBackground1)",
    colorPaletteGreenBackground2: "var(--colorPaletteGreenBackground2)",
    colorPaletteGreenBackground3: "var(--colorPaletteGreenBackground3)",
    colorPaletteGreenBorderActive: "var(--colorPaletteGreenBorderActive)",
    colorPaletteGreenBorder1: "var(--colorPaletteGreenBorder1)",
    colorPaletteGreenBorder2: "var(--colorPaletteGreenBorder2)",
    colorPaletteGreenForeground1: "var(--colorPaletteGreenForeground1)",
    colorPaletteGreenForeground2: "var(--colorPaletteGreenForeground2)",
    colorPaletteGreenForeground3: "var(--colorPaletteGreenForeground3)",
    colorPaletteGreenForegroundInverted: "var(--colorPaletteGreenForegroundInverted)",
    // Color palette dark orange tokens
    colorPaletteDarkOrangeBackground1: "var(--colorPaletteDarkOrangeBackground1)",
    colorPaletteDarkOrangeBackground2: "var(--colorPaletteDarkOrangeBackground2)",
    colorPaletteDarkOrangeBackground3: "var(--colorPaletteDarkOrangeBackground3)",
    colorPaletteDarkOrangeBorderActive: "var(--colorPaletteDarkOrangeBorderActive)",
    colorPaletteDarkOrangeBorder1: "var(--colorPaletteDarkOrangeBorder1)",
    colorPaletteDarkOrangeBorder2: "var(--colorPaletteDarkOrangeBorder2)",
    colorPaletteDarkOrangeForeground1: "var(--colorPaletteDarkOrangeForeground1)",
    colorPaletteDarkOrangeForeground2: "var(--colorPaletteDarkOrangeForeground2)",
    colorPaletteDarkOrangeForeground3: "var(--colorPaletteDarkOrangeForeground3)",
    // Color palette yellow tokens
    colorPaletteYellowBackground1: "var(--colorPaletteYellowBackground1)",
    colorPaletteYellowBackground2: "var(--colorPaletteYellowBackground2)",
    colorPaletteYellowBackground3: "var(--colorPaletteYellowBackground3)",
    colorPaletteYellowBorderActive: "var(--colorPaletteYellowBorderActive)",
    colorPaletteYellowBorder1: "var(--colorPaletteYellowBorder1)",
    colorPaletteYellowBorder2: "var(--colorPaletteYellowBorder2)",
    colorPaletteYellowForeground1: "var(--colorPaletteYellowForeground1)",
    colorPaletteYellowForeground2: "var(--colorPaletteYellowForeground2)",
    colorPaletteYellowForeground3: "var(--colorPaletteYellowForeground3)",
    colorPaletteYellowForegroundInverted: "var(--colorPaletteYellowForegroundInverted)",
    // Color palette berry tokens
    colorPaletteBerryBackground1: "var(--colorPaletteBerryBackground1)",
    colorPaletteBerryBackground2: "var(--colorPaletteBerryBackground2)",
    colorPaletteBerryBackground3: "var(--colorPaletteBerryBackground3)",
    colorPaletteBerryBorderActive: "var(--colorPaletteBerryBorderActive)",
    colorPaletteBerryBorder1: "var(--colorPaletteBerryBorder1)",
    colorPaletteBerryBorder2: "var(--colorPaletteBerryBorder2)",
    colorPaletteBerryForeground1: "var(--colorPaletteBerryForeground1)",
    colorPaletteBerryForeground2: "var(--colorPaletteBerryForeground2)",
    colorPaletteBerryForeground3: "var(--colorPaletteBerryForeground3)",
    // Color palette marigold tokens
    colorPaletteMarigoldBackground1: "var(--colorPaletteMarigoldBackground1)",
    colorPaletteMarigoldBackground2: "var(--colorPaletteMarigoldBackground2)",
    colorPaletteMarigoldBackground3: "var(--colorPaletteMarigoldBackground3)",
    colorPaletteMarigoldBorderActive: "var(--colorPaletteMarigoldBorderActive)",
    colorPaletteMarigoldBorder1: "var(--colorPaletteMarigoldBorder1)",
    colorPaletteMarigoldBorder2: "var(--colorPaletteMarigoldBorder2)",
    colorPaletteMarigoldForeground1: "var(--colorPaletteMarigoldForeground1)",
    colorPaletteMarigoldForeground2: "var(--colorPaletteMarigoldForeground2)",
    colorPaletteMarigoldForeground3: "var(--colorPaletteMarigoldForeground3)",
    // Color palette light green tokens
    colorPaletteLightGreenBackground1: "var(--colorPaletteLightGreenBackground1)",
    colorPaletteLightGreenBackground2: "var(--colorPaletteLightGreenBackground2)",
    colorPaletteLightGreenBackground3: "var(--colorPaletteLightGreenBackground3)",
    colorPaletteLightGreenBorderActive: "var(--colorPaletteLightGreenBorderActive)",
    colorPaletteLightGreenBorder1: "var(--colorPaletteLightGreenBorder1)",
    colorPaletteLightGreenBorder2: "var(--colorPaletteLightGreenBorder2)",
    colorPaletteLightGreenForeground1: "var(--colorPaletteLightGreenForeground1)",
    colorPaletteLightGreenForeground2: "var(--colorPaletteLightGreenForeground2)",
    colorPaletteLightGreenForeground3: "var(--colorPaletteLightGreenForeground3)",
    // Color palette anchor tokens
    colorPaletteAnchorBackground2: "var(--colorPaletteAnchorBackground2)",
    colorPaletteAnchorBorderActive: "var(--colorPaletteAnchorBorderActive)",
    colorPaletteAnchorForeground2: "var(--colorPaletteAnchorForeground2)",
    // Color palette beige tokens
    colorPaletteBeigeBackground2: "var(--colorPaletteBeigeBackground2)",
    colorPaletteBeigeBorderActive: "var(--colorPaletteBeigeBorderActive)",
    colorPaletteBeigeForeground2: "var(--colorPaletteBeigeForeground2)",
    // Color palette blue tokens
    colorPaletteBlueBackground2: "var(--colorPaletteBlueBackground2)",
    colorPaletteBlueBorderActive: "var(--colorPaletteBlueBorderActive)",
    colorPaletteBlueForeground2: "var(--colorPaletteBlueForeground2)",
    // Color palette brass tokens
    colorPaletteBrassBackground2: "var(--colorPaletteBrassBackground2)",
    colorPaletteBrassBorderActive: "var(--colorPaletteBrassBorderActive)",
    colorPaletteBrassForeground2: "var(--colorPaletteBrassForeground2)",
    // Color palette brown tokens
    colorPaletteBrownBackground2: "var(--colorPaletteBrownBackground2)",
    colorPaletteBrownBorderActive: "var(--colorPaletteBrownBorderActive)",
    colorPaletteBrownForeground2: "var(--colorPaletteBrownForeground2)",
    // Color palette cornflower tokens
    colorPaletteCornflowerBackground2: "var(--colorPaletteCornflowerBackground2)",
    colorPaletteCornflowerBorderActive: "var(--colorPaletteCornflowerBorderActive)",
    colorPaletteCornflowerForeground2: "var(--colorPaletteCornflowerForeground2)",
    // Color palette cranberry tokens
    colorPaletteCranberryBackground2: "var(--colorPaletteCranberryBackground2)",
    colorPaletteCranberryBorderActive: "var(--colorPaletteCranberryBorderActive)",
    colorPaletteCranberryForeground2: "var(--colorPaletteCranberryForeground2)",
    // Color palette dark green tokens
    colorPaletteDarkGreenBackground2: "var(--colorPaletteDarkGreenBackground2)",
    colorPaletteDarkGreenBorderActive: "var(--colorPaletteDarkGreenBorderActive)",
    colorPaletteDarkGreenForeground2: "var(--colorPaletteDarkGreenForeground2)",
    // Color palette dark red tokens
    colorPaletteDarkRedBackground2: "var(--colorPaletteDarkRedBackground2)",
    colorPaletteDarkRedBorderActive: "var(--colorPaletteDarkRedBorderActive)",
    colorPaletteDarkRedForeground2: "var(--colorPaletteDarkRedForeground2)",
    // Color palette forest tokens
    colorPaletteForestBackground2: "var(--colorPaletteForestBackground2)",
    colorPaletteForestBorderActive: "var(--colorPaletteForestBorderActive)",
    colorPaletteForestForeground2: "var(--colorPaletteForestForeground2)",
    // Color palette gold tokens
    colorPaletteGoldBackground2: "var(--colorPaletteGoldBackground2)",
    colorPaletteGoldBorderActive: "var(--colorPaletteGoldBorderActive)",
    colorPaletteGoldForeground2: "var(--colorPaletteGoldForeground2)",
    // Color palette grape tokens
    colorPaletteGrapeBackground2: "var(--colorPaletteGrapeBackground2)",
    colorPaletteGrapeBorderActive: "var(--colorPaletteGrapeBorderActive)",
    colorPaletteGrapeForeground2: "var(--colorPaletteGrapeForeground2)",
    // Color palette lavender tokens
    colorPaletteLavenderBackground2: "var(--colorPaletteLavenderBackground2)",
    colorPaletteLavenderBorderActive: "var(--colorPaletteLavenderBorderActive)",
    colorPaletteLavenderForeground2: "var(--colorPaletteLavenderForeground2)",
    // Color palette light teal tokens
    colorPaletteLightTealBackground2: "var(--colorPaletteLightTealBackground2)",
    colorPaletteLightTealBorderActive: "var(--colorPaletteLightTealBorderActive)",
    colorPaletteLightTealForeground2: "var(--colorPaletteLightTealForeground2)",
    // Color palette lilac tokens
    colorPaletteLilacBackground2: "var(--colorPaletteLilacBackground2)",
    colorPaletteLilacBorderActive: "var(--colorPaletteLilacBorderActive)",
    colorPaletteLilacForeground2: "var(--colorPaletteLilacForeground2)",
    // Color palette magenta tokens
    colorPaletteMagentaBackground2: "var(--colorPaletteMagentaBackground2)",
    colorPaletteMagentaBorderActive: "var(--colorPaletteMagentaBorderActive)",
    colorPaletteMagentaForeground2: "var(--colorPaletteMagentaForeground2)",
    // Color palette mink tokens
    colorPaletteMinkBackground2: "var(--colorPaletteMinkBackground2)",
    colorPaletteMinkBorderActive: "var(--colorPaletteMinkBorderActive)",
    colorPaletteMinkForeground2: "var(--colorPaletteMinkForeground2)",
    // Color palette navy tokens
    colorPaletteNavyBackground2: "var(--colorPaletteNavyBackground2)",
    colorPaletteNavyBorderActive: "var(--colorPaletteNavyBorderActive)",
    colorPaletteNavyForeground2: "var(--colorPaletteNavyForeground2)",
    // Color palette peach tokens
    colorPalettePeachBackground2: "var(--colorPalettePeachBackground2)",
    colorPalettePeachBorderActive: "var(--colorPalettePeachBorderActive)",
    colorPalettePeachForeground2: "var(--colorPalettePeachForeground2)",
    // Color palette pink tokens
    colorPalettePinkBackground2: "var(--colorPalettePinkBackground2)",
    colorPalettePinkBorderActive: "var(--colorPalettePinkBorderActive)",
    colorPalettePinkForeground2: "var(--colorPalettePinkForeground2)",
    // Color palette platinum tokens
    colorPalettePlatinumBackground2: "var(--colorPalettePlatinumBackground2)",
    colorPalettePlatinumBorderActive: "var(--colorPalettePlatinumBorderActive)",
    colorPalettePlatinumForeground2: "var(--colorPalettePlatinumForeground2)",
    // Color palette plum tokens
    colorPalettePlumBackground2: "var(--colorPalettePlumBackground2)",
    colorPalettePlumBorderActive: "var(--colorPalettePlumBorderActive)",
    colorPalettePlumForeground2: "var(--colorPalettePlumForeground2)",
    // Color palette pumpkin tokens
    colorPalettePumpkinBackground2: "var(--colorPalettePumpkinBackground2)",
    colorPalettePumpkinBorderActive: "var(--colorPalettePumpkinBorderActive)",
    colorPalettePumpkinForeground2: "var(--colorPalettePumpkinForeground2)",
    // Color palette purple tokens
    colorPalettePurpleBackground2: "var(--colorPalettePurpleBackground2)",
    colorPalettePurpleBorderActive: "var(--colorPalettePurpleBorderActive)",
    colorPalettePurpleForeground2: "var(--colorPalettePurpleForeground2)",
    // Color palette royal blue tokens
    colorPaletteRoyalBlueBackground2: "var(--colorPaletteRoyalBlueBackground2)",
    colorPaletteRoyalBlueBorderActive: "var(--colorPaletteRoyalBlueBorderActive)",
    colorPaletteRoyalBlueForeground2: "var(--colorPaletteRoyalBlueForeground2)",
    // Color palette seafoam tokens
    colorPaletteSeafoamBackground2: "var(--colorPaletteSeafoamBackground2)",
    colorPaletteSeafoamBorderActive: "var(--colorPaletteSeafoamBorderActive)",
    colorPaletteSeafoamForeground2: "var(--colorPaletteSeafoamForeground2)",
    // Color palette steel tokens
    colorPaletteSteelBackground2: "var(--colorPaletteSteelBackground2)",
    colorPaletteSteelBorderActive: "var(--colorPaletteSteelBorderActive)",
    colorPaletteSteelForeground2: "var(--colorPaletteSteelForeground2)",
    // Color palette teal tokens
    colorPaletteTealBackground2: "var(--colorPaletteTealBackground2)",
    colorPaletteTealBorderActive: "var(--colorPaletteTealBorderActive)",
    colorPaletteTealForeground2: "var(--colorPaletteTealForeground2)",
    // Color status success tokens
    colorStatusSuccessBackground1: "var(--colorStatusSuccessBackground1)",
    colorStatusSuccessBackground2: "var(--colorStatusSuccessBackground2)",
    colorStatusSuccessBackground3: "var(--colorStatusSuccessBackground3)",
    colorStatusSuccessForeground1: "var(--colorStatusSuccessForeground1)",
    colorStatusSuccessForeground2: "var(--colorStatusSuccessForeground2)",
    colorStatusSuccessForeground3: "var(--colorStatusSuccessForeground3)",
    colorStatusSuccessForegroundInverted: "var(--colorStatusSuccessForegroundInverted)",
    colorStatusSuccessBorderActive: "var(--colorStatusSuccessBorderActive)",
    colorStatusSuccessBorder1: "var(--colorStatusSuccessBorder1)",
    colorStatusSuccessBorder2: "var(--colorStatusSuccessBorder2)",
    // Color status warning tokens
    colorStatusWarningBackground1: "var(--colorStatusWarningBackground1)",
    colorStatusWarningBackground2: "var(--colorStatusWarningBackground2)",
    colorStatusWarningBackground3: "var(--colorStatusWarningBackground3)",
    colorStatusWarningForeground1: "var(--colorStatusWarningForeground1)",
    colorStatusWarningForeground2: "var(--colorStatusWarningForeground2)",
    colorStatusWarningForeground3: "var(--colorStatusWarningForeground3)",
    colorStatusWarningForegroundInverted: "var(--colorStatusWarningForegroundInverted)",
    colorStatusWarningBorderActive: "var(--colorStatusWarningBorderActive)",
    colorStatusWarningBorder1: "var(--colorStatusWarningBorder1)",
    colorStatusWarningBorder2: "var(--colorStatusWarningBorder2)",
    // Color status danger tokens
    colorStatusDangerBackground1: "var(--colorStatusDangerBackground1)",
    colorStatusDangerBackground2: "var(--colorStatusDangerBackground2)",
    colorStatusDangerBackground3: "var(--colorStatusDangerBackground3)",
    colorStatusDangerBackground3Hover: "var(--colorStatusDangerBackground3Hover)",
    colorStatusDangerBackground3Pressed: "var(--colorStatusDangerBackground3Pressed)",
    colorStatusDangerForeground1: "var(--colorStatusDangerForeground1)",
    colorStatusDangerForeground2: "var(--colorStatusDangerForeground2)",
    colorStatusDangerForeground3: "var(--colorStatusDangerForeground3)",
    colorStatusDangerForegroundInverted: "var(--colorStatusDangerForegroundInverted)",
    colorStatusDangerBorderActive: "var(--colorStatusDangerBorderActive)",
    colorStatusDangerBorder1: "var(--colorStatusDangerBorder1)",
    colorStatusDangerBorder2: "var(--colorStatusDangerBorder2)",
    // Border radius tokens
    borderRadiusNone: "var(--borderRadiusNone)",
    borderRadiusSmall: "var(--borderRadiusSmall)",
    borderRadiusMedium: "var(--borderRadiusMedium)",
    borderRadiusLarge: "var(--borderRadiusLarge)",
    borderRadiusXLarge: "var(--borderRadiusXLarge)",
    borderRadiusCircular: "var(--borderRadiusCircular)",
    // Font family tokens
    fontFamilyBase: "var(--fontFamilyBase)",
    fontFamilyMonospace: "var(--fontFamilyMonospace)",
    fontFamilyNumeric: "var(--fontFamilyNumeric)",
    // Font size tokens
    fontSizeBase100: "var(--fontSizeBase100)",
    fontSizeBase200: "var(--fontSizeBase200)",
    fontSizeBase300: "var(--fontSizeBase300)",
    fontSizeBase400: "var(--fontSizeBase400)",
    fontSizeBase500: "var(--fontSizeBase500)",
    fontSizeBase600: "var(--fontSizeBase600)",
    fontSizeHero700: "var(--fontSizeHero700)",
    fontSizeHero800: "var(--fontSizeHero800)",
    fontSizeHero900: "var(--fontSizeHero900)",
    fontSizeHero1000: "var(--fontSizeHero1000)",
    // Font weight tokens
    fontWeightRegular: "var(--fontWeightRegular)",
    fontWeightMedium: "var(--fontWeightMedium)",
    fontWeightSemibold: "var(--fontWeightSemibold)",
    fontWeightBold: "var(--fontWeightBold)",
    // Line height tokens
    lineHeightBase100: "var(--lineHeightBase100)",
    lineHeightBase200: "var(--lineHeightBase200)",
    lineHeightBase300: "var(--lineHeightBase300)",
    lineHeightBase400: "var(--lineHeightBase400)",
    lineHeightBase500: "var(--lineHeightBase500)",
    lineHeightBase600: "var(--lineHeightBase600)",
    lineHeightHero700: "var(--lineHeightHero700)",
    lineHeightHero800: "var(--lineHeightHero800)",
    lineHeightHero900: "var(--lineHeightHero900)",
    lineHeightHero1000: "var(--lineHeightHero1000)",
    // Shadow tokens
    shadow2: "var(--shadow2)",
    shadow4: "var(--shadow4)",
    shadow8: "var(--shadow8)",
    shadow16: "var(--shadow16)",
    shadow28: "var(--shadow28)",
    shadow64: "var(--shadow64)",
    // Shadow brand tokens
    shadow2Brand: "var(--shadow2Brand)",
    shadow4Brand: "var(--shadow4Brand)",
    shadow8Brand: "var(--shadow8Brand)",
    shadow16Brand: "var(--shadow16Brand)",
    shadow28Brand: "var(--shadow28Brand)",
    shadow64Brand: "var(--shadow64Brand)",
    // Stroke width tokens
    strokeWidthThin: "var(--strokeWidthThin)",
    strokeWidthThick: "var(--strokeWidthThick)",
    strokeWidthThicker: "var(--strokeWidthThicker)",
    strokeWidthThickest: "var(--strokeWidthThickest)",
    // Spacings
    spacingHorizontalNone: "var(--spacingHorizontalNone)",
    spacingHorizontalXXS: "var(--spacingHorizontalXXS)",
    spacingHorizontalXS: "var(--spacingHorizontalXS)",
    spacingHorizontalSNudge: "var(--spacingHorizontalSNudge)",
    spacingHorizontalS: "var(--spacingHorizontalS)",
    spacingHorizontalMNudge: "var(--spacingHorizontalMNudge)",
    spacingHorizontalM: "var(--spacingHorizontalM)",
    spacingHorizontalL: "var(--spacingHorizontalL)",
    spacingHorizontalXL: "var(--spacingHorizontalXL)",
    spacingHorizontalXXL: "var(--spacingHorizontalXXL)",
    spacingHorizontalXXXL: "var(--spacingHorizontalXXXL)",
    spacingVerticalNone: "var(--spacingVerticalNone)",
    spacingVerticalXXS: "var(--spacingVerticalXXS)",
    spacingVerticalXS: "var(--spacingVerticalXS)",
    spacingVerticalSNudge: "var(--spacingVerticalSNudge)",
    spacingVerticalS: "var(--spacingVerticalS)",
    spacingVerticalMNudge: "var(--spacingVerticalMNudge)",
    spacingVerticalM: "var(--spacingVerticalM)",
    spacingVerticalL: "var(--spacingVerticalL)",
    spacingVerticalXL: "var(--spacingVerticalXL)",
    spacingVerticalXXL: "var(--spacingVerticalXXL)",
    spacingVerticalXXXL: "var(--spacingVerticalXXXL)",
    // Durations
    durationUltraFast: "var(--durationUltraFast)",
    durationFaster: "var(--durationFaster)",
    durationFast: "var(--durationFast)",
    durationNormal: "var(--durationNormal)",
    durationGentle: "var(--durationGentle)",
    durationSlow: "var(--durationSlow)",
    durationSlower: "var(--durationSlower)",
    durationUltraSlow: "var(--durationUltraSlow)",
    // Curves
    curveAccelerateMax: "var(--curveAccelerateMax)",
    curveAccelerateMid: "var(--curveAccelerateMid)",
    curveAccelerateMin: "var(--curveAccelerateMin)",
    curveDecelerateMax: "var(--curveDecelerateMax)",
    curveDecelerateMid: "var(--curveDecelerateMid)",
    curveDecelerateMin: "var(--curveDecelerateMin)",
    curveEasyEaseMax: "var(--curveEasyEaseMax)",
    curveEasyEase: "var(--curveEasyEase)",
    curveLinear: "var(--curveLinear)",
    /**
    * ZIndexes
    * Special case where the tokens contain default values
    * ZIndexes are not mandatory, so they are not included in the theme, but can be used as tokens with default values
    */
    /**
    * Elevation 0
    * Can be used for background elements, like surfaces
    */
    zIndexBackground: "var(--zIndexBackground, 0)",
    /**
    * Elevation 2
    * Can be used content that is on top of the background, like cards
    */
    zIndexContent: "var(--zIndexContent, 1)",
    /**
    * Elevation 4
    * Can be used for overlays, like the backdrop of a modal
    */
    zIndexOverlay: "var(--zIndexOverlay, 1000)",
    /**
    * Elevation 8
    * Can be used for popups, like modals and drawers
    */
    zIndexPopup: "var(--zIndexPopup, 2000)",
    /**
    * Elevation 16
    * Can be used for messages, like snackbars and toasts
    */
    zIndexMessages: "var(--zIndexMessages, 3000)",
    /**
    * Elevation 28
    * Can be used for floating elements, like dropdowns
    */
    zIndexFloating: "var(--zIndexFloating, 4000)",
    /**
    * Elevation 64
    * Can be used for high priority floating elements, like tooltips
    */
    zIndexPriority: "var(--zIndexPriority, 5000)",
    /**
    * Special elevation
    * Can be used for elements that need to be above everything else, like debug overlays
    */
    zIndexDebug: "var(--zIndexDebug, 6000)"
  };

  // ../../node_modules/@fluentui/tokens/lib/utils/shadows.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function createShadowTokens(ambientColor, keyColor, tokenSuffix = "") {
    return {
      [`shadow2${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 1px 2px ${keyColor}`,
      [`shadow4${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 2px 4px ${keyColor}`,
      [`shadow8${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 4px 8px ${keyColor}`,
      [`shadow16${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 8px 16px ${keyColor}`,
      [`shadow28${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 14px 28px ${keyColor}`,
      [`shadow64${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 32px 64px ${keyColor}`
    };
  }

  // ../../node_modules/@fluentui/tokens/lib/utils/createLightTheme.js
  var createLightTheme = (brand) => {
    const colorTokens = generateColorTokens(brand);
    return {
      ...borderRadius,
      ...fontSizes,
      ...lineHeights,
      ...fontFamilies,
      ...fontWeights,
      ...strokeWidths,
      ...horizontalSpacings,
      ...verticalSpacings,
      ...durations,
      ...curves,
      ...colorTokens,
      ...colorPaletteTokens,
      ...colorStatusTokens,
      ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
      ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
    };
  };

  // ../../node_modules/@fluentui/tokens/lib/global/brandColors.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var brandWeb = {
    10: `#061724`,
    20: `#082338`,
    30: `#0a2e4a`,
    40: `#0c3b5e`,
    50: `#0e4775`,
    60: `#0f548c`,
    70: `#115ea3`,
    80: `#0f6cbd`,
    90: `#2886de`,
    100: `#479ef5`,
    110: `#62abf5`,
    120: `#77b7f7`,
    130: `#96c6fa`,
    140: `#b4d6fa`,
    150: `#cfe4fa`,
    160: `#ebf3fc`
  };

  // ../../node_modules/@fluentui/tokens/lib/themes/web/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/tokens/lib/themes/web/lightTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var webLightTheme = createLightTheme(brandWeb);

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
  var React53 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderThemeStyleTag.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React52 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var fluentProviderClassNames = {
    root: "fui-FluentProvider"
  };
  var useStyles = /* @__PURE__ */ __styles({
    root: {
      sj55zd: "f19n0e5",
      De3pzq: "fxugw4r",
      fsow6f: ["f1o700av", "fes3tcz"],
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    }
  }, {
    d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
  });
  var useFluentProviderStyles_unstable = (state) => {
    "use no memo";
    const renderer = useRenderer();
    const styles2 = useStyles({
      dir: state.dir,
      renderer
    });
    state.root.className = mergeClasses(fluentProviderClassNames.root, state.themeClassName, styles2.root, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderThemeStyleTag.js
  var useInsertionEffect4 = React52["useInsertionEffect"] ? React52["useInsertionEffect"] : useIsomorphicLayoutEffect2;
  var createStyleTag = (target, elementAttributes) => {
    if (!(target === null || target === void 0 ? void 0 : target.head)) {
      return void 0;
    }
    const tag = target.createElement("style");
    Object.keys(elementAttributes).forEach((attrName) => {
      tag.setAttribute(attrName, elementAttributes[attrName]);
    });
    target.head.appendChild(tag);
    return tag;
  };
  var insertSheet = (tag, rule) => {
    const sheet = tag.sheet;
    if (sheet) {
      if (sheet.cssRules.length > 0) {
        sheet.deleteRule(0);
      }
      sheet.insertRule(rule, 0);
    } else if (false) {
      console.error("FluentProvider: No sheet available on styleTag, styles will not be inserted into DOM.");
    }
  };
  var useFluentProviderThemeStyleTag = (options) => {
    "use no memo";
    const { targetDocument, theme, rendererAttributes } = options;
    const styleTag = React52.useRef();
    const styleTagId = useId4(fluentProviderClassNames.root);
    const styleElementAttributes = rendererAttributes;
    const rule = React52.useMemo(() => createCSSRuleFromTheme(`.${styleTagId}`, theme), [
      theme,
      styleTagId
    ]);
    if (false) {
      React52.useMemo(() => {
        if (targetDocument) {
          var _styleElement_textContent;
          const providerElementSelector = `.${fluentProviderClassNames.root}.${styleTagId}`;
          const providerElements = targetDocument.querySelectorAll(providerElementSelector);
          const styleElementSelector = `style[id="${styleTagId}"]`;
          const styleElements = targetDocument.querySelectorAll(styleElementSelector);
          if (styleElements.length > 1) {
            console.error([
              "@fluentui/react-provider: We found multiple <style> elements with same IDs in your DOM.",
              "Please make sure that you configured your application properly.",
              "\n",
              "\n",
              "Configuration guide: https://aka.ms/fluentui-conflicting-ids"
            ].join(" "));
            return;
          }
          const styleElement = styleElements.item(0);
          var _styleElement_textContent_length;
          const isSSR = ((_styleElement_textContent_length = styleElement === null || styleElement === void 0 ? void 0 : (_styleElement_textContent = styleElement.textContent) === null || _styleElement_textContent === void 0 ? void 0 : _styleElement_textContent.length) !== null && _styleElement_textContent_length !== void 0 ? _styleElement_textContent_length : 0) > 0;
          const elementsCount = isSSR ? 1 : 0;
          if (providerElements.length > elementsCount) {
            console.error([
              "@fluentui/react-provider: There are conflicting ids in your DOM.",
              "Please make sure that you configured your application properly.",
              "\n",
              "\n",
              "Configuration guide: https://aka.ms/fluentui-conflicting-ids"
            ].join(" "));
          }
        }
      }, []);
    }
    useHandleSSRStyleElements(targetDocument, styleTagId);
    useInsertionEffect4(() => {
      const ssrStyleElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(styleTagId);
      if (ssrStyleElement) {
        styleTag.current = ssrStyleElement;
      } else {
        styleTag.current = createStyleTag(targetDocument, {
          ...styleElementAttributes,
          id: styleTagId
        });
        if (styleTag.current) {
          insertSheet(styleTag.current, rule);
        }
      }
      return () => {
        var _styleTag_current;
        (_styleTag_current = styleTag.current) === null || _styleTag_current === void 0 ? void 0 : _styleTag_current.remove();
      };
    }, [
      styleTagId,
      targetDocument,
      rule,
      styleElementAttributes
    ]);
    return {
      styleTagId,
      rule
    };
  };
  function useHandleSSRStyleElements(targetDocument, styleTagId) {
    React52.useState(() => {
      if (!targetDocument) {
        return;
      }
      const themeStyleElement = targetDocument.getElementById(styleTagId);
      if (themeStyleElement) {
        targetDocument.head.append(themeStyleElement);
      }
    });
  }

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
  var DEFAULT_STYLE_HOOKS = {};
  var DEFAULT_RENDERER_ATTRIBUTES = {};
  var useFluentProvider_unstable = (props, ref) => {
    "use no memo";
    const parentContext = useFluent();
    const parentTheme = useTheme2();
    const parentOverrides = useOverrides();
    const parentCustomStyleHooks = React53.useContext(CustomStyleHooksContext) || DEFAULT_STYLE_HOOKS;
    const {
      applyStylesToPortals = true,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      customStyleHooks_unstable,
      dir = parentContext.dir,
      targetDocument = parentContext.targetDocument,
      theme,
      overrides_unstable: overrides = {}
    } = props;
    const mergedTheme = shallowMerge(parentTheme, theme);
    const mergedOverrides = shallowMerge(parentOverrides, overrides);
    const mergedCustomStyleHooks = shallowMerge(parentCustomStyleHooks, customStyleHooks_unstable);
    const renderer = useRenderer();
    var _renderer_styleElementAttributes;
    const { styleTagId, rule } = useFluentProviderThemeStyleTag({
      theme: mergedTheme,
      targetDocument,
      rendererAttributes: (_renderer_styleElementAttributes = renderer.styleElementAttributes) !== null && _renderer_styleElementAttributes !== void 0 ? _renderer_styleElementAttributes : DEFAULT_RENDERER_ATTRIBUTES
    });
    if (false) {
      React53.useEffect(() => {
        if (mergedTheme === void 0) {
          console.warn([
            '@fluentui/react-provider: FluentProvider does not have your "theme" defined.',
            "Make sure that your top-level FluentProvider has set a `theme` prop or you're setting the theme in your child FluentProvider."
          ].join(" "));
        }
      }, []);
    }
    return {
      applyStylesToPortals,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      customStyleHooks_unstable: mergedCustomStyleHooks,
      dir,
      targetDocument,
      theme: mergedTheme,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      overrides_unstable: mergedOverrides,
      themeClassName: styleTagId,
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        ...props,
        dir,
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, useFocusVisible({
          targetDocument
        }))
      }), {
        elementType: "div"
      }),
      serverStyleProps: {
        cssRule: rule,
        attributes: {
          ...renderer.styleElementAttributes,
          id: styleTagId
        }
      }
    };
  };
  function shallowMerge(a, b) {
    if (a && b) {
      return {
        ...a,
        ...b
      };
    }
    if (a) {
      return a;
    }
    return b;
  }
  function useTheme2() {
    return React53.useContext(ThemeContext2);
  }

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React54 = __toESM(require_react());
  function useFluentProviderContextValues_unstable(state) {
    const {
      applyStylesToPortals,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      customStyleHooks_unstable,
      dir,
      root,
      targetDocument,
      theme,
      themeClassName,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      overrides_unstable
    } = state;
    const provider = React54.useMemo(() => ({
      dir,
      targetDocument
    }), [
      dir,
      targetDocument
    ]);
    const [tooltip] = React54.useState(() => ({}));
    const iconDirection = React54.useMemo(() => ({
      textDirection: dir
    }), [
      dir
    ]);
    return {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      customStyleHooks_unstable,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      overrides_unstable,
      provider,
      textDirection: dir,
      iconDirection,
      tooltip,
      theme,
      themeClassName: applyStylesToPortals ? root.className : themeClassName
    };
  }

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/FluentProvider.js
  var FluentProvider = /* @__PURE__ */ React55.forwardRef((props, ref) => {
    const state = useFluentProvider_unstable(props, ref);
    useFluentProviderStyles_unstable(state);
    const contextValues = useFluentProviderContextValues_unstable(state);
    return renderFluentProvider_unstable(state, contextValues);
  });
  FluentProvider.displayName = "FluentProvider";

  // ../../node_modules/@fluentui/react-context-selector/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-context-selector/lib/createContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React56 = __toESM(require_react());
  var import_scheduler = __toESM(require_scheduler2());
  var createProvider = (Original) => {
    const Provider2 = (props) => {
      const valueRef = React56.useRef(props.value);
      const versionRef = React56.useRef(0);
      const contextValue = React56.useRef();
      if (!contextValue.current) {
        contextValue.current = {
          value: valueRef,
          version: versionRef,
          listeners: []
        };
      }
      useIsomorphicLayoutEffect2(() => {
        valueRef.current = props.value;
        versionRef.current += 1;
        (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, () => {
          contextValue.current.listeners.forEach((listener) => {
            listener([
              versionRef.current,
              props.value
            ]);
          });
        });
      }, [
        props.value
      ]);
      return React56.createElement(Original, {
        value: contextValue.current
      }, props.children);
    };
    if (false) {
      Provider2.displayName = "ContextSelector.Provider";
    }
    return Provider2;
  };
  var createContext20 = (defaultValue) => {
    const context = React56.createContext({
      value: {
        current: defaultValue
      },
      version: {
        current: -1
      },
      listeners: []
    });
    context.Provider = createProvider(context.Provider);
    delete context.Consumer;
    return context;
  };

  // ../../node_modules/@fluentui/react-context-selector/lib/useContextSelector.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React57 = __toESM(require_react());
  var useContextSelector = (context, selector) => {
    const contextValue = React57.useContext(context);
    const { value: { current: value }, version: { current: version2 }, listeners } = contextValue;
    const selected = selector(value);
    const [state, setState] = React57.useState([
      value,
      selected
    ]);
    const dispatch = (payload) => {
      setState((prevState) => {
        if (!payload) {
          return [
            value,
            selected
          ];
        }
        if (payload[0] <= version2) {
          if (Object.is(prevState[1], selected)) {
            return prevState;
          }
          return [
            value,
            selected
          ];
        }
        try {
          if (Object.is(prevState[0], payload[1])) {
            return prevState;
          }
          const nextSelected = selector(payload[1]);
          if (Object.is(prevState[1], nextSelected)) {
            return prevState;
          }
          return [
            payload[1],
            nextSelected
          ];
        } catch (e) {
        }
        return [
          prevState[0],
          prevState[1]
        ];
      });
    };
    if (!Object.is(state[1], selected)) {
      dispatch(void 0);
    }
    const stableDispatch = useEventCallback(dispatch);
    useIsomorphicLayoutEffect2(() => {
      listeners.push(stableDispatch);
      return () => {
        const index = listeners.indexOf(stableDispatch);
        listeners.splice(index, 1);
      };
    }, [
      stableDispatch,
      listeners
    ]);
    return state[1];
  };

  // ../../node_modules/@fluentui/react-context-selector/lib/useHasParentContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React58 = __toESM(require_react());
  function useHasParentContext(context) {
    const contextValue = React58.useContext(context);
    if (contextValue.version) {
      return contextValue.version.current !== -1;
    }
    return false;
  }

  // ../../node_modules/@fluentui/react-aria/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-aria/lib/button/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-aria/lib/button/useARIAButtonProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/keyboard-keys/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/keyboard-keys/lib/keys.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var Enter = "Enter";
  var Space = " ";
  var Escape = "Escape";

  // ../../node_modules/@fluentui/react-aria/lib/button/useARIAButtonProps.js
  var React59 = __toESM(require_react());
  function useARIAButtonProps(type, props) {
    const { disabled, disabledFocusable = false, ["aria-disabled"]: ariaDisabled, onClick, onKeyDown, onKeyUp, ...rest } = props !== null && props !== void 0 ? props : {};
    const normalizedARIADisabled = typeof ariaDisabled === "string" ? ariaDisabled === "true" : ariaDisabled;
    const isDisabled = disabled || disabledFocusable || normalizedARIADisabled;
    const handleClick = useEventCallback((ev) => {
      if (isDisabled) {
        ev.preventDefault();
        ev.stopPropagation();
      } else {
        onClick === null || onClick === void 0 ? void 0 : onClick(ev);
      }
    });
    const handleKeyDown = useEventCallback((ev) => {
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
      if (ev.isDefaultPrevented()) {
        return;
      }
      const key = ev.key;
      if (isDisabled && (key === Enter || key === Space)) {
        ev.preventDefault();
        ev.stopPropagation();
        return;
      }
      if (key === Space) {
        ev.preventDefault();
        return;
      } else if (key === Enter) {
        ev.preventDefault();
        ev.currentTarget.click();
      }
    });
    const handleKeyUp = useEventCallback((ev) => {
      onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(ev);
      if (ev.isDefaultPrevented()) {
        return;
      }
      const key = ev.key;
      if (isDisabled && (key === Enter || key === Space)) {
        ev.preventDefault();
        ev.stopPropagation();
        return;
      }
      if (key === Space) {
        ev.preventDefault();
        ev.currentTarget.click();
      }
    });
    if (type === "button" || type === void 0) {
      return {
        ...rest,
        disabled: disabled && !disabledFocusable,
        "aria-disabled": disabledFocusable ? true : normalizedARIADisabled,
        // onclick should still use internal handler to ensure prevention if disabled
        // if disabledFocusable then there's no requirement for handlers as those events should not be propagated
        onClick: disabledFocusable ? void 0 : handleClick,
        onKeyUp: disabledFocusable ? void 0 : onKeyUp,
        onKeyDown: disabledFocusable ? void 0 : onKeyDown
      };
    } else {
      const isLink = !!rest.href;
      let roleOverride = isLink ? void 0 : "button";
      if (!roleOverride && isDisabled) {
        roleOverride = "link";
      }
      const resultProps = {
        role: roleOverride,
        tabIndex: disabledFocusable || !isLink && !disabled ? 0 : void 0,
        ...rest,
        // If it's not a <button> than listeners are required even with disabledFocusable
        // Since you cannot assure the default behavior of the element
        // E.g: <a> will redirect on click
        onClick: handleClick,
        onKeyUp: handleKeyUp,
        onKeyDown: handleKeyDown,
        "aria-disabled": isDisabled
      };
      if (type === "a" && isDisabled) {
        resultProps.href = void 0;
      }
      return resultProps;
    }
  }

  // ../../node_modules/@fluentui/react-icons/lib/utils/createFluentIcon.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React60 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-icons/lib/utils/useIconState.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var useRootStyles = __styles2({
    "root": {
      "mc9l5x": "f1w7gpdv",
      "Bg96gwp": "fez10in",
      "ycbfsm": "fg4l7m0"
    },
    "rtl": {
      "Bz10aip": "f13rod7r"
    }
  }, {
    "d": [".f1w7gpdv{display:inline;}", ".fez10in{line-height:0;}", ".f13rod7r{-webkit-transform:scaleX(-1);-moz-transform:scaleX(-1);-ms-transform:scaleX(-1);transform:scaleX(-1);}"],
    "t": ["@media (forced-colors: active){.fg4l7m0{forced-color-adjust:auto;}}"]
  });
  var useIconState = (props, options) => {
    const {
      title,
      primaryFill = "currentColor",
      ...rest
    } = props;
    const state = {
      ...rest,
      title: void 0,
      fill: primaryFill
    };
    const styles2 = useRootStyles();
    const iconContext = useIconContext();
    state.className = mergeClasses(styles2.root, (options === null || options === void 0 ? void 0 : options.flipInRtl) && (iconContext === null || iconContext === void 0 ? void 0 : iconContext.textDirection) === "rtl" && styles2.rtl, state.className);
    if (title) {
      state["aria-label"] = title;
    }
    if (!state["aria-label"] && !state["aria-labelledby"]) {
      state["aria-hidden"] = true;
    } else {
      state["role"] = "img";
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-icons/lib/utils/createFluentIcon.js
  var createFluentIcon = (displayName, width, pathsOrSvg, options) => {
    const viewBoxWidth = width === "1em" ? "20" : width;
    const Icon = React60.forwardRef((props, ref) => {
      const state = {
        ...useIconState(props, {
          flipInRtl: options === null || options === void 0 ? void 0 : options.flipInRtl
        }),
        ref,
        width,
        height: width,
        viewBox: `0 0 ${viewBoxWidth} ${viewBoxWidth}`,
        xmlns: "http://www.w3.org/2000/svg"
      };
      if (typeof pathsOrSvg === "string") {
        return React60.createElement("svg", {
          ...state,
          dangerouslySetInnerHTML: {
            __html: pathsOrSvg
          }
        });
      } else {
        return React60.createElement("svg", state, ...pathsOrSvg.map((d) => React60.createElement("path", {
          d,
          fill: state.fill
        })));
      }
    });
    Icon.displayName = displayName;
    return Icon;
  };

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-1.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var CheckmarkCircleFilled = /* @__PURE__ */ createFluentIcon("CheckmarkCircleFilled", "1em", ["M10 2a8 8 0 1 1 0 16 8 8 0 0 1 0-16Zm3.36 5.65a.5.5 0 0 0-.64-.06l-.07.06L9 11.3 7.35 9.65l-.07-.06a.5.5 0 0 0-.7.7l.07.07 2 2 .07.06c.17.11.4.11.56 0l.07-.06 4-4 .07-.08a.5.5 0 0 0-.06-.63Z"]);
  var CircleFilled = /* @__PURE__ */ createFluentIcon("CircleFilled", "1em", ["M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"]);
  var DismissCircleFilled = /* @__PURE__ */ createFluentIcon("DismissCircleFilled", "1em", ["M10 2a8 8 0 1 1 0 16 8 8 0 0 1 0-16ZM7.8 7.11a.5.5 0 0 0-.63.06l-.06.07a.5.5 0 0 0 .06.64L9.3 10l-2.12 2.12-.06.07a.5.5 0 0 0 .06.64l.07.06c.2.13.47.11.64-.06L10 10.7l2.12 2.12.07.06c.2.13.46.11.64-.06l.06-.07a.5.5 0 0 0-.06-.64L10.7 10l2.12-2.12.06-.07a.5.5 0 0 0-.06-.64l-.07-.06a.5.5 0 0 0-.64.06L10 9.3 7.88 7.17l-.07-.06Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-2.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var InfoFilled = /* @__PURE__ */ createFluentIcon("InfoFilled", "1em", ["M18 10a8 8 0 1 0-16 0 8 8 0 0 0 16 0ZM9.5 8.91a.5.5 0 0 1 1 0V13.6a.5.5 0 0 1-1 0V8.9Zm-.25-2.16a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-3.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var PersonRegular = /* @__PURE__ */ createFluentIcon("PersonRegular", "1em", ["M10 2a4 4 0 1 0 0 8 4 4 0 0 0 0-8ZM7 6a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm-2 5a2 2 0 0 0-2 2c0 1.7.83 2.97 2.13 3.8A9.14 9.14 0 0 0 10 18c1.85 0 3.58-.39 4.87-1.2A4.35 4.35 0 0 0 17 13a2 2 0 0 0-2-2H5Zm-1 2a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1c0 1.3-.62 2.28-1.67 2.95A8.16 8.16 0 0 1 10 17a8.16 8.16 0 0 1-4.33-1.05A3.36 3.36 0 0 1 4 13Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-5.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var WarningFilled = /* @__PURE__ */ createFluentIcon("WarningFilled", "1em", ["M8.68 2.79a1.5 1.5 0 0 1 2.64 0l6.5 12A1.5 1.5 0 0 1 16.5 17h-13a1.5 1.5 0 0 1-1.32-2.21l6.5-12ZM10.5 7.5a.5.5 0 0 0-1 0v4a.5.5 0 0 0 1 0v-4Zm.25 6.25a.75.75 0 1 0-1.5 0 .75.75 0 0 0 1.5 0Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-6.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var Dismiss20Regular = /* @__PURE__ */ createFluentIcon("Dismiss20Regular", "20", ["m4.09 4.22.06-.07a.5.5 0 0 1 .63-.06l.07.06L10 9.29l5.15-5.14a.5.5 0 0 1 .63-.06l.07.06c.18.17.2.44.06.63l-.06.07L10.71 10l5.14 5.15c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L10 10.71l-5.15 5.14a.5.5 0 0 1-.63.06l-.07-.06a.5.5 0 0 1-.06-.63l.06-.07L9.29 10 4.15 4.85a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z"]);
  var Dismiss24Regular = /* @__PURE__ */ createFluentIcon("Dismiss24Regular", "24", ["m4.4 4.55.07-.08a.75.75 0 0 1 .98-.07l.08.07L12 10.94l6.47-6.47a.75.75 0 1 1 1.06 1.06L13.06 12l6.47 6.47c.27.27.3.68.07.98l-.07.08a.75.75 0 0 1-.98.07l-.08-.07L12 13.06l-6.47 6.47a.75.75 0 0 1-1.06-1.06L10.94 12 4.47 5.53a.75.75 0 0 1-.07-.98l.07-.08-.07.08Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-13.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var PresenceAvailable10Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10Zm2.1-5.9L4.85 6.35a.5.5 0 0 1-.7 0l-1-1a.5.5 0 0 1 .7-.7l.65.64 1.9-1.9a.5.5 0 0 1 .7.71Z"]);
  var PresenceAvailable10Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable10Regular", "10", ["M5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm6.1-1.6c.2.2.2.5 0 .7L4.85 6.35a.5.5 0 0 1-.7 0l-1-1a.5.5 0 1 1 .7-.7l.65.64 1.9-1.9c.2-.19.5-.19.7 0Z"]);
  var PresenceAvailable12Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12Zm2.53-6.72L5.78 8.03c-.3.3-.77.3-1.06 0l-1-1a.75.75 0 0 1 1.06-1.06l.47.47 2.22-2.22a.75.75 0 0 1 1.06 1.06Z"]);
  var PresenceAvailable12Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable12Regular", "12", ["M6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0Zm7.03-1.78c.3.3.3.77 0 1.06L5.78 8.03c-.3.3-.77.3-1.06 0l-1-1a.75.75 0 0 1 1.06-1.06l.47.47 2.22-2.22c.3-.3.77-.3 1.06 0Z"]);
  var PresenceAvailable16Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16Zm3.7-9.3-4 4a1 1 0 0 1-1.41 0l-2-2a1 1 0 1 1 1.42-1.4L7 8.58l3.3-3.3a1 1 0 0 1 1.4 1.42Z"]);
  var PresenceAvailable16Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable16Regular", "16", ["M11.7 6.7a1 1 0 0 0-1.4-1.4L7 8.58l-1.3-1.3a1 1 0 0 0-1.4 1.42l2 2a1 1 0 0 0 1.4 0l4-4ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
  var PresenceAvailable20Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20Zm4.2-11.8-4.5 4.5a1 1 0 0 1-1.4 0l-2-2a1 1 0 1 1 1.4-1.4L9 10.58l3.8-3.8a1 1 0 1 1 1.4 1.42Z"]);
  var PresenceAvailable20Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable20Regular", "20", ["M10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm12.2-3.2a1 1 0 0 1 0 1.4l-4.5 4.5a1 1 0 0 1-1.4 0l-2-2a1 1 0 0 1 1.4-1.4L9 10.58l3.8-3.8a1 1 0 0 1 1.4 0Z"]);
  var PresenceAway10Filled = /* @__PURE__ */ createFluentIcon("PresenceAway10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10Zm0-7v1.8l1.35 1.35a.5.5 0 1 1-.7.7l-1.5-1.5A.5.5 0 0 1 4 5V3a.5.5 0 0 1 1 0Z"]);
  var PresenceAway12Filled = /* @__PURE__ */ createFluentIcon("PresenceAway12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12Zm.5-8.75v2.4l1.49 1.28A.75.75 0 1 1 7 8.07l-1.75-1.5A.75.75 0 0 1 5 6V3.25a.75.75 0 0 1 1.5 0Z"]);
  var PresenceAway16Filled = /* @__PURE__ */ createFluentIcon("PresenceAway16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16Zm.5-11.5v3.02l2.12 1.7a1 1 0 1 1-1.24 1.56l-2.5-2A1 1 0 0 1 6.5 8V4.5a1 1 0 0 1 2 0Z"]);
  var PresenceAway20Filled = /* @__PURE__ */ createFluentIcon("PresenceAway20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20Zm0-14V9.6l2.7 2.7a1 1 0 0 1-1.4 1.42l-3-3A1 1 0 0 1 8 10V6a1 1 0 1 1 2 0Z"]);
  var PresenceBlocked10Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked10Regular", "10", ["M10 5A5 5 0 1 0 0 5a5 5 0 0 0 10 0ZM9 5a4 4 0 0 1-6.45 3.16l5.61-5.61C8.69 3.22 9 4.08 9 5ZM7.45 1.84 1.84 7.45a4 4 0 0 1 5.61-5.61Z"]);
  var PresenceBlocked12Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked12Regular", "12", ["M12 6A6 6 0 1 1 0 6a6 6 0 0 1 12 0Zm-1.5 0c0-.97-.3-1.87-.83-2.6L3.39 9.66A4.5 4.5 0 0 0 10.5 6ZM8.6 2.33a4.5 4.5 0 0 0-6.28 6.28l6.29-6.28Z"]);
  var PresenceBlocked16Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked16Regular", "16", ["M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Zm-2 0c0-1.3-.41-2.5-1.1-3.48L4.51 12.9A6 6 0 0 0 14 8Zm-2.52-4.9a6 6 0 0 0-8.37 8.37l8.37-8.36Z"]);
  var PresenceBlocked20Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked20Regular", "20", ["M20 10a10 10 0 1 0-20 0 10 10 0 0 0 20 0Zm-2 0a8 8 0 0 1-12.9 6.32L16.31 5.09A7.97 7.97 0 0 1 18 10Zm-3.1-6.32L3.69 14.91A8 8 0 0 1 14.91 3.68Z"]);
  var PresenceBusy10Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy10Filled", "10", ["M10 5A5 5 0 1 1 0 5a5 5 0 0 1 10 0Z"]);
  var PresenceBusy12Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy12Filled", "12", ["M12 6A6 6 0 1 1 0 6a6 6 0 0 1 12 0Z"]);
  var PresenceBusy16Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy16Filled", "16", ["M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Z"]);
  var PresenceBusy20Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy20Filled", "20", ["M20 10a10 10 0 1 1-20 0 10 10 0 0 1 20 0Z"]);
  var PresenceDnd10Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10ZM3.5 4.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1 0-1Z"]);
  var PresenceDnd10Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd10Regular", "10", ["M5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm2 0c0-.28.22-.5.5-.5h3a.5.5 0 0 1 0 1h-3A.5.5 0 0 1 3 5Z"]);
  var PresenceDnd12Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12ZM3.75 5.25h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5Z"]);
  var PresenceDnd12Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd12Regular", "12", ["M6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0ZM3 6c0-.41.34-.75.75-.75h4.5a.75.75 0 0 1 0 1.5h-4.5A.75.75 0 0 1 3 6Z"]);
  var PresenceDnd16Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16ZM5.25 7h5.5a1 1 0 1 1 0 2h-5.5a1 1 0 1 1 0-2Z"]);
  var PresenceDnd16Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd16Regular", "16", ["M5.25 7a1 1 0 0 0 0 2h5.5a1 1 0 1 0 0-2h-5.5ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
  var PresenceDnd20Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20ZM7 9h6a1 1 0 1 1 0 2H7a1 1 0 1 1 0-2Z"]);
  var PresenceDnd20Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd20Regular", "20", ["M10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm4 0a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H7a1 1 0 0 1-1-1Z"]);
  var PresenceOffline10Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline10Regular", "10", ["M6.85 3.15c.2.2.2.5 0 .7L5.71 5l1.14 1.15a.5.5 0 1 1-.7.7L5 5.71 3.85 6.85a.5.5 0 1 1-.7-.7L4.29 5 3.15 3.85a.5.5 0 1 1 .7-.7L5 4.29l1.15-1.14c.2-.2.5-.2.7 0ZM0 5a5 5 0 1 1 10 0A5 5 0 0 1 0 5Zm5-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z"]);
  var PresenceOffline12Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline12Regular", "12", ["M8.03 3.97c.3.3.3.77 0 1.06L7.06 6l.97.97a.75.75 0 0 1-1.06 1.06L6 7.06l-.97.97a.75.75 0 0 1-1.06-1.06L4.94 6l-.97-.97a.75.75 0 0 1 1.06-1.06l.97.97.97-.97c.3-.3.77-.3 1.06 0ZM0 6a6 6 0 1 1 12 0A6 6 0 0 1 0 6Zm6-4.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9Z"]);
  var PresenceOffline16Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline16Regular", "16", ["M10.7 5.3a1 1 0 0 1 0 1.4L9.42 8l1.3 1.3a1 1 0 0 1-1.42 1.4L8 9.42l-1.3 1.3a1 1 0 0 1-1.4-1.42L6.58 8l-1.3-1.3a1 1 0 0 1 1.42-1.4L8 6.58l1.3-1.3a1 1 0 0 1 1.4 0ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
  var PresenceOffline20Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline20Regular", "20", ["M13.7 6.3a1 1 0 0 1 0 1.4L11.42 10l2.3 2.3a1 1 0 0 1-1.42 1.4L10 11.42l-2.3 2.3a1 1 0 0 1-1.4-1.42L8.58 10l-2.3-2.3a1 1 0 0 1 1.42-1.4L10 8.58l2.3-2.3a1 1 0 0 1 1.4 0ZM0 10a10 10 0 1 1 20 0 10 10 0 0 1-20 0Zm10-8a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"]);
  var PresenceOof10Regular = /* @__PURE__ */ createFluentIcon("PresenceOof10Regular", "10", ["M5.35 3.85a.5.5 0 1 0-.7-.7l-1.5 1.5a.5.5 0 0 0 0 .7l1.5 1.5a.5.5 0 1 0 .7-.7L4.7 5.5h1.8a.5.5 0 1 0 0-1H4.7l.65-.65ZM5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Z"]);
  var PresenceOof12Regular = /* @__PURE__ */ createFluentIcon("PresenceOof12Regular", "12", ["M6.28 4.53a.75.75 0 0 0-1.06-1.06l-2 2c-.3.3-.3.77 0 1.06l2 2a.75.75 0 0 0 1.06-1.06l-.72-.72h2.69a.75.75 0 1 0 0-1.5h-2.7l.73-.72ZM6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0Z"]);
  var PresenceOof16Regular = /* @__PURE__ */ createFluentIcon("PresenceOof16Regular", "16", ["M8.2 6.2a1 1 0 1 0-1.4-1.4L4.3 7.3a1 1 0 0 0 0 1.4l2.5 2.5a1 1 0 0 0 1.4-1.4L7.42 9H11a1 1 0 1 0 0-2H7.41l.8-.8ZM8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0ZM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8Z"]);
  var PresenceOof20Regular = /* @__PURE__ */ createFluentIcon("PresenceOof20Regular", "20", ["M10.7 7.7A1 1 0 1 0 9.28 6.3l-3 3a1 1 0 0 0 0 1.41l3 3a1 1 0 1 0 1.42-1.41l-1.3-1.3H13a1 1 0 1 0 0-2H9.4l1.3-1.29ZM10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Z"]);
  var PresenceUnknown10Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown10Regular", "10", ["M5 1a4 4 0 1 0 0 8 4 4 0 0 0 0-8ZM0 5a5 5 0 1 1 10 0A5 5 0 0 1 0 5Z"]);
  var PresenceUnknown12Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown12Regular", "12", ["M6 1.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9ZM0 6a6 6 0 1 1 12 0A6 6 0 0 1 0 6Z"]);
  var PresenceUnknown16Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown16Regular", "16", ["M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Z"]);
  var PresenceUnknown20Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown20Regular", "20", ["M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16ZM0 10a10 10 0 1 1 20 0 10 10 0 0 1-20 0Z"]);

  // ../../node_modules/@fluentui/react-motion/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-motion/lib/motions/motionTokens.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var durations2 = {
    durationUltraFast: 50,
    durationFaster: 100,
    durationFast: 150,
    durationNormal: 200,
    durationGentle: 250,
    durationSlow: 300,
    durationSlower: 400,
    durationUltraSlow: 500
  };
  var curves2 = {
    curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
    curveAccelerateMid: "cubic-bezier(1,0,1,1)",
    curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
    curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
    curveDecelerateMid: "cubic-bezier(0,0,0,1)",
    curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
    curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
    curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
    curveLinear: "cubic-bezier(0,0,1,1)"
  };
  var motionTokens = {
    ...durations2,
    ...curves2
  };

  // ../../node_modules/@fluentui/react-motion/lib/factories/createMotionComponent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React66 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useAnimateAtoms.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React61 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-motion/lib/utils/isAnimationRunning.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function isAnimationRunning(animation) {
    if (animation.playState === "running") {
      var _animation_effect;
      if (animation.overallProgress !== void 0) {
        var _animation_overallProgress;
        const overallProgress = (_animation_overallProgress = animation.overallProgress) !== null && _animation_overallProgress !== void 0 ? _animation_overallProgress : 0;
        return overallProgress > 0 && overallProgress < 1;
      }
      var _animation_currentTime;
      const currentTime = Number((_animation_currentTime = animation.currentTime) !== null && _animation_currentTime !== void 0 ? _animation_currentTime : 0);
      var _animation_effect_getTiming_duration;
      const totalTime = Number((_animation_effect_getTiming_duration = (_animation_effect = animation.effect) === null || _animation_effect === void 0 ? void 0 : _animation_effect.getTiming().duration) !== null && _animation_effect_getTiming_duration !== void 0 ? _animation_effect_getTiming_duration : 0);
      return currentTime > 0 && currentTime < totalTime;
    }
    return false;
  }

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useAnimateAtoms.js
  var DEFAULT_ANIMATION_OPTIONS = {
    fill: "forwards"
  };
  var DEFAULT_REDUCED_MOTION_ATOM = {
    duration: 1
  };
  function useAnimateAtomsInSupportedEnvironment() {
    var _window_Animation;
    const SUPPORTS_PERSIST = typeof window !== "undefined" && typeof ((_window_Animation = window.Animation) === null || _window_Animation === void 0 ? void 0 : _window_Animation.prototype.persist) === "function";
    return React61.useCallback((element, value, options) => {
      const atoms = Array.isArray(value) ? value : [
        value
      ];
      const { isReducedMotion } = options;
      const animations = atoms.map((motion) => {
        const { keyframes: motionKeyframes, reducedMotion = DEFAULT_REDUCED_MOTION_ATOM, ...params } = motion;
        const { keyframes: reducedMotionKeyframes = motionKeyframes, ...reducedMotionParams } = reducedMotion;
        const animationKeyframes = isReducedMotion ? reducedMotionKeyframes : motionKeyframes;
        const animationParams = {
          ...DEFAULT_ANIMATION_OPTIONS,
          ...params,
          // Use reduced motion overrides (e.g. duration, easing) when reduced motion is enabled
          ...isReducedMotion && reducedMotionParams
        };
        try {
          const animation = element.animate(animationKeyframes, animationParams);
          if (SUPPORTS_PERSIST) {
            animation === null || animation === void 0 ? void 0 : animation.persist();
          } else {
            const resultKeyframe = animationKeyframes[animationKeyframes.length - 1];
            var _element_style;
            Object.assign((_element_style = element.style) !== null && _element_style !== void 0 ? _element_style : {}, resultKeyframe);
          }
          return animation;
        } catch (e) {
          return null;
        }
      }).filter((animation) => !!animation);
      return {
        set playbackRate(rate) {
          animations.forEach((animation) => {
            animation.playbackRate = rate;
          });
        },
        setMotionEndCallbacks(onfinish, oncancel) {
          const promises = animations.map((animation) => {
            return new Promise((resolve, reject) => {
              animation.onfinish = () => resolve();
              animation.oncancel = () => reject();
            });
          });
          Promise.all(promises).then(() => {
            onfinish();
          }).catch(() => {
            oncancel();
          });
        },
        isRunning() {
          return animations.some((animation) => isAnimationRunning(animation));
        },
        cancel: () => {
          animations.forEach((animation) => {
            animation.cancel();
          });
        },
        pause: () => {
          animations.forEach((animation) => {
            animation.pause();
          });
        },
        play: () => {
          animations.forEach((animation) => {
            animation.play();
          });
        },
        finish: () => {
          animations.forEach((animation) => {
            animation.finish();
          });
        },
        reverse: () => {
          animations.forEach((animation) => {
            animation.reverse();
          });
        }
      };
    }, [
      SUPPORTS_PERSIST
    ]);
  }
  function useAnimateAtoms() {
    "use no memo";
    if (false) {
      return useAnimateAtomsInTestEnvironment();
    }
    return useAnimateAtomsInSupportedEnvironment();
  }

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useMotionImperativeRef.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React62 = __toESM(require_react());
  function useMotionImperativeRef(imperativeRef) {
    const animationRef = React62.useRef();
    React62.useImperativeHandle(imperativeRef, () => ({
      setPlayState: (state) => {
        if (state === "running") {
          var _animationRef_current;
          (_animationRef_current = animationRef.current) === null || _animationRef_current === void 0 ? void 0 : _animationRef_current.play();
        }
        if (state === "paused") {
          var _animationRef_current1;
          (_animationRef_current1 = animationRef.current) === null || _animationRef_current1 === void 0 ? void 0 : _animationRef_current1.pause();
        }
      },
      setPlaybackRate: (rate) => {
        if (animationRef.current) {
          animationRef.current.playbackRate = rate;
        }
      }
    }));
    return animationRef;
  }

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useIsReducedMotion.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React63 = __toESM(require_react());
  var REDUCED_MEDIA_QUERY = "screen and (prefers-reduced-motion: reduce)";
  function useIsReducedMotion() {
    const { targetDocument } = useFluent();
    var _targetDocument_defaultView;
    const targetWindow = (_targetDocument_defaultView = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) !== null && _targetDocument_defaultView !== void 0 ? _targetDocument_defaultView : null;
    const queryValue = React63.useRef(false);
    const isEnabled = React63.useCallback(() => queryValue.current, []);
    useIsomorphicLayoutEffect2(() => {
      if (targetWindow === null || typeof targetWindow.matchMedia !== "function") {
        return;
      }
      const queryMatch = targetWindow.matchMedia(REDUCED_MEDIA_QUERY);
      if (queryMatch.matches) {
        queryValue.current = true;
      }
      const matchListener = (e) => {
        queryValue.current = e.matches;
      };
      queryMatch.addEventListener("change", matchListener);
      return () => {
        queryMatch.removeEventListener("change", matchListener);
      };
    }, [
      targetWindow
    ]);
    return isEnabled;
  }

  // ../../node_modules/@fluentui/react-motion/lib/utils/useChildElement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React64 = __toESM(require_react());
  var IS_REACT_19 = React64.version.startsWith("19.");
  var CHILD_ERROR_MESSAGE = [
    "@fluentui/react-motion: Invalid child element.",
    "\n",
    "Motion factories require a single child element to be passed. ",
    "That element element should support ref forwarding i.e. it should be either an intrinsic element (e.g. div) or a component that uses React.forwardRef()."
  ].join("");
  function getRefFromReactElement(element) {
    if (IS_REACT_19) {
      return element.props.ref;
    }
    return element.ref;
  }
  function useChildElement(children, mounted = true) {
    const childRef = React64.useRef(null);
    React64.useEffect(() => {
      if (false) {
        if (mounted && !childRef.current) {
          console.error(CHILD_ERROR_MESSAGE);
        }
      }
    }, [
      mounted
    ]);
    try {
      const child = React64.Children.only(children);
      if (React64.isValidElement(child)) {
        return [
          React64.cloneElement(child, {
            ref: useMergedRefs(childRef, getRefFromReactElement(child))
          }),
          childRef
        ];
      }
    } catch {
    }
    throw new Error(CHILD_ERROR_MESSAGE);
  }

  // ../../node_modules/@fluentui/react-motion/lib/contexts/MotionBehaviourContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React65 = __toESM(require_react());
  var MotionBehaviourContext = React65.createContext(void 0);
  var MotionBehaviourProvider = MotionBehaviourContext.Provider;
  var useMotionBehaviourContext = () => {
    var _React_useContext;
    return (_React_useContext = React65.useContext(MotionBehaviourContext)) !== null && _React_useContext !== void 0 ? _React_useContext : "default";
  };

  // ../../node_modules/@fluentui/react-motion/lib/factories/createMotionComponent.js
  function createMotionComponent(value) {
    const Atom = (props) => {
      "use no memo";
      const { children, imperativeRef, onMotionFinish: onMotionFinishProp, onMotionStart: onMotionStartProp, onMotionCancel: onMotionCancelProp, ..._rest } = props;
      const params = _rest;
      const [child, childRef] = useChildElement(children);
      const handleRef = useMotionImperativeRef(imperativeRef);
      const skipMotions = useMotionBehaviourContext() === "skip";
      const optionsRef = React66.useRef({
        skipMotions,
        params
      });
      const animateAtoms = useAnimateAtoms();
      const isReducedMotion = useIsReducedMotion();
      const onMotionStart = useEventCallback(() => {
        onMotionStartProp === null || onMotionStartProp === void 0 ? void 0 : onMotionStartProp(null);
      });
      const onMotionFinish = useEventCallback(() => {
        onMotionFinishProp === null || onMotionFinishProp === void 0 ? void 0 : onMotionFinishProp(null);
      });
      const onMotionCancel = useEventCallback(() => {
        onMotionCancelProp === null || onMotionCancelProp === void 0 ? void 0 : onMotionCancelProp(null);
      });
      useIsomorphicLayoutEffect2(() => {
        optionsRef.current = {
          skipMotions,
          params
        };
      });
      useIsomorphicLayoutEffect2(() => {
        const element = childRef.current;
        if (element) {
          const atoms = typeof value === "function" ? value({
            element,
            ...optionsRef.current.params
          }) : value;
          onMotionStart();
          const handle = animateAtoms(element, atoms, {
            isReducedMotion: isReducedMotion()
          });
          handleRef.current = handle;
          handle.setMotionEndCallbacks(onMotionFinish, onMotionCancel);
          if (optionsRef.current.skipMotions) {
            handle.finish();
          }
          return () => {
            handle.cancel();
          };
        }
      }, [
        animateAtoms,
        childRef,
        handleRef,
        isReducedMotion,
        onMotionFinish,
        onMotionStart,
        onMotionCancel
      ]);
      return child;
    };
    return Atom;
  }

  // ../../node_modules/@fluentui/react-motion/lib/factories/createPresenceComponent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React69 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-motion/lib/contexts/PresenceGroupChildContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React67 = __toESM(require_react());
  var PresenceGroupChildContext = React67.createContext(void 0);
  var PresenceGroupChildProvider = PresenceGroupChildContext.Provider;

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useMountedState.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React68 = __toESM(require_react());
  function useMountedState(visible = false, unmountOnExit = false) {
    const mountedRef = React68.useRef(unmountOnExit ? visible : true);
    const forceUpdate = useForceUpdate();
    const setMounted = React68.useCallback((newValue) => {
      if (mountedRef.current !== newValue) {
        mountedRef.current = newValue;
        forceUpdate();
      }
    }, [
      forceUpdate
    ]);
    React68.useEffect(() => {
      if (visible) {
        mountedRef.current = visible;
      }
    });
    return [
      visible || mountedRef.current,
      setMounted
    ];
  }

  // ../../node_modules/@fluentui/react-motion/lib/factories/createPresenceComponent.js
  var MOTION_DEFINITION = Symbol("MOTION_DEFINITION");
  var INTERRUPTABLE_MOTION_SYMBOL = Symbol.for("interruptablePresence");
  function createPresenceComponent(value) {
    return Object.assign((props) => {
      "use no memo";
      const itemContext = React69.useContext(PresenceGroupChildContext);
      const merged = {
        ...itemContext,
        ...props
      };
      const skipMotions = useMotionBehaviourContext() === "skip";
      const { appear, children, imperativeRef, onExit, onMotionFinish, onMotionStart, onMotionCancel, visible, unmountOnExit, ..._rest } = merged;
      const params = _rest;
      const [mounted, setMounted] = useMountedState(visible, unmountOnExit);
      const [child, childRef] = useChildElement(children, mounted);
      const handleRef = useMotionImperativeRef(imperativeRef);
      const optionsRef = React69.useRef({
        appear,
        params,
        skipMotions
      });
      const animateAtoms = useAnimateAtoms();
      const isFirstMount = useFirstMount();
      const isReducedMotion = useIsReducedMotion();
      const handleMotionStart = useEventCallback((direction) => {
        onMotionStart === null || onMotionStart === void 0 ? void 0 : onMotionStart(null, {
          direction
        });
      });
      const handleMotionFinish = useEventCallback((direction) => {
        onMotionFinish === null || onMotionFinish === void 0 ? void 0 : onMotionFinish(null, {
          direction
        });
        if (direction === "exit" && unmountOnExit) {
          setMounted(false);
          onExit === null || onExit === void 0 ? void 0 : onExit();
        }
      });
      const handleMotionCancel = useEventCallback((direction) => {
        onMotionCancel === null || onMotionCancel === void 0 ? void 0 : onMotionCancel(null, {
          direction
        });
      });
      useIsomorphicLayoutEffect2(() => {
        optionsRef.current = {
          appear,
          params,
          skipMotions
        };
      });
      useIsomorphicLayoutEffect2(
        () => {
          const element = childRef.current;
          if (!element) {
            return;
          }
          let handle;
          function cleanup() {
            if (!handle) {
              return;
            }
            if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION && handle.isRunning()) {
              return;
            }
            handle.cancel();
            handleRef.current = void 0;
          }
          const presenceMotion = typeof value === "function" ? value({
            element,
            ...optionsRef.current.params
          }) : value;
          const IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION = presenceMotion[INTERRUPTABLE_MOTION_SYMBOL];
          if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION) {
            handle = handleRef.current;
            if (handle && handle.isRunning()) {
              handle.reverse();
              return cleanup;
            }
          }
          const atoms = visible ? presenceMotion.enter : presenceMotion.exit;
          const direction = visible ? "enter" : "exit";
          const applyInitialStyles = !optionsRef.current.appear && isFirstMount;
          const skipAnimationByConfig = optionsRef.current.skipMotions;
          if (!applyInitialStyles) {
            handleMotionStart(direction);
          }
          handle = animateAtoms(element, atoms, {
            isReducedMotion: isReducedMotion()
          });
          if (applyInitialStyles) {
            handle.finish();
            return cleanup;
          }
          handleRef.current = handle;
          handle.setMotionEndCallbacks(() => handleMotionFinish(direction), () => handleMotionCancel(direction));
          if (skipAnimationByConfig) {
            handle.finish();
          }
          return cleanup;
        },
        // Excluding `isFirstMount` from deps to prevent re-triggering the animation on subsequent renders
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [
          animateAtoms,
          childRef,
          handleRef,
          isReducedMotion,
          handleMotionFinish,
          handleMotionStart,
          handleMotionCancel,
          visible
        ]
      );
      if (mounted) {
        return child;
      }
      return null;
    }, {
      // Heads up!
      // Always normalize it to a function to simplify types
      [MOTION_DEFINITION]: typeof value === "function" ? value : () => value
    }, {
      // Wrap `enter` in its own motion component as a static method, e.g. <Fade.In>
      In: createMotionComponent(
        // If we have a motion function, wrap it to forward the runtime params and pick `enter`.
        // Otherwise, pass the `enter` motion object directly.
        typeof value === "function" ? (...args) => value(...args).enter : value.enter
      ),
      // Wrap `exit` in its own motion component as a static method, e.g. <Fade.Out>
      Out: createMotionComponent(
        // If we have a motion function, wrap it to forward the runtime params and pick `exit`.
        // Otherwise, pass the `exit` motion object directly.
        typeof value === "function" ? (...args) => value(...args).exit : value.exit
      )
    });
  }

  // ../../node_modules/@fluentui/react-motion/lib/factories/createPresenceComponentVariant.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function createPresenceFnVariant(presenceFn, variantParams) {
    const variantFn = (runtimeParams) => presenceFn({
      ...variantParams,
      ...runtimeParams
    });
    return variantFn;
  }
  function createPresenceComponentVariant(component, variantParams) {
    const originalFn = component[MOTION_DEFINITION];
    const variantFn = createPresenceFnVariant(originalFn, variantParams);
    return createPresenceComponent(variantFn);
  }

  // ../../node_modules/@fluentui/react-motion/lib/slots/presenceMotionSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React70 = __toESM(require_react());
  function presenceMotionSlot(motion, options) {
    const { as, children, ...rest } = motion !== null && motion !== void 0 ? motion : {};
    if (false) {
      if (typeof as !== "undefined") {
        throw new Error(`@fluentui/react-motion: "as" property is not supported on motion slots.`);
      }
    }
    if (motion === null) {
      const isUnmounted = !options.defaultProps.visible && options.defaultProps.unmountOnExit;
      const renderFn = (_, props) => isUnmounted ? null : /* @__PURE__ */ React70.createElement(React70.Fragment, null, props.children);
      return {
        [SLOT_RENDER_FUNCTION_SYMBOL]: renderFn,
        [SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
      };
    }
    const propsWithMetadata = {
      ...options.defaultProps,
      ...rest,
      [SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
    };
    if (typeof children === "function") {
      propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = children;
    }
    return propsWithMetadata;
  }

  // ../../node_modules/@fluentui/react-motion-components-preview/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-motion-components-preview/lib/atoms/fade-atom.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var fadeAtom = ({ direction, duration, easing = motionTokens.curveLinear, fromValue = 0 }) => {
    const keyframes2 = [
      {
        opacity: fromValue
      },
      {
        opacity: 1
      }
    ];
    if (direction === "exit") {
      keyframes2.reverse();
    }
    return {
      keyframes: keyframes2,
      duration,
      easing
    };
  };

  // ../../node_modules/@fluentui/react-motion-components-preview/lib/components/Fade/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-motion-components-preview/lib/components/Fade/Fade.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var fadePresenceFn = ({ duration = motionTokens.durationNormal, easing = motionTokens.curveEasyEase, exitDuration = duration, exitEasing = easing }) => {
    return {
      enter: fadeAtom({
        direction: "enter",
        duration,
        easing
      }),
      exit: fadeAtom({
        direction: "exit",
        duration: exitDuration,
        easing: exitEasing
      })
    };
  };
  var Fade = createPresenceComponent(fadePresenceFn);
  var FadeSnappy = createPresenceComponentVariant(Fade, {
    duration: motionTokens.durationFast
  });
  var FadeRelaxed = createPresenceComponentVariant(Fade, {
    duration: motionTokens.durationGentle
  });

  // ../../node_modules/@fluentui/react-avatar/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-avatar/lib/Avatar.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React78 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/renderAvatar.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderAvatar_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.initials && /* @__PURE__ */ jsx(state.initials, {}),
        state.icon && /* @__PURE__ */ jsx(state.icon, {}),
        state.image && /* @__PURE__ */ jsx(state.image, {}),
        state.badge && /* @__PURE__ */ jsx(state.badge, {}),
        state.activeAriaLabelElement
      ]
    });
  };

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React77 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-avatar/lib/utils/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-avatar/lib/utils/getInitials.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var UNWANTED_ENCLOSURES_REGEX = /[\(\[\{][^\)\]\}]*[\)\]\}]/g;
  var UNWANTED_CHARS_REGEX = /[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
  var PHONENUMBER_REGEX = /^\d+[\d\s]*(:?ext|x|)\s*\d+$/i;
  var MULTIPLE_WHITESPACES_REGEX = /\s+/g;
  var UNSUPPORTED_TEXT_REGEX = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
  function getInitialsLatin(displayName, isRtl, firstInitialOnly) {
    let initials = "";
    const splits = displayName.split(" ");
    if (splits.length !== 0) {
      initials += splits[0].charAt(0).toUpperCase();
    }
    if (!firstInitialOnly) {
      if (splits.length === 2) {
        initials += splits[1].charAt(0).toUpperCase();
      } else if (splits.length === 3) {
        initials += splits[2].charAt(0).toUpperCase();
      }
    }
    if (isRtl && initials.length > 1) {
      return initials.charAt(1) + initials.charAt(0);
    }
    return initials;
  }
  function cleanupDisplayName(displayName) {
    displayName = displayName.replace(UNWANTED_ENCLOSURES_REGEX, "");
    displayName = displayName.replace(UNWANTED_CHARS_REGEX, "");
    displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, " ");
    displayName = displayName.trim();
    return displayName;
  }
  function getInitials(displayName, isRtl, options) {
    if (!displayName) {
      return "";
    }
    displayName = cleanupDisplayName(displayName);
    if (UNSUPPORTED_TEXT_REGEX.test(displayName) || !(options === null || options === void 0 ? void 0 : options.allowPhoneInitials) && PHONENUMBER_REGEX.test(displayName)) {
      return "";
    }
    return getInitialsLatin(displayName, isRtl, options === null || options === void 0 ? void 0 : options.firstInitialOnly);
  }

  // ../../node_modules/@fluentui/react-badge/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-badge/lib/Badge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React72 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/useBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React71 = __toESM(require_react());
  var useBadge_unstable = (props, ref) => {
    const { shape = "circular", size = "medium", iconPosition = "before", appearance = "filled", color = "brand" } = props;
    const state = {
      shape,
      size,
      iconPosition,
      appearance,
      color,
      components: {
        root: "div",
        icon: "span"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      }),
      icon: slot_exports.optional(props.icon, {
        elementType: "span"
      })
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/useBadgeStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var badgeClassNames = {
    root: "fui-Badge",
    icon: "fui-Badge__icon"
  };
  var textPadding = tokens.spacingHorizontalXXS;
  var useRootClassName = /* @__PURE__ */ __resetStyles2("r1iycov", "r115jdol", [".r1iycov{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.r1iycov::after{content:"";position:absolute;top:0;left:0;bottom:0;right:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}', ".r115jdol{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.r115jdol::after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}']);
  var useRootStyles2 = /* @__PURE__ */ __styles2({
    fontSmallToTiny: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "f13mqy1h",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "fcpl73t"
    },
    tiny: {
      a9b677: "f16dn6v3",
      Bqenvij: "f3mu39s",
      Be2twd7: "f130uwy9",
      Bg96gwp: "fod1mrr",
      Bf4jedk: "f18p0k4z",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f19jm9xf"
    },
    "extra-small": {
      a9b677: "fpd43o0",
      Bqenvij: "f30q22z",
      Be2twd7: "f1tccstq",
      Bg96gwp: "f1y3arg5",
      Bf4jedk: "f18p0k4z",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f19jm9xf"
    },
    small: {
      Bf4jedk: "fq2vo04",
      Bqenvij: "fd461yt",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fupdldz"
    },
    medium: {},
    large: {
      Bf4jedk: "f17fgpbq",
      Bqenvij: "frvgh55",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1996nqw"
    },
    "extra-large": {
      Bf4jedk: "fwbmr0d",
      Bqenvij: "f1d2rq10",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fty64o7"
    },
    square: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f1fabniw"
    },
    rounded: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5"
    },
    roundedSmallToTiny: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "fq9zq91"
    },
    circular: {},
    borderGhost: {
      ap17g6: "f10ludwy"
    },
    filled: {},
    "filled-brand": {
      De3pzq: "ffp7eso",
      sj55zd: "f1phragk"
    },
    "filled-danger": {
      De3pzq: "fdl5y0r",
      sj55zd: "f1phragk"
    },
    "filled-important": {
      De3pzq: "f1c73kur",
      sj55zd: "fr0bkrk"
    },
    "filled-informative": {
      De3pzq: "f3vzo32",
      sj55zd: "f11d4kpn"
    },
    "filled-severe": {
      De3pzq: "f1s438gw",
      sj55zd: "f1phragk"
    },
    "filled-subtle": {
      De3pzq: "fxugw4r",
      sj55zd: "f19n0e5"
    },
    "filled-success": {
      De3pzq: "flxk52p",
      sj55zd: "f1phragk"
    },
    "filled-warning": {
      De3pzq: "ffq97bm",
      sj55zd: "ff5vbop"
    },
    ghost: {},
    "ghost-brand": {
      sj55zd: "f16muhyy"
    },
    "ghost-danger": {
      sj55zd: "f1whyuy6"
    },
    "ghost-important": {
      sj55zd: "f19n0e5"
    },
    "ghost-informative": {
      sj55zd: "f11d4kpn"
    },
    "ghost-severe": {
      sj55zd: "f1l8vj45"
    },
    "ghost-subtle": {
      sj55zd: "fonrgv7"
    },
    "ghost-success": {
      sj55zd: "f1m7fhi8"
    },
    "ghost-warning": {
      sj55zd: "fpti2h4"
    },
    outline: {
      g2u3we: "f23ftbb",
      h3c5rm: ["f1gkuv52", "f1p1bl80"],
      B9xav0g: "fioka3i",
      zhjwy3: ["f1p1bl80", "f1gkuv52"]
    },
    "outline-brand": {
      sj55zd: "f16muhyy"
    },
    "outline-danger": {
      sj55zd: "f1whyuy6",
      g2u3we: "fyqpifd",
      h3c5rm: ["f3ukxca", "f1k7dugc"],
      B9xav0g: "f1njxb2b",
      zhjwy3: ["f1k7dugc", "f3ukxca"]
    },
    "outline-important": {
      sj55zd: "f11d4kpn",
      g2u3we: "fq0vr37",
      h3c5rm: ["f1byw159", "f11cr0be"],
      B9xav0g: "f1c1zstj",
      zhjwy3: ["f11cr0be", "f1byw159"]
    },
    "outline-informative": {
      sj55zd: "f11d4kpn",
      g2u3we: "f68mrw8",
      h3c5rm: ["f7pw515", "fw35ms5"],
      B9xav0g: "frpde29",
      zhjwy3: ["fw35ms5", "f7pw515"]
    },
    "outline-severe": {
      sj55zd: "f1l8vj45"
    },
    "outline-subtle": {
      sj55zd: "fonrgv7"
    },
    "outline-success": {
      sj55zd: "f1m7fhi8",
      g2u3we: "f1mmhl11",
      h3c5rm: ["f1tjpp2f", "f1ocn5n7"],
      B9xav0g: "f1gjv25d",
      zhjwy3: ["f1ocn5n7", "f1tjpp2f"]
    },
    "outline-warning": {
      sj55zd: "fpti2h4"
    },
    tint: {},
    "tint-brand": {
      De3pzq: "f16xkysk",
      sj55zd: "faj9fo0",
      g2u3we: "f161y7kd",
      h3c5rm: ["f1c8dzaj", "f1sl6hi9"],
      B9xav0g: "f1619yhw",
      zhjwy3: ["f1sl6hi9", "f1c8dzaj"]
    },
    "tint-danger": {
      De3pzq: "ff0poqj",
      sj55zd: "f1hcrxcs",
      g2u3we: "f1oqjm8o",
      h3c5rm: ["fkgrb8g", "frb5wm0"],
      B9xav0g: "f1iai1ph",
      zhjwy3: ["frb5wm0", "fkgrb8g"]
    },
    "tint-important": {
      De3pzq: "f945g0u",
      sj55zd: "fr0bkrk",
      g2u3we: "fghlq4f",
      h3c5rm: ["f1gn591s", "fjscplz"],
      B9xav0g: "fb073pr",
      zhjwy3: ["fjscplz", "f1gn591s"]
    },
    "tint-informative": {
      De3pzq: "f1ctqxl6",
      sj55zd: "f11d4kpn",
      g2u3we: "f68mrw8",
      h3c5rm: ["f7pw515", "fw35ms5"],
      B9xav0g: "frpde29",
      zhjwy3: ["fw35ms5", "f7pw515"]
    },
    "tint-severe": {
      De3pzq: "f1xzsg4",
      sj55zd: "f1k5f75o",
      g2u3we: "fxy9dsj",
      h3c5rm: ["f54u6j2", "fcm23ze"],
      B9xav0g: "f4vf0uq",
      zhjwy3: ["fcm23ze", "f54u6j2"]
    },
    "tint-subtle": {
      De3pzq: "fxugw4r",
      sj55zd: "f11d4kpn",
      g2u3we: "f68mrw8",
      h3c5rm: ["f7pw515", "fw35ms5"],
      B9xav0g: "frpde29",
      zhjwy3: ["fw35ms5", "f7pw515"]
    },
    "tint-success": {
      De3pzq: "f2vsrz6",
      sj55zd: "ffmvakt",
      g2u3we: "fdmic9h",
      h3c5rm: ["f196y6m", "fetptd8"],
      B9xav0g: "f1pev5xq",
      zhjwy3: ["fetptd8", "f196y6m"]
    },
    "tint-warning": {
      De3pzq: "f10s6hli",
      sj55zd: "f42v8de",
      g2u3we: "fn9i3n",
      h3c5rm: ["f1aw8cx4", "f51if14"],
      B9xav0g: "fvq8iai",
      zhjwy3: ["f51if14", "f1aw8cx4"]
    }
  }, {
    d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".f16dn6v3{width:6px;}", ".f3mu39s{height:6px;}", ".f130uwy9{font-size:4px;}", ".fod1mrr{line-height:4px;}", ".f18p0k4z{min-width:unset;}", [".f19jm9xf{padding:unset;}", {
      p: -1
    }], ".fpd43o0{width:10px;}", ".f30q22z{height:10px;}", ".f1tccstq{font-size:6px;}", ".f1y3arg5{line-height:6px;}", [".f19jm9xf{padding:unset;}", {
      p: -1
    }], ".fq2vo04{min-width:16px;}", ".fd461yt{height:16px;}", [".fupdldz{padding:0 calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".f17fgpbq{min-width:24px;}", ".frvgh55{height:24px;}", [".f1996nqw{padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".fwbmr0d{min-width:32px;}", ".f1d2rq10{height:32px;}", [".fty64o7{padding:0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
      p: -1
    }], ".f10ludwy::after{display:none;}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fdl5y0r{background-color:var(--colorPaletteRedBackground3);}", ".f1c73kur{background-color:var(--colorNeutralForeground1);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f3vzo32{background-color:var(--colorNeutralBackground5);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f1s438gw{background-color:var(--colorPaletteDarkOrangeBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".flxk52p{background-color:var(--colorPaletteGreenBackground3);}", ".ffq97bm{background-color:var(--colorPaletteYellowBackground3);}", ".ff5vbop{color:var(--colorNeutralForeground1Static);}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".f1l8vj45{color:var(--colorPaletteDarkOrangeForeground3);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1m7fhi8{color:var(--colorPaletteGreenForeground3);}", ".fpti2h4{color:var(--colorPaletteYellowForeground2);}", ".f23ftbb{border-top-color:currentColor;}", ".f1gkuv52{border-right-color:currentColor;}", ".f1p1bl80{border-left-color:currentColor;}", ".fioka3i{border-bottom-color:currentColor;}", ".fyqpifd{border-top-color:var(--colorPaletteRedBorder2);}", ".f3ukxca{border-right-color:var(--colorPaletteRedBorder2);}", ".f1k7dugc{border-left-color:var(--colorPaletteRedBorder2);}", ".f1njxb2b{border-bottom-color:var(--colorPaletteRedBorder2);}", ".fq0vr37{border-top-color:var(--colorNeutralStrokeAccessible);}", ".f1byw159{border-right-color:var(--colorNeutralStrokeAccessible);}", ".f11cr0be{border-left-color:var(--colorNeutralStrokeAccessible);}", ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".f68mrw8{border-top-color:var(--colorNeutralStroke2);}", ".f7pw515{border-right-color:var(--colorNeutralStroke2);}", ".fw35ms5{border-left-color:var(--colorNeutralStroke2);}", ".frpde29{border-bottom-color:var(--colorNeutralStroke2);}", ".f1mmhl11{border-top-color:var(--colorPaletteGreenBorder2);}", ".f1tjpp2f{border-right-color:var(--colorPaletteGreenBorder2);}", ".f1ocn5n7{border-left-color:var(--colorPaletteGreenBorder2);}", ".f1gjv25d{border-bottom-color:var(--colorPaletteGreenBorder2);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", ".f161y7kd{border-top-color:var(--colorBrandStroke2);}", ".f1c8dzaj{border-right-color:var(--colorBrandStroke2);}", ".f1sl6hi9{border-left-color:var(--colorBrandStroke2);}", ".f1619yhw{border-bottom-color:var(--colorBrandStroke2);}", ".ff0poqj{background-color:var(--colorPaletteRedBackground1);}", ".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".f1oqjm8o{border-top-color:var(--colorPaletteRedBorder1);}", ".fkgrb8g{border-right-color:var(--colorPaletteRedBorder1);}", ".frb5wm0{border-left-color:var(--colorPaletteRedBorder1);}", ".f1iai1ph{border-bottom-color:var(--colorPaletteRedBorder1);}", ".f945g0u{background-color:var(--colorNeutralForeground3);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".f1xzsg4{background-color:var(--colorPaletteDarkOrangeBackground1);}", ".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}", ".fxy9dsj{border-top-color:var(--colorPaletteDarkOrangeBorder1);}", ".f54u6j2{border-right-color:var(--colorPaletteDarkOrangeBorder1);}", ".fcm23ze{border-left-color:var(--colorPaletteDarkOrangeBorder1);}", ".f4vf0uq{border-bottom-color:var(--colorPaletteDarkOrangeBorder1);}", ".f2vsrz6{background-color:var(--colorPaletteGreenBackground1);}", ".ffmvakt{color:var(--colorPaletteGreenForeground1);}", ".fdmic9h{border-top-color:var(--colorPaletteGreenBorder1);}", ".f196y6m{border-right-color:var(--colorPaletteGreenBorder1);}", ".fetptd8{border-left-color:var(--colorPaletteGreenBorder1);}", ".f1pev5xq{border-bottom-color:var(--colorPaletteGreenBorder1);}", ".f10s6hli{background-color:var(--colorPaletteYellowBackground1);}", ".f42v8de{color:var(--colorPaletteYellowForeground1);}", ".fn9i3n{border-top-color:var(--colorPaletteYellowBorder1);}", ".f1aw8cx4{border-right-color:var(--colorPaletteYellowBorder1);}", ".f51if14{border-left-color:var(--colorPaletteYellowBorder1);}", ".fvq8iai{border-bottom-color:var(--colorPaletteYellowBorder1);}"]
  });
  var useIconRootClassName = /* @__PURE__ */ __resetStyles2("rttl5z0", null, [".rttl5z0{display:flex;line-height:1;margin:0 calc(-1 * var(--spacingHorizontalXXS));font-size:12px;}"]);
  var useIconStyles = /* @__PURE__ */ __styles2({
    beforeText: {
      t21cq0: ["f1t8l4o1", "f11juvx6"]
    },
    afterText: {
      Frg6f3: ["f11juvx6", "f1t8l4o1"]
    },
    beforeTextXL: {
      t21cq0: ["f1rs9grm", "f1kwmkpi"]
    },
    afterTextXL: {
      Frg6f3: ["f1kwmkpi", "f1rs9grm"]
    },
    tiny: {
      Be2twd7: "f1tccstq"
    },
    "extra-small": {
      Be2twd7: "fnmn6fi"
    },
    small: {
      Be2twd7: "f1ugzwwg"
    },
    medium: {},
    large: {
      Be2twd7: "f4ybsrx"
    },
    "extra-large": {
      Be2twd7: "fe5j1ua"
    }
  }, {
    d: [".f1t8l4o1{margin-right:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f11juvx6{margin-left:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f1rs9grm{margin-right:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1kwmkpi{margin-left:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1tccstq{font-size:6px;}", ".fnmn6fi{font-size:10px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}"]
  });
  var useBadgeStyles_unstable = (state) => {
    "use no memo";
    const rootClassName = useRootClassName();
    const rootStyles = useRootStyles2();
    const smallToTiny = state.size === "small" || state.size === "extra-small" || state.size === "tiny";
    state.root.className = mergeClasses(badgeClassNames.root, rootClassName, smallToTiny && rootStyles.fontSmallToTiny, rootStyles[state.size], rootStyles[state.shape], state.shape === "rounded" && smallToTiny && rootStyles.roundedSmallToTiny, state.appearance === "ghost" && rootStyles.borderGhost, rootStyles[state.appearance], rootStyles[`${state.appearance}-${state.color}`], state.root.className);
    const iconRootClassName = useIconRootClassName();
    const iconStyles = useIconStyles();
    if (state.icon) {
      let iconPositionClass;
      if (state.root.children) {
        if (state.size === "extra-large") {
          iconPositionClass = state.iconPosition === "after" ? iconStyles.afterTextXL : iconStyles.beforeTextXL;
        } else {
          iconPositionClass = state.iconPosition === "after" ? iconStyles.afterText : iconStyles.beforeText;
        }
      }
      state.icon.className = mergeClasses(badgeClassNames.icon, iconRootClassName, iconPositionClass, iconStyles[state.size], state.icon.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/renderBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderBadge_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.iconPosition === "before" && state.icon && /* @__PURE__ */ jsx(state.icon, {}),
        state.root.children,
        state.iconPosition === "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
  var Badge = /* @__PURE__ */ React72.forwardRef((props, ref) => {
    const state = useBadge_unstable(props, ref);
    useBadgeStyles_unstable(state);
    useCustomStyleHook("useBadgeStyles_unstable")(state);
    return renderBadge_unstable(state);
  });
  Badge.displayName = "Badge";

  // ../../node_modules/@fluentui/react-badge/lib/PresenceBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React75 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React74 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/presenceIcons.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React73 = __toESM(require_react());
  var presenceAwayFilled = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceAway10Filled,
    "extra-small": PresenceAway10Filled,
    small: PresenceAway12Filled,
    medium: PresenceAway16Filled,
    large: PresenceAway20Filled,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceAway20Filled
  };
  var presenceAvailableRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceAvailable10Regular,
    "extra-small": PresenceAvailable10Regular,
    small: PresenceAvailable12Regular,
    medium: PresenceAvailable16Regular,
    large: PresenceAvailable20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceAvailable20Regular
  };
  var presenceAvailableFilled = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceAvailable10Filled,
    "extra-small": PresenceAvailable10Filled,
    small: PresenceAvailable12Filled,
    medium: PresenceAvailable16Filled,
    large: PresenceAvailable20Filled,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceAvailable20Filled
  };
  var presenceBlockedRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceBlocked10Regular,
    "extra-small": PresenceBlocked10Regular,
    small: PresenceBlocked12Regular,
    medium: PresenceBlocked16Regular,
    large: PresenceBlocked20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceBlocked20Regular
  };
  var presenceBusyFilled = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceBusy10Filled,
    "extra-small": PresenceBusy10Filled,
    small: PresenceBusy12Filled,
    medium: PresenceBusy16Filled,
    large: PresenceBusy20Filled,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceBusy20Filled
  };
  var presenceDndFilled = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceDnd10Filled,
    "extra-small": PresenceDnd10Filled,
    small: PresenceDnd12Filled,
    medium: PresenceDnd16Filled,
    large: PresenceDnd20Filled,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceDnd20Filled
  };
  var presenceDndRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceDnd10Regular,
    "extra-small": PresenceDnd10Regular,
    small: PresenceDnd12Regular,
    medium: PresenceDnd16Regular,
    large: PresenceDnd20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceDnd20Regular
  };
  var presenceOofRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceOof10Regular,
    "extra-small": PresenceOof10Regular,
    small: PresenceOof12Regular,
    medium: PresenceOof16Regular,
    large: PresenceOof20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceOof20Regular
  };
  var presenceOfflineRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceOffline10Regular,
    "extra-small": PresenceOffline10Regular,
    small: PresenceOffline12Regular,
    medium: PresenceOffline16Regular,
    large: PresenceOffline20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceOffline20Regular
  };
  var presenceUnknownRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceUnknown10Regular,
    "extra-small": PresenceUnknown10Regular,
    small: PresenceUnknown12Regular,
    medium: PresenceUnknown16Regular,
    large: PresenceUnknown20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceUnknown20Regular
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
  var iconMap = (status, outOfOffice, size) => {
    switch (status) {
      case "available":
        return outOfOffice ? presenceAvailableRegular[size] : presenceAvailableFilled[size];
      case "away":
        return outOfOffice ? presenceOofRegular[size] : presenceAwayFilled[size];
      case "blocked":
        return presenceBlockedRegular[size];
      case "busy":
        return outOfOffice ? presenceUnknownRegular[size] : presenceBusyFilled[size];
      case "do-not-disturb":
        return outOfOffice ? presenceDndRegular[size] : presenceDndFilled[size];
      case "offline":
        return outOfOffice ? presenceOofRegular[size] : presenceOfflineRegular[size];
      case "out-of-office":
        return presenceOofRegular[size];
      case "unknown":
        return presenceUnknownRegular[size];
    }
  };
  var DEFAULT_STRINGS = {
    busy: "busy",
    "out-of-office": "out of office",
    away: "away",
    available: "available",
    offline: "offline",
    "do-not-disturb": "do not disturb",
    unknown: "unknown",
    blocked: "blocked"
  };
  var usePresenceBadge_unstable = (props, ref) => {
    const { size = "medium", status = "available", outOfOffice = false } = props;
    const statusText = DEFAULT_STRINGS[status];
    const oofText = props.outOfOffice && props.status !== "out-of-office" ? ` ${DEFAULT_STRINGS["out-of-office"]}` : "";
    const IconElement = iconMap(status, outOfOffice, size);
    const state = {
      ...useBadge_unstable({
        "aria-label": statusText + oofText,
        role: "img",
        ...props,
        size,
        icon: slot_exports.optional(props.icon, {
          defaultProps: {
            children: IconElement ? /* @__PURE__ */ React74.createElement(IconElement, null) : null
          },
          renderByDefault: true,
          elementType: "span"
        })
      }, ref),
      status,
      outOfOffice
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadgeStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var presenceBadgeClassNames = {
    root: "fui-PresenceBadge",
    icon: "fui-PresenceBadge__icon"
  };
  var getIsBusy = (status) => {
    if (status === "busy" || status === "do-not-disturb" || status === "blocked") {
      return true;
    }
    return false;
  };
  var useRootClassName2 = /* @__PURE__ */ __resetStyles2("r832ydo", null, [".r832ydo{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;border-radius:var(--borderRadiusCircular);background-color:var(--colorNeutralBackground1);padding:1px;background-clip:content-box;}"]);
  var useIconClassName = /* @__PURE__ */ __resetStyles2("r11ag4qr", null, [".r11ag4qr{display:flex;margin:-1px;}"]);
  var useStyles2 = /* @__PURE__ */ __styles2({
    statusBusy: {
      sj55zd: "fvi85wt"
    },
    statusAway: {
      sj55zd: "f14k8a89"
    },
    statusAvailable: {
      sj55zd: "fqa5hgp"
    },
    statusOffline: {
      sj55zd: "f11d4kpn"
    },
    statusOutOfOffice: {
      sj55zd: "fdce8r3"
    },
    statusUnknown: {
      sj55zd: "f11d4kpn"
    },
    outOfOffice: {
      sj55zd: "fr0bkrk"
    },
    outOfOfficeAvailable: {
      sj55zd: "fqa5hgp"
    },
    outOfOfficeBusy: {
      sj55zd: "fvi85wt"
    },
    outOfOfficeUnknown: {
      sj55zd: "f11d4kpn"
    },
    tiny: {
      Bubjx69: "f9ikmtg",
      a9b677: "f16dn6v3",
      B2eet1l: "f1w2irj7",
      B5pe6w7: "fab5kbq",
      p4uzdd: "f1ms1d91"
    },
    large: {
      Bubjx69: "f9ikmtg",
      a9b677: "f64fuq3",
      B5pe6w7: "f1vfi1yj",
      p4uzdd: "f15s34gz"
    },
    extraLarge: {
      Bubjx69: "f9ikmtg",
      a9b677: "f1w9dchk",
      B5pe6w7: "f14efy9b",
      p4uzdd: "fhipgdu"
    }
  }, {
    d: [".fvi85wt{color:var(--colorPaletteRedBackground3);}", ".f14k8a89{color:var(--colorPaletteMarigoldBackground3);}", ".fqa5hgp{color:var(--colorPaletteLightGreenForeground3);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".fdce8r3{color:var(--colorPaletteBerryForeground3);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f9ikmtg{aspect-ratio:1;}", ".f16dn6v3{width:6px;}", ".f1w2irj7{background-clip:unset;}", ".fab5kbq svg{width:6px!important;}", ".f1ms1d91 svg{height:6px!important;}", ".f64fuq3{width:20px;}", ".f1vfi1yj svg{width:20px!important;}", ".f15s34gz svg{height:20px!important;}", ".f1w9dchk{width:28px;}", ".f14efy9b svg{width:28px!important;}", ".fhipgdu svg{height:28px!important;}"]
  });
  var usePresenceBadgeStyles_unstable = (state) => {
    "use no memo";
    const rootClassName = useRootClassName2();
    const iconClassName = useIconClassName();
    const styles2 = useStyles2();
    const isBusy = getIsBusy(state.status);
    state.root.className = mergeClasses(presenceBadgeClassNames.root, rootClassName, isBusy && styles2.statusBusy, state.status === "away" && styles2.statusAway, state.status === "available" && styles2.statusAvailable, state.status === "offline" && styles2.statusOffline, state.status === "out-of-office" && styles2.statusOutOfOffice, state.status === "unknown" && styles2.statusUnknown, state.outOfOffice && styles2.outOfOffice, state.outOfOffice && state.status === "available" && styles2.outOfOfficeAvailable, state.outOfOffice && isBusy && styles2.outOfOfficeBusy, state.outOfOffice && (state.status === "out-of-office" || state.status === "away" || state.status === "offline") && styles2.statusOutOfOffice, state.outOfOffice && state.status === "unknown" && styles2.outOfOfficeUnknown, state.size === "tiny" && styles2.tiny, state.size === "large" && styles2.large, state.size === "extra-large" && styles2.extraLarge, state.root.className);
    if (state.icon) {
      state.icon.className = mergeClasses(presenceBadgeClassNames.icon, iconClassName, state.icon.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
  var PresenceBadge = /* @__PURE__ */ React75.forwardRef((props, ref) => {
    const state = usePresenceBadge_unstable(props, ref);
    usePresenceBadgeStyles_unstable(state);
    useCustomStyleHook("usePresenceBadgeStyles_unstable")(state);
    return renderBadge_unstable(state);
  });
  PresenceBadge.displayName = "PresenceBadge";

  // ../../node_modules/@fluentui/react-avatar/lib/contexts/AvatarContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React76 = __toESM(require_react());
  var avatarContext = React76.createContext(void 0);
  var avatarContextDefaultValue = {};
  var AvatarContextProvider = avatarContext.Provider;
  var useAvatarContext = () => {
    var _React_useContext;
    return (_React_useContext = React76.useContext(avatarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : avatarContextDefaultValue;
  };

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
  var DEFAULT_STRINGS2 = {
    active: "active",
    inactive: "inactive"
  };
  var useAvatar_unstable = (props, ref) => {
    const { dir } = useFluent();
    const { shape: contextShape, size: contextSize } = useAvatarContext();
    const { name, size = contextSize !== null && contextSize !== void 0 ? contextSize : 32, shape = contextShape !== null && contextShape !== void 0 ? contextShape : "circular", active = "unset", activeAppearance = "ring", idForColor } = props;
    let { color = "neutral" } = props;
    if (color === "colorful") {
      var _ref;
      color = avatarColors[getHashCode((_ref = idForColor !== null && idForColor !== void 0 ? idForColor : name) !== null && _ref !== void 0 ? _ref : "") % avatarColors.length];
    }
    const baseId = useId4("avatar-");
    const root = slot_exports.always(getIntrinsicElementProps(
      "span",
      {
        role: "img",
        id: baseId,
        // aria-label and/or aria-labelledby are resolved below
        ...props,
        ref
      },
      /* excludedPropNames: */
      [
        "name"
      ]
    ), {
      elementType: "span"
    });
    const [imageHidden, setImageHidden] = React77.useState(void 0);
    let image = slot_exports.optional(props.image, {
      defaultProps: {
        alt: "",
        role: "presentation",
        "aria-hidden": true,
        hidden: imageHidden
      },
      elementType: "img"
    });
    if (!(image === null || image === void 0 ? void 0 : image.src)) {
      image = void 0;
    }
    if (image) {
      image.onError = mergeCallbacks(image.onError, () => setImageHidden(true));
      image.onLoad = mergeCallbacks(image.onLoad, () => setImageHidden(void 0));
    }
    let initials = slot_exports.optional(props.initials, {
      renderByDefault: true,
      defaultProps: {
        children: getInitials(name, dir === "rtl", {
          firstInitialOnly: size <= 16
        }),
        id: baseId + "__initials"
      },
      elementType: "span"
    });
    if (!(initials === null || initials === void 0 ? void 0 : initials.children)) {
      initials = void 0;
    }
    let icon = void 0;
    if (!initials && (!image || imageHidden)) {
      icon = slot_exports.optional(props.icon, {
        renderByDefault: true,
        defaultProps: {
          children: /* @__PURE__ */ React77.createElement(PersonRegular, null),
          "aria-hidden": true
        },
        elementType: "span"
      });
    }
    const badge = slot_exports.optional(props.badge, {
      defaultProps: {
        size: getBadgeSize(size),
        id: baseId + "__badge"
      },
      elementType: PresenceBadge
    });
    let activeAriaLabelElement;
    if (!root["aria-label"] && !root["aria-labelledby"]) {
      if (name) {
        root["aria-label"] = name;
        if (badge) {
          root["aria-labelledby"] = root.id + " " + badge.id;
        }
      } else if (initials) {
        root["aria-labelledby"] = initials.id + (badge ? " " + badge.id : "");
      }
      if (active === "active" || active === "inactive") {
        const activeText = DEFAULT_STRINGS2[active];
        if (root["aria-labelledby"]) {
          const activeId = baseId + "__active";
          root["aria-labelledby"] += " " + activeId;
          activeAriaLabelElement = /* @__PURE__ */ React77.createElement("span", {
            hidden: true,
            id: activeId
          }, activeText);
        } else if (root["aria-label"]) {
          root["aria-label"] += " " + activeText;
        }
      }
    }
    return {
      size,
      shape,
      active,
      activeAppearance,
      activeAriaLabelElement,
      color,
      components: {
        root: "span",
        initials: "span",
        icon: "span",
        image: "img",
        badge: PresenceBadge
      },
      root,
      initials,
      icon,
      image,
      badge
    };
  };
  var getBadgeSize = (size) => {
    if (size >= 96) {
      return "extra-large";
    } else if (size >= 64) {
      return "large";
    } else if (size >= 56) {
      return "medium";
    } else if (size >= 40) {
      return "small";
    } else if (size >= 28) {
      return "extra-small";
    } else {
      return "tiny";
    }
  };
  var avatarColors = [
    "dark-red",
    "cranberry",
    "red",
    "pumpkin",
    "peach",
    "marigold",
    "gold",
    "brass",
    "brown",
    "forest",
    "seafoam",
    "dark-green",
    "light-teal",
    "teal",
    "steel",
    "blue",
    "royal-blue",
    "cornflower",
    "navy",
    "lavender",
    "purple",
    "grape",
    "lilac",
    "pink",
    "magenta",
    "plum",
    "beige",
    "mink",
    "platinum",
    "anchor"
  ];
  var getHashCode = (str) => {
    let hashCode = 0;
    for (let len = str.length - 1; len >= 0; len--) {
      const ch = str.charCodeAt(len);
      const shift = len % 8;
      hashCode ^= (ch << shift) + (ch >> 8 - shift);
    }
    return hashCode;
  };

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatarStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var avatarClassNames = {
    root: "fui-Avatar",
    image: "fui-Avatar__image",
    initials: "fui-Avatar__initials",
    icon: "fui-Avatar__icon",
    badge: "fui-Avatar__badge"
  };
  var useRootClassName3 = /* @__PURE__ */ __resetStyles2("r81b29z", "r1aatmv", {
    r: [".r81b29z{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r81b29z::before,.r81b29z::after{position:absolute;top:0;left:0;bottom:0;right:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r81b29z::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}", ".r1aatmv{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r1aatmv::before,.r1aatmv::after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r1aatmv::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.r81b29z::before,.r81b29z::after{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1aatmv::before,.r1aatmv::after{transition-duration:0.01ms;}}"]
  });
  var useImageClassName = /* @__PURE__ */ __resetStyles2("r136dc0n", "rjly0nl", [".r136dc0n{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}", ".rjly0nl{position:absolute;top:0;right:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}"]);
  var useIconInitialsClassName = /* @__PURE__ */ __resetStyles2("rip04v", "r31uzil", [".rip04v{position:absolute;box-sizing:border-box;top:0;left:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}", ".r31uzil{position:absolute;box-sizing:border-box;top:0;right:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}"]);
  var useStyles3 = /* @__PURE__ */ __styles2({
    textCaption2Strong: {
      Be2twd7: "f13mqy1h"
    },
    textCaption1Strong: {
      Be2twd7: "fy9rknc"
    },
    textSubtitle2: {
      Be2twd7: "fod5ikn"
    },
    textSubtitle1: {
      Be2twd7: "f1pp30po"
    },
    textTitle3: {
      Be2twd7: "f1x0m3f5"
    },
    squareSmall: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "fq9zq91"
    },
    squareMedium: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5"
    },
    squareLarge: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f1o0qvyv"
    },
    squareXLarge: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f1kijzfu"
    },
    activeOrInactive: {
      Bz10aip: "ftfx35i",
      Bmy1vo4: "fv0atk9",
      B3o57yi: "f1iry5bo",
      Bkqvd7p: "f15n41j8",
      Hwfdqs: "f1onx1g3"
    },
    ring: {
      Ftih45: "f1wl9k8s"
    },
    ringBadgeCutout: {
      f4a502: "fp2gujx"
    },
    ringThick: {
      of393c: "fq1w1vq"
    },
    ringThicker: {
      of393c: "fzg6ace"
    },
    ringThickest: {
      of393c: "f1nu8p71"
    },
    shadow: {
      Bsft5z2: "f13zj6fq"
    },
    shadow4: {
      Be6vj1x: "fcjn15l"
    },
    shadow8: {
      Be6vj1x: "f1tm8t9f"
    },
    shadow16: {
      Be6vj1x: "f1a1aohj"
    },
    shadow28: {
      Be6vj1x: "fond6v5"
    },
    inactive: {
      abs64n: "fp25eh",
      Bz10aip: "f1clczzi",
      Bkqvd7p: "f1l3s34x",
      Bfgortx: 0,
      Bnvr3x9: 0,
      b2tv09: 0,
      Bucmhp4: 0,
      iayac2: "flkahu5",
      b6ubon: "fw457kn",
      Bqinb2h: "f1wmllxl"
    },
    badge: {
      qhf8xq: "f1euv43f",
      B5kzvoi: "f1yab3r1",
      j35jbq: ["f1e31b4d", "f1vgc2s3"]
    },
    badgeCutout: {
      btxmck: "f1eugkqs"
    },
    badgeAlign: {
      Dnlfbu: ["f1tlnv9o", "f1y9kyih"]
    },
    tiny: {
      Bdjeniz: "f1uwoubl",
      niu6jh: "fid048z"
    },
    "extra-small": {
      Bdjeniz: "f13ar0e0",
      niu6jh: "fid048z"
    },
    small: {
      Bdjeniz: "fwwuruf",
      niu6jh: "fid048z"
    },
    medium: {
      Bdjeniz: "f1af27q5",
      niu6jh: "fid048z"
    },
    large: {
      Bdjeniz: "f18yy57a",
      niu6jh: "f924bxt"
    },
    "extra-large": {
      Bdjeniz: "f2jg042",
      niu6jh: "f924bxt"
    },
    icon12: {
      Be2twd7: "f1ugzwwg"
    },
    icon16: {
      Be2twd7: "f4ybsrx"
    },
    icon20: {
      Be2twd7: "fe5j1ua"
    },
    icon24: {
      Be2twd7: "f1rt2boy"
    },
    icon28: {
      Be2twd7: "f24l1pt"
    },
    icon32: {
      Be2twd7: "ffl51b"
    },
    icon48: {
      Be2twd7: "f18m8u13"
    }
  }, {
    d: [".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], [".f1o0qvyv{border-radius:var(--borderRadiusLarge);}", {
      p: -1
    }], [".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
      p: -1
    }], ".ftfx35i{transform:perspective(1px);}", ".fv0atk9{transition-property:transform,opacity;}", ".f1iry5bo{transition-duration:var(--durationUltraSlow),var(--durationFaster);}", ".f15n41j8{transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);}", '.f1wl9k8s::before{content:"";}', ".fp2gujx::before{-webkit-mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".fq1w1vq{--fui-Avatar-ringWidth:var(--strokeWidthThick);}", ".fzg6ace{--fui-Avatar-ringWidth:var(--strokeWidthThicker);}", ".f1nu8p71{--fui-Avatar-ringWidth:var(--strokeWidthThickest);}", '.f13zj6fq::after{content:"";}', ".fcjn15l::after{box-shadow:var(--shadow4);}", ".f1tm8t9f::after{box-shadow:var(--shadow8);}", ".f1a1aohj::after{box-shadow:var(--shadow16);}", ".fond6v5::after{box-shadow:var(--shadow28);}", ".fp25eh{opacity:0.8;}", ".f1clczzi{transform:scale(0.875);}", ".f1l3s34x{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", [".flkahu5::before,.flkahu5::after{margin:0;}", {
      p: -1
    }], ".fw457kn::before,.fw457kn::after{opacity:0;}", ".f1wmllxl::before,.f1wmllxl::after{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", ".f1euv43f{position:absolute;}", ".f1yab3r1{bottom:0;}", ".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f1eugkqs{-webkit-mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".f1tlnv9o{--fui-Avatar-badgeAlign:right;}", ".f1y9kyih{--fui-Avatar-badgeAlign:left;}", ".f1uwoubl{--fui-Avatar-badgeRadius:3px;}", ".fid048z{--fui-Avatar-badgeGap:var(--strokeWidthThin);}", ".f13ar0e0{--fui-Avatar-badgeRadius:5px;}", ".fwwuruf{--fui-Avatar-badgeRadius:6px;}", ".f1af27q5{--fui-Avatar-badgeRadius:8px;}", ".f18yy57a{--fui-Avatar-badgeRadius:10px;}", ".f924bxt{--fui-Avatar-badgeGap:var(--strokeWidthThick);}", ".f2jg042{--fui-Avatar-badgeRadius:14px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f24l1pt{font-size:28px;}", ".ffl51b{font-size:32px;}", ".f18m8u13{font-size:48px;}"],
    m: [["@media screen and (prefers-reduced-motion: reduce){.f1onx1g3{transition-duration:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }]]
  });
  var useSizeStyles = /* @__PURE__ */ __styles2({
    "16": {
      a9b677: "fjw5fx7",
      Bqenvij: "fd461yt"
    },
    "20": {
      a9b677: "f64fuq3",
      Bqenvij: "fjamq6b"
    },
    "24": {
      a9b677: "fq4mcun",
      Bqenvij: "frvgh55"
    },
    "28": {
      a9b677: "f1w9dchk",
      Bqenvij: "fxldao9"
    },
    "32": {
      a9b677: "f1szoe96",
      Bqenvij: "f1d2rq10"
    },
    "36": {
      a9b677: "fpdz1er",
      Bqenvij: "f8ljn23"
    },
    "40": {
      a9b677: "feqmc2u",
      Bqenvij: "fbhnoac"
    },
    "48": {
      a9b677: "f124akge",
      Bqenvij: "ff2sm71"
    },
    "56": {
      a9b677: "f1u66zr1",
      Bqenvij: "fzki0ko"
    },
    "64": {
      a9b677: "fa9ln6p",
      Bqenvij: "f16k9i2m"
    },
    "72": {
      a9b677: "fhcae8x",
      Bqenvij: "f1shusfg"
    },
    "96": {
      a9b677: "f1kyr2gn",
      Bqenvij: "fypu0ge"
    },
    "120": {
      a9b677: "fwfqyga",
      Bqenvij: "fjr5b71"
    },
    "128": {
      a9b677: "f1iksgmy",
      Bqenvij: "fele2au"
    }
  }, {
    d: [".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}", ".fpdz1er{width:36px;}", ".f8ljn23{height:36px;}", ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", ".f124akge{width:48px;}", ".ff2sm71{height:48px;}", ".f1u66zr1{width:56px;}", ".fzki0ko{height:56px;}", ".fa9ln6p{width:64px;}", ".f16k9i2m{height:64px;}", ".fhcae8x{width:72px;}", ".f1shusfg{height:72px;}", ".f1kyr2gn{width:96px;}", ".fypu0ge{height:96px;}", ".fwfqyga{width:120px;}", ".fjr5b71{height:120px;}", ".f1iksgmy{width:128px;}", ".fele2au{height:128px;}"]
  });
  var useColorStyles = /* @__PURE__ */ __styles2({
    neutral: {
      sj55zd: "f11d4kpn",
      De3pzq: "f18f03hv"
    },
    brand: {
      sj55zd: "fonrgv7",
      De3pzq: "f1blnnmj"
    },
    "dark-red": {
      sj55zd: "fqjd1y1",
      De3pzq: "f1vq2oo4"
    },
    cranberry: {
      sj55zd: "fg9gses",
      De3pzq: "f1lwxszt"
    },
    red: {
      sj55zd: "f23f7i0",
      De3pzq: "f1q9qhfq"
    },
    pumpkin: {
      sj55zd: "fjnan08",
      De3pzq: "fz91bi3"
    },
    peach: {
      sj55zd: "fknu15p",
      De3pzq: "f1b9nr51"
    },
    marigold: {
      sj55zd: "f9603vw",
      De3pzq: "f3z4w6d"
    },
    gold: {
      sj55zd: "fmq0uwp",
      De3pzq: "fg50kya"
    },
    brass: {
      sj55zd: "f28g5vo",
      De3pzq: "f4w2gd0"
    },
    brown: {
      sj55zd: "ftl572b",
      De3pzq: "f14wu1f4"
    },
    forest: {
      sj55zd: "f1gymlvd",
      De3pzq: "f19ut4y6"
    },
    seafoam: {
      sj55zd: "fnnb6wn",
      De3pzq: "f1n057jc"
    },
    "dark-green": {
      sj55zd: "ff58qw8",
      De3pzq: "f11t05wk"
    },
    "light-teal": {
      sj55zd: "f1up9qbj",
      De3pzq: "f42feg1"
    },
    teal: {
      sj55zd: "f135dsb4",
      De3pzq: "f6hvv1p"
    },
    steel: {
      sj55zd: "f151dlcp",
      De3pzq: "f1lnp8zf"
    },
    blue: {
      sj55zd: "f1rjv50u",
      De3pzq: "f1ggcpy6"
    },
    "royal-blue": {
      sj55zd: "f1emykk5",
      De3pzq: "f12rj61f"
    },
    cornflower: {
      sj55zd: "fqsigj7",
      De3pzq: "f8k7hur"
    },
    navy: {
      sj55zd: "f1nj97xi",
      De3pzq: "f19gw0ux"
    },
    lavender: {
      sj55zd: "fwctg0i",
      De3pzq: "ff379vm"
    },
    purple: {
      sj55zd: "fjrsgpu",
      De3pzq: "f1mzf1e1"
    },
    grape: {
      sj55zd: "f1fiiydq",
      De3pzq: "f1o4k8oy"
    },
    lilac: {
      sj55zd: "f1res9jt",
      De3pzq: "f1x6mz1o"
    },
    pink: {
      sj55zd: "fv3fbbi",
      De3pzq: "fydlv6t"
    },
    magenta: {
      sj55zd: "f1f1fwnz",
      De3pzq: "f4xb6j5"
    },
    plum: {
      sj55zd: "f8ptl6j",
      De3pzq: "fqo8e26"
    },
    beige: {
      sj55zd: "f1ntv3ld",
      De3pzq: "f101elhj"
    },
    mink: {
      sj55zd: "f1fscmp",
      De3pzq: "f13g8o5c"
    },
    platinum: {
      sj55zd: "f1dr00v2",
      De3pzq: "fkh7blw"
    },
    anchor: {
      sj55zd: "f1f3ti53",
      De3pzq: "fu4yj0j"
    }
  }, {
    d: [".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f18f03hv{background-color:var(--colorNeutralBackground6);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1blnnmj{background-color:var(--colorBrandBackgroundStatic);}", ".fqjd1y1{color:var(--colorPaletteDarkRedForeground2);}", ".f1vq2oo4{background-color:var(--colorPaletteDarkRedBackground2);}", ".fg9gses{color:var(--colorPaletteCranberryForeground2);}", ".f1lwxszt{background-color:var(--colorPaletteCranberryBackground2);}", ".f23f7i0{color:var(--colorPaletteRedForeground2);}", ".f1q9qhfq{background-color:var(--colorPaletteRedBackground2);}", ".fjnan08{color:var(--colorPalettePumpkinForeground2);}", ".fz91bi3{background-color:var(--colorPalettePumpkinBackground2);}", ".fknu15p{color:var(--colorPalettePeachForeground2);}", ".f1b9nr51{background-color:var(--colorPalettePeachBackground2);}", ".f9603vw{color:var(--colorPaletteMarigoldForeground2);}", ".f3z4w6d{background-color:var(--colorPaletteMarigoldBackground2);}", ".fmq0uwp{color:var(--colorPaletteGoldForeground2);}", ".fg50kya{background-color:var(--colorPaletteGoldBackground2);}", ".f28g5vo{color:var(--colorPaletteBrassForeground2);}", ".f4w2gd0{background-color:var(--colorPaletteBrassBackground2);}", ".ftl572b{color:var(--colorPaletteBrownForeground2);}", ".f14wu1f4{background-color:var(--colorPaletteBrownBackground2);}", ".f1gymlvd{color:var(--colorPaletteForestForeground2);}", ".f19ut4y6{background-color:var(--colorPaletteForestBackground2);}", ".fnnb6wn{color:var(--colorPaletteSeafoamForeground2);}", ".f1n057jc{background-color:var(--colorPaletteSeafoamBackground2);}", ".ff58qw8{color:var(--colorPaletteDarkGreenForeground2);}", ".f11t05wk{background-color:var(--colorPaletteDarkGreenBackground2);}", ".f1up9qbj{color:var(--colorPaletteLightTealForeground2);}", ".f42feg1{background-color:var(--colorPaletteLightTealBackground2);}", ".f135dsb4{color:var(--colorPaletteTealForeground2);}", ".f6hvv1p{background-color:var(--colorPaletteTealBackground2);}", ".f151dlcp{color:var(--colorPaletteSteelForeground2);}", ".f1lnp8zf{background-color:var(--colorPaletteSteelBackground2);}", ".f1rjv50u{color:var(--colorPaletteBlueForeground2);}", ".f1ggcpy6{background-color:var(--colorPaletteBlueBackground2);}", ".f1emykk5{color:var(--colorPaletteRoyalBlueForeground2);}", ".f12rj61f{background-color:var(--colorPaletteRoyalBlueBackground2);}", ".fqsigj7{color:var(--colorPaletteCornflowerForeground2);}", ".f8k7hur{background-color:var(--colorPaletteCornflowerBackground2);}", ".f1nj97xi{color:var(--colorPaletteNavyForeground2);}", ".f19gw0ux{background-color:var(--colorPaletteNavyBackground2);}", ".fwctg0i{color:var(--colorPaletteLavenderForeground2);}", ".ff379vm{background-color:var(--colorPaletteLavenderBackground2);}", ".fjrsgpu{color:var(--colorPalettePurpleForeground2);}", ".f1mzf1e1{background-color:var(--colorPalettePurpleBackground2);}", ".f1fiiydq{color:var(--colorPaletteGrapeForeground2);}", ".f1o4k8oy{background-color:var(--colorPaletteGrapeBackground2);}", ".f1res9jt{color:var(--colorPaletteLilacForeground2);}", ".f1x6mz1o{background-color:var(--colorPaletteLilacBackground2);}", ".fv3fbbi{color:var(--colorPalettePinkForeground2);}", ".fydlv6t{background-color:var(--colorPalettePinkBackground2);}", ".f1f1fwnz{color:var(--colorPaletteMagentaForeground2);}", ".f4xb6j5{background-color:var(--colorPaletteMagentaBackground2);}", ".f8ptl6j{color:var(--colorPalettePlumForeground2);}", ".fqo8e26{background-color:var(--colorPalettePlumBackground2);}", ".f1ntv3ld{color:var(--colorPaletteBeigeForeground2);}", ".f101elhj{background-color:var(--colorPaletteBeigeBackground2);}", ".f1fscmp{color:var(--colorPaletteMinkForeground2);}", ".f13g8o5c{background-color:var(--colorPaletteMinkBackground2);}", ".f1dr00v2{color:var(--colorPalettePlatinumForeground2);}", ".fkh7blw{background-color:var(--colorPalettePlatinumBackground2);}", ".f1f3ti53{color:var(--colorPaletteAnchorForeground2);}", ".fu4yj0j{background-color:var(--colorPaletteAnchorBackground2);}"]
  });
  var useRingColorStyles = /* @__PURE__ */ __styles2({
    neutral: {
      Bic5iru: "f1uuiafn"
    },
    brand: {
      Bic5iru: "f1uuiafn"
    },
    "dark-red": {
      Bic5iru: "f1t2x9on"
    },
    cranberry: {
      Bic5iru: "f1pvshc9"
    },
    red: {
      Bic5iru: "f1ectbk9"
    },
    pumpkin: {
      Bic5iru: "fvzpl0b"
    },
    peach: {
      Bic5iru: "fwj2kd7"
    },
    marigold: {
      Bic5iru: "fr120vy"
    },
    gold: {
      Bic5iru: "f8xmmar"
    },
    brass: {
      Bic5iru: "f1hbety2"
    },
    brown: {
      Bic5iru: "f1vg3s4g"
    },
    forest: {
      Bic5iru: "f1m3olm5"
    },
    seafoam: {
      Bic5iru: "f17xiqtr"
    },
    "dark-green": {
      Bic5iru: "fx32vyh"
    },
    "light-teal": {
      Bic5iru: "f1mkihwv"
    },
    teal: {
      Bic5iru: "fecnooh"
    },
    steel: {
      Bic5iru: "f15hfgzm"
    },
    blue: {
      Bic5iru: "fqproka"
    },
    "royal-blue": {
      Bic5iru: "f17v2w59"
    },
    cornflower: {
      Bic5iru: "fp0q1mo"
    },
    navy: {
      Bic5iru: "f1nlym55"
    },
    lavender: {
      Bic5iru: "f62vk8h"
    },
    purple: {
      Bic5iru: "f15zl69q"
    },
    grape: {
      Bic5iru: "f53w4j7"
    },
    lilac: {
      Bic5iru: "fu2771t"
    },
    pink: {
      Bic5iru: "fzflscs"
    },
    magenta: {
      Bic5iru: "fb6rmqc"
    },
    plum: {
      Bic5iru: "f1a4gm5b"
    },
    beige: {
      Bic5iru: "f1qpf9z1"
    },
    mink: {
      Bic5iru: "f1l7or83"
    },
    platinum: {
      Bic5iru: "fzrj0iu"
    },
    anchor: {
      Bic5iru: "f8oz6wf"
    }
  }, {
    d: [".f1uuiafn::before{color:var(--colorBrandStroke1);}", ".f1t2x9on::before{color:var(--colorPaletteDarkRedBorderActive);}", ".f1pvshc9::before{color:var(--colorPaletteCranberryBorderActive);}", ".f1ectbk9::before{color:var(--colorPaletteRedBorderActive);}", ".fvzpl0b::before{color:var(--colorPalettePumpkinBorderActive);}", ".fwj2kd7::before{color:var(--colorPalettePeachBorderActive);}", ".fr120vy::before{color:var(--colorPaletteMarigoldBorderActive);}", ".f8xmmar::before{color:var(--colorPaletteGoldBorderActive);}", ".f1hbety2::before{color:var(--colorPaletteBrassBorderActive);}", ".f1vg3s4g::before{color:var(--colorPaletteBrownBorderActive);}", ".f1m3olm5::before{color:var(--colorPaletteForestBorderActive);}", ".f17xiqtr::before{color:var(--colorPaletteSeafoamBorderActive);}", ".fx32vyh::before{color:var(--colorPaletteDarkGreenBorderActive);}", ".f1mkihwv::before{color:var(--colorPaletteLightTealBorderActive);}", ".fecnooh::before{color:var(--colorPaletteTealBorderActive);}", ".f15hfgzm::before{color:var(--colorPaletteSteelBorderActive);}", ".fqproka::before{color:var(--colorPaletteBlueBorderActive);}", ".f17v2w59::before{color:var(--colorPaletteRoyalBlueBorderActive);}", ".fp0q1mo::before{color:var(--colorPaletteCornflowerBorderActive);}", ".f1nlym55::before{color:var(--colorPaletteNavyBorderActive);}", ".f62vk8h::before{color:var(--colorPaletteLavenderBorderActive);}", ".f15zl69q::before{color:var(--colorPalettePurpleBorderActive);}", ".f53w4j7::before{color:var(--colorPaletteGrapeBorderActive);}", ".fu2771t::before{color:var(--colorPaletteLilacBorderActive);}", ".fzflscs::before{color:var(--colorPalettePinkBorderActive);}", ".fb6rmqc::before{color:var(--colorPaletteMagentaBorderActive);}", ".f1a4gm5b::before{color:var(--colorPalettePlumBorderActive);}", ".f1qpf9z1::before{color:var(--colorPaletteBeigeBorderActive);}", ".f1l7or83::before{color:var(--colorPaletteMinkBorderActive);}", ".fzrj0iu::before{color:var(--colorPalettePlatinumBorderActive);}", ".f8oz6wf::before{color:var(--colorPaletteAnchorBorderActive);}"]
  });
  var useAvatarStyles_unstable = (state) => {
    "use no memo";
    const {
      size,
      shape,
      active,
      activeAppearance,
      color
    } = state;
    const rootClassName = useRootClassName3();
    const imageClassName = useImageClassName();
    const iconInitialsClassName = useIconInitialsClassName();
    const styles2 = useStyles3();
    const sizeStyles = useSizeStyles();
    const colorStyles = useColorStyles();
    const ringColorStyles = useRingColorStyles();
    const rootClasses = [rootClassName, size !== 32 && sizeStyles[size]];
    if (state.badge) {
      rootClasses.push(styles2.badgeAlign, styles2[state.badge.size || "medium"]);
    }
    if (size <= 24) {
      rootClasses.push(styles2.textCaption2Strong);
    } else if (size <= 28) {
      rootClasses.push(styles2.textCaption1Strong);
    } else if (size <= 40) {
    } else if (size <= 56) {
      rootClasses.push(styles2.textSubtitle2);
    } else if (size <= 96) {
      rootClasses.push(styles2.textSubtitle1);
    } else {
      rootClasses.push(styles2.textTitle3);
    }
    if (shape === "square") {
      if (size <= 24) {
        rootClasses.push(styles2.squareSmall);
      } else if (size <= 48) {
        rootClasses.push(styles2.squareMedium);
      } else if (size <= 72) {
        rootClasses.push(styles2.squareLarge);
      } else {
        rootClasses.push(styles2.squareXLarge);
      }
    }
    if (active === "active" || active === "inactive") {
      rootClasses.push(styles2.activeOrInactive);
      if (activeAppearance === "ring" || activeAppearance === "ring-shadow") {
        rootClasses.push(styles2.ring, ringColorStyles[color]);
        if (state.badge) {
          rootClasses.push(styles2.ringBadgeCutout);
        }
        if (size <= 48) {
          rootClasses.push(styles2.ringThick);
        } else if (size <= 64) {
          rootClasses.push(styles2.ringThicker);
        } else {
          rootClasses.push(styles2.ringThickest);
        }
      }
      if (activeAppearance === "shadow" || activeAppearance === "ring-shadow") {
        rootClasses.push(styles2.shadow);
        if (size <= 28) {
          rootClasses.push(styles2.shadow4);
        } else if (size <= 48) {
          rootClasses.push(styles2.shadow8);
        } else if (size <= 64) {
          rootClasses.push(styles2.shadow16);
        } else {
          rootClasses.push(styles2.shadow28);
        }
      }
      if (active === "inactive") {
        rootClasses.push(styles2.inactive);
      }
    }
    state.root.className = mergeClasses(avatarClassNames.root, ...rootClasses, state.root.className);
    if (state.badge) {
      state.badge.className = mergeClasses(avatarClassNames.badge, styles2.badge, state.badge.className);
    }
    if (state.image) {
      state.image.className = mergeClasses(avatarClassNames.image, imageClassName, colorStyles[color], state.badge && styles2.badgeCutout, state.image.className);
    }
    if (state.initials) {
      state.initials.className = mergeClasses(avatarClassNames.initials, iconInitialsClassName, colorStyles[color], state.badge && styles2.badgeCutout, state.initials.className);
    }
    if (state.icon) {
      let iconSizeClass;
      if (size <= 16) {
        iconSizeClass = styles2.icon12;
      } else if (size <= 24) {
        iconSizeClass = styles2.icon16;
      } else if (size <= 40) {
        iconSizeClass = styles2.icon20;
      } else if (size <= 48) {
        iconSizeClass = styles2.icon24;
      } else if (size <= 56) {
        iconSizeClass = styles2.icon28;
      } else if (size <= 72) {
        iconSizeClass = styles2.icon32;
      } else {
        iconSizeClass = styles2.icon48;
      }
      state.icon.className = mergeClasses(avatarClassNames.icon, iconInitialsClassName, iconSizeClass, colorStyles[color], state.badge && styles2.badgeCutout, state.icon.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
  var Avatar = /* @__PURE__ */ React78.forwardRef((props, ref) => {
    const state = useAvatar_unstable(props, ref);
    useAvatarStyles_unstable(state);
    useCustomStyleHook("useAvatarStyles_unstable")(state);
    return renderAvatar_unstable(state);
  });
  Avatar.displayName = "Avatar";

  // ../../node_modules/@fluentui/react-portal/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React82 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React80 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-portal/lib/utils/toMountNodeProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function toMountNodeProps(mountNode) {
    if (isHTMLElement(mountNode)) {
      return {
        element: mountNode
      };
    }
    if (typeof mountNode === "object") {
      if (mountNode === null) {
        return {
          element: null
        };
      }
      return mountNode;
    }
    return {};
  }

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React79 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNodeStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var usePortalMountNodeStylesStyles = /* @__PURE__ */ __styles2({
    root: {
      qhf8xq: "f1euv43f",
      Bhzewxz: "f15twtuk",
      oyh7mz: ["f1vgc2s3", "f1e31b4d"],
      j35jbq: ["f1e31b4d", "f1vgc2s3"],
      Bj3rh1h: "f494woh"
    }
  }, {
    d: [".f1euv43f{position:absolute;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".f494woh{z-index:1000000;}"]
  });

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
  var useInsertionEffect6 = React79["useInsertionEffect"];
  var useLegacyElementFactory = (options) => {
    const { className, dir, focusVisibleRef, targetNode } = options;
    const targetElement = React79.useMemo(() => {
      if (targetNode === void 0 || options.disabled) {
        return null;
      }
      const element = targetNode.ownerDocument.createElement("div");
      targetNode.appendChild(element);
      return element;
    }, [
      targetNode,
      options.disabled
    ]);
    React79.useMemo(() => {
      if (!targetElement) {
        return;
      }
      targetElement.className = className;
      targetElement.setAttribute("dir", dir);
      targetElement.setAttribute("data-portal-node", "true");
      focusVisibleRef.current = targetElement;
    }, [
      className,
      dir,
      targetElement,
      focusVisibleRef
    ]);
    React79.useEffect(() => {
      return () => {
        targetElement === null || targetElement === void 0 ? void 0 : targetElement.remove();
      };
    }, [
      targetElement
    ]);
    return targetElement;
  };
  var useModernElementFactory = (options) => {
    const { className, dir, focusVisibleRef, targetNode } = options;
    const [elementFactory] = React79.useState(() => {
      let currentElement = void 0;
      function get(targetRoot, forceCreation) {
        if (currentElement) {
          return currentElement;
        }
        if (forceCreation) {
          currentElement = targetRoot.ownerDocument.createElement("div");
          targetRoot.appendChild(currentElement);
        }
        return currentElement;
      }
      function dispose() {
        if (currentElement) {
          currentElement.remove();
          currentElement = void 0;
        }
      }
      return {
        get,
        dispose
      };
    });
    const elementProxy = React79.useMemo(() => {
      if (targetNode === void 0 || options.disabled) {
        return null;
      }
      return new Proxy({}, {
        get(_, property) {
          if (property === "remove") {
            const targetElement2 = elementFactory.get(targetNode, false);
            if (targetElement2) {
              const portalHasNoChildren = targetElement2.childNodes.length === 0;
              if (portalHasNoChildren) {
                return targetElement2.remove.bind(targetElement2);
              }
            }
            return () => {
            };
          }
          const targetElement = elementFactory.get(targetNode, true);
          const targetProperty = targetElement[property];
          if (typeof targetProperty === "function") {
            return targetProperty.bind(targetElement);
          }
          return targetProperty;
        },
        set(_, property, value) {
          const targetElement = elementFactory.get(targetNode, true);
          if (targetElement) {
            Object.assign(targetElement, {
              [property]: value
            });
            return true;
          }
          return false;
        }
      });
    }, [
      elementFactory,
      targetNode,
      options.disabled
    ]);
    React79.useEffect(() => {
      return () => {
        elementProxy === null || elementProxy === void 0 ? void 0 : elementProxy.remove();
      };
    }, [
      elementProxy
    ]);
    useInsertionEffect6(() => {
      if (!elementProxy) {
        return;
      }
      const classesToApply = className.split(" ").filter(Boolean);
      elementProxy.classList.add(...classesToApply);
      elementProxy.setAttribute("dir", dir);
      elementProxy.setAttribute("data-portal-node", "true");
      focusVisibleRef.current = elementProxy;
      return () => {
        elementProxy.classList.remove(...classesToApply);
        elementProxy.removeAttribute("dir");
      };
    }, [
      className,
      dir,
      elementProxy,
      focusVisibleRef
    ]);
    return elementProxy;
  };
  var usePortalMountNode2 = (options) => {
    "use no memo";
    const { targetDocument, dir } = useFluent();
    const mountNode = usePortalMountNode();
    const focusVisibleRef = useFocusVisible();
    const classes = usePortalMountNodeStylesStyles();
    const themeClassName = useThemeClassName();
    const factoryOptions = {
      dir,
      disabled: options.disabled,
      focusVisibleRef,
      className: mergeClasses(themeClassName, classes.root, options.className),
      targetNode: mountNode !== null && mountNode !== void 0 ? mountNode : targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body
    };
    if (useInsertionEffect6) {
      return useModernElementFactory(factoryOptions);
    }
    return useLegacyElementFactory(factoryOptions);
  };

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
  var usePortal_unstable = (props) => {
    const { element, className } = toMountNodeProps(props.mountNode);
    const virtualParentRootRef = React80.useRef(null);
    const fallbackElement = usePortalMountNode2({
      disabled: !!element,
      className
    });
    const mountNode = element !== null && element !== void 0 ? element : fallbackElement;
    const state = {
      children: props.children,
      mountNode,
      virtualParentRootRef
    };
    React80.useEffect(() => {
      if (!mountNode) {
        return;
      }
      const virtualParent = virtualParentRootRef.current;
      const isVirtualParentInsideChild = mountNode.contains(virtualParent);
      if (virtualParent && !isVirtualParentInsideChild) {
        setVirtualParent(mountNode, virtualParent);
        return () => {
          setVirtualParent(mountNode, void 0);
        };
      }
    }, [
      mountNode
    ]);
    return state;
  };

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/renderPortal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var ReactDOM = __toESM(require_react_dom());
  var React81 = __toESM(require_react());
  var renderPortal_unstable = (state) => {
    return /* @__PURE__ */ React81.createElement("span", {
      hidden: true,
      ref: state.virtualParentRootRef
    }, state.mountNode && /* @__PURE__ */ ReactDOM.createPortal(state.children, state.mountNode));
  };

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
  var Portal = (props) => {
    const state = usePortal_unstable(props);
    return renderPortal_unstable(state);
  };
  Portal.displayName = "Portal";

  // ../../node_modules/@fluentui/react-button/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-button/lib/Button.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-button/lib/components/Button/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-button/lib/components/Button/Button.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React85 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-button/lib/components/Button/renderButton.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderButton_unstable = (state) => {
    assertSlots(state);
    const { iconOnly, iconPosition } = state;
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        iconPosition !== "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {}),
        !iconOnly && state.root.children,
        iconPosition === "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-button/lib/components/Button/useButton.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React84 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-button/lib/contexts/ButtonContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React83 = __toESM(require_react());
  var buttonContext = React83.createContext(void 0);
  var buttonContextDefaultValue = {};
  var ButtonContextProvider = buttonContext.Provider;
  var useButtonContext = () => {
    var _React_useContext;
    return (_React_useContext = React83.useContext(buttonContext)) !== null && _React_useContext !== void 0 ? _React_useContext : buttonContextDefaultValue;
  };

  // ../../node_modules/@fluentui/react-button/lib/components/Button/useButton.js
  var useButton_unstable = (props, ref) => {
    const { size: contextSize } = useButtonContext();
    const { appearance = "secondary", as = "button", disabled = false, disabledFocusable = false, icon, iconPosition = "before", shape = "rounded", size = contextSize !== null && contextSize !== void 0 ? contextSize : "medium" } = props;
    const iconShorthand = slot_exports.optional(icon, {
      elementType: "span"
    });
    return {
      // Props passed at the top-level
      appearance,
      disabled,
      disabledFocusable,
      iconPosition,
      shape,
      size,
      iconOnly: Boolean((iconShorthand === null || iconShorthand === void 0 ? void 0 : iconShorthand.children) && !props.children),
      components: {
        root: "button",
        icon: "span"
      },
      root: slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
        elementType: "button",
        defaultProps: {
          ref,
          type: as === "button" ? "button" : void 0
        }
      }),
      icon: iconShorthand
    };
  };

  // ../../node_modules/@fluentui/react-button/lib/components/Button/useButtonStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var buttonClassNames = {
    root: "fui-Button",
    icon: "fui-Button__icon"
  };
  var boxShadowStrokeWidthThinMoz = `calc(${tokens.strokeWidthThin} + 0.25px)`;
  var useRootBaseClassName = /* @__PURE__ */ __resetStyles2("r1alrhcs", null, {
    r: [".r1alrhcs{align-items:center;box-sizing:border-box;display:inline-flex;justify-content:center;text-decoration-line:none;vertical-align:middle;margin:0;overflow:hidden;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);font-family:var(--fontFamilyBase);outline-style:none;padding:5px var(--spacingHorizontalM);min-width:96px;border-radius:var(--borderRadiusMedium);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase300);transition-duration:var(--durationFaster);transition-property:background,border,color;transition-timing-function:var(--curveEasyEase);}", ".r1alrhcs:hover{background-color:var(--colorNeutralBackground1Hover);border-color:var(--colorNeutralStroke1Hover);color:var(--colorNeutralForeground1Hover);cursor:pointer;}", ".r1alrhcs:hover:active{background-color:var(--colorNeutralBackground1Pressed);border-color:var(--colorNeutralStroke1Pressed);color:var(--colorNeutralForeground1Pressed);outline-style:none;}", ".r1alrhcs[data-fui-focus-visible]{border-color:var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);border-width:1px;outline:var(--strokeWidthThick) solid var(--colorTransparentStroke);box-shadow:0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;z-index:1;}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.r1alrhcs{transition-duration:0.01ms;}}", "@media (forced-colors: active){.r1alrhcs:focus{border-color:ButtonText;}.r1alrhcs:hover{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}.r1alrhcs:hover:active{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}}", "@supports (-moz-appearance:button){.r1alrhcs[data-fui-focus-visible]{box-shadow:0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
  });
  var useIconBaseClassName = /* @__PURE__ */ __resetStyles2("rywnvv2", null, [".rywnvv2{align-items:center;display:inline-flex;justify-content:center;font-size:20px;height:20px;width:20px;--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}"]);
  var useRootStyles3 = /* @__PURE__ */ __styles2({
    outline: {
      De3pzq: "f1c21dwh",
      Jwef8y: "fjxutwb",
      iro3zm: "fwiml72"
    },
    primary: {
      De3pzq: "ffp7eso",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      sj55zd: "f1phragk",
      Jwef8y: "f15wkkf3",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      Bi91k9c: "f1rq72xc",
      iro3zm: "fnp9lpt",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"],
      B2d53fq: "f1d6v5y2",
      Bsw6fvg: "f1rirnrt",
      Bjwas2f: "f1uu00uk",
      Bn1d65q: ["fkvaka8", "f9a0qzu"],
      Bxeuatn: "f1ux7til",
      n51gp8: ["f9a0qzu", "fkvaka8"],
      Bbusuzp: "f1lkg8j3",
      ycbfsm: "fkc42ay",
      Bqrx1nm: "fq7113v",
      pgvf35: "ff1wgvm",
      Bh7lczh: ["fiob0tu", "f1x4h75k"],
      dpv3f4: "f1j6scgf",
      Bpnjhaq: ["f1x4h75k", "fiob0tu"],
      ze5xyy: "f4xjyn1",
      g2kj27: "fbgcvur",
      Bf756sw: "f1ks1yx8",
      Bow2dr7: ["f1o6qegi", "fmxjhhp"],
      Bvhedfk: "fcnxywj",
      Gye4lf: ["fmxjhhp", "f1o6qegi"],
      pc6evw: "f9ddjv3"
    },
    secondary: {},
    subtle: {
      De3pzq: "fhovq9v",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      sj55zd: "fkfq4zb",
      Jwef8y: "f1t94bn6",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      Bi91k9c: "fnwyq0v",
      Bk3fhr4: "ft1hn21",
      Bmfj8id: "fuxngvv",
      Bbdnnc7: "fy5bs14",
      iro3zm: "fsv2rcd",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"],
      B2d53fq: "f1omzyqd",
      em6i61: "f1dfjoow",
      vm6p8p: "f1j98vj9",
      x3br3k: "fj8yq94",
      ze5xyy: "f4xjyn1",
      Bx3q9su: "f1et0tmh",
      pc6evw: "f9ddjv3",
      xd2cci: "f1wi8ngl"
    },
    transparent: {
      De3pzq: "f1c21dwh",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      sj55zd: "fkfq4zb",
      Jwef8y: "fjxutwb",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      Bi91k9c: "f139oj5f",
      Bk3fhr4: "ft1hn21",
      Bmfj8id: "fuxngvv",
      iro3zm: "fwiml72",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"],
      B2d53fq: "f1fg1p5m",
      em6i61: "f1dfjoow",
      vm6p8p: "f1j98vj9",
      Bqrx1nm: "f1tme0vf",
      ze5xyy: "f4xjyn1",
      g2kj27: "f18onu3q",
      pc6evw: "f9ddjv3"
    },
    circular: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f44lkw9"
    },
    rounded: {},
    square: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f1fabniw"
    },
    small: {
      Bf4jedk: "fh7ncta",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fneth5b",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      Be2twd7: "fy9rknc",
      Bhrd7zp: "figsok6",
      Bg96gwp: "fwrc4pm"
    },
    smallWithIcon: {
      Byoj8tv: "f1brlhvm",
      z8tnut: "f1sl3k7w"
    },
    medium: {},
    large: {
      Bf4jedk: "f14es27b",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f4db1ww",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    largeWithIcon: {
      Byoj8tv: "fy7v416",
      z8tnut: "f1a1bwwz"
    }
  }, {
    d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
      p: -1
    }], ".fh7ncta{min-width:64px;}", [".fneth5b{padding:3px var(--spacingHorizontalS);}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1brlhvm{padding-bottom:1px;}", ".f1sl3k7w{padding-top:1px;}", ".f14es27b{min-width:96px;}", [".f4db1ww{padding:8px var(--spacingHorizontalL);}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fy7v416{padding-bottom:7px;}", ".f1a1bwwz{padding-top:7px;}"],
    h: [".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".fwiml72:hover:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".fnp9lpt:hover:active{background-color:var(--colorBrandBackgroundPressed);}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}", ".f1d6v5y2:hover:active{color:var(--colorNeutralForegroundOnBrand);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".ft1hn21:hover .fui-Icon-filled{display:inline;}", ".fuxngvv:hover .fui-Icon-regular{display:none;}", ".fy5bs14:hover .fui-Button__icon{color:var(--colorNeutralForeground2BrandHover);}", ".fsv2rcd:hover:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1omzyqd:hover:active{color:var(--colorNeutralForeground2Pressed);}", ".f1dfjoow:hover:active .fui-Icon-filled{display:inline;}", ".f1j98vj9:hover:active .fui-Icon-regular{display:none;}", ".fj8yq94:hover:active .fui-Button__icon{color:var(--colorNeutralForeground2BrandPressed);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f1fg1p5m:hover:active{color:var(--colorNeutralForeground2BrandPressed);}"],
    m: [["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1uu00uk{border-top-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f9a0qzu{border-left-color:HighlightText;}.fkvaka8{border-right-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1ux7til{border-bottom-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fq7113v:hover{background-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.ff1wgvm:hover{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1x4h75k:hover{border-left-color:Highlight;}.fiob0tu:hover{border-right-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1j6scgf:hover{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f4xjyn1:hover{color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fbgcvur:hover:active{background-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1ks1yx8:hover:active{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1o6qegi:hover:active{border-right-color:Highlight;}.fmxjhhp:hover:active{border-left-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fcnxywj:hover:active{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f9ddjv3:hover:active{color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1et0tmh:hover .fui-Button__icon{color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1wi8ngl:hover:active .fui-Button__icon{color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1tme0vf:hover{background-color:var(--colorTransparentBackground);}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f18onu3q:hover:active{background-color:var(--colorTransparentBackground);}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useRootDisabledStyles = /* @__PURE__ */ __styles2({
    base: {
      De3pzq: "f1bg9a2p",
      g2u3we: "f1jj8ep1",
      h3c5rm: ["f15xbau", "fy0fskl"],
      B9xav0g: "f4ikngz",
      zhjwy3: ["fy0fskl", "f15xbau"],
      sj55zd: "f1s2aq7o",
      Bceei9c: "fdrzuqr",
      Bfinmwp: "f15x8b5r",
      Jwef8y: "f1falr9n",
      Bgoe8wy: "f12mpcsy",
      Bwzppfd: ["f1gwvigk", "f18rmfxp"],
      oetu4i: "f1jnshp0",
      gg5e9n: ["f18rmfxp", "f1gwvigk"],
      Bi91k9c: "fvgxktp",
      eoavqd: "fphbwmw",
      Bk3fhr4: "f19vpps7",
      Bmfj8id: "fv5swzo",
      Bbdnnc7: "f1al02dq",
      iro3zm: "f1t6o4dc",
      b661bw: "f10ztigi",
      Bk6r4ia: ["f1ft5sdu", "f1gzf82w"],
      B9zn80p: "f12zbtn2",
      Bpld233: ["f1gzf82w", "f1ft5sdu"],
      B2d53fq: "fcvwxyo",
      c3iz72: "f8w4c43",
      em6i61: "f1ol4fw6",
      vm6p8p: "f1q1lw4e",
      x3br3k: "f1dwjv2g"
    },
    highContrast: {
      Bsw6fvg: "f4lkoma",
      Bjwas2f: "fg455y9",
      Bn1d65q: ["f1rvyvqg", "f14g86mu"],
      Bxeuatn: "f1cwzwz",
      n51gp8: ["f14g86mu", "f1rvyvqg"],
      Bbusuzp: "f1dcs8yz",
      Bm2fdqk: "fuigjrg",
      G867l3: "fjwq6ea",
      gdbnj: ["f1lr3nhc", "f1mbxvi6"],
      mxns5l: "fn5gmvv",
      o3nasb: ["f1mbxvi6", "f1lr3nhc"],
      Bqrx1nm: "f1vmkb5g",
      pgvf35: "f53ppgq",
      Bh7lczh: ["f1663y11", "f80fkiy"],
      dpv3f4: "f18v5270",
      Bpnjhaq: ["f80fkiy", "f1663y11"],
      ze5xyy: "f1kc2mi9",
      Bx3q9su: "f4dhi0o",
      g2kj27: "f1y0svfh",
      Bf756sw: "fihuait",
      Bow2dr7: ["fnxhupq", "fyd6l6x"],
      Bvhedfk: "fx507ft",
      Gye4lf: ["fyd6l6x", "fnxhupq"],
      pc6evw: "fb3rf2x",
      xd2cci: "fequ9m0"
    },
    outline: {
      De3pzq: "f1c21dwh",
      Jwef8y: "f9ql6rf",
      iro3zm: "f3h1zc4"
    },
    primary: {
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"]
    },
    secondary: {},
    subtle: {
      De3pzq: "f1c21dwh",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      Jwef8y: "f9ql6rf",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      iro3zm: "f3h1zc4",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"]
    },
    transparent: {
      De3pzq: "f1c21dwh",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      Jwef8y: "f9ql6rf",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      iro3zm: "f3h1zc4",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"]
    }
  }, {
    d: [".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f15x8b5r .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}"],
    h: [".f1falr9n:hover{background-color:var(--colorNeutralBackgroundDisabled);}", ".f12mpcsy:hover{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1gwvigk:hover{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f18rmfxp:hover{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1jnshp0:hover{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".fphbwmw:hover{cursor:not-allowed;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f1al02dq:hover .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1t6o4dc:hover:active{background-color:var(--colorNeutralBackgroundDisabled);}", ".f10ztigi:hover:active{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1ft5sdu:hover:active{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1gzf82w:hover:active{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f12zbtn2:hover:active{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fcvwxyo:hover:active{color:var(--colorNeutralForegroundDisabled);}", ".f8w4c43:hover:active{cursor:not-allowed;}", ".f1ol4fw6:hover:active .fui-Icon-filled{display:none;}", ".f1q1lw4e:hover:active .fui-Icon-regular{display:inline;}", ".f1dwjv2g:hover:active .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".f3h1zc4:hover:active{background-color:var(--colorTransparentBackground);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}"],
    m: [["@media (forced-colors: active){.f4lkoma{background-color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fuigjrg .fui-Button__icon{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fjwq6ea:focus{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1lr3nhc:focus{border-right-color:GrayText;}.f1mbxvi6:focus{border-left-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fn5gmvv:focus{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1vmkb5g:hover{background-color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f53ppgq:hover{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1663y11:hover{border-right-color:GrayText;}.f80fkiy:hover{border-left-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f18v5270:hover{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1kc2mi9:hover{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f4dhi0o:hover .fui-Button__icon{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1y0svfh:hover:active{background-color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fihuait:hover:active{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fnxhupq:hover:active{border-right-color:GrayText;}.fyd6l6x:hover:active{border-left-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fx507ft:hover:active{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fb3rf2x:hover:active{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fequ9m0:hover:active .fui-Button__icon{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useRootFocusStyles = /* @__PURE__ */ __styles2({
    circular: {
      Bw81rd7: 0,
      kdpuga: 0,
      dm238s: 0,
      B6xbmo0: 0,
      B3whbx2: "f1062rbf"
    },
    rounded: {},
    square: {
      Bw81rd7: 0,
      kdpuga: 0,
      dm238s: 0,
      B6xbmo0: 0,
      B3whbx2: "fj0ryk1"
    },
    primary: {
      B8q5s1w: "f17t0x8g",
      Bci5o5g: ["f194v5ow", "fk7jm04"],
      n8qw10: "f1qgg65p",
      Bdrgwmp: ["fk7jm04", "f194v5ow"],
      j6ew2k: ["fhgccpy", "fjo7pq6"],
      he4mth: "f32wu9k",
      Byr4aka: "fu5nqqq",
      lks7q5: ["f13prjl2", "f1nl83rv"],
      Bnan3qt: "f1czftr5",
      k1dn9: ["f1nl83rv", "f13prjl2"],
      Boium3a: ["f12k37oa", "fdnykm2"],
      tm8e47: "fr96u23"
    },
    small: {
      Bw81rd7: 0,
      kdpuga: 0,
      dm238s: 0,
      B6xbmo0: 0,
      B3whbx2: "fazmxh"
    },
    medium: {},
    large: {
      Bw81rd7: 0,
      kdpuga: 0,
      dm238s: 0,
      B6xbmo0: 0,
      B3whbx2: "f1b6alqh"
    }
  }, {
    d: [[".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
      p: -1
    }], ".f17t0x8g[data-fui-focus-visible]{border-top-color:var(--colorStrokeFocus2);}", ".f194v5ow[data-fui-focus-visible]{border-right-color:var(--colorStrokeFocus2);}", ".fk7jm04[data-fui-focus-visible]{border-left-color:var(--colorStrokeFocus2);}", ".f1qgg65p[data-fui-focus-visible]{border-bottom-color:var(--colorStrokeFocus2);}", ".fhgccpy[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".fjo7pq6[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".f32wu9k[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;}", ".fu5nqqq[data-fui-focus-visible]:hover{border-top-color:var(--colorStrokeFocus2);}", ".f13prjl2[data-fui-focus-visible]:hover{border-right-color:var(--colorStrokeFocus2);}", ".f1nl83rv[data-fui-focus-visible]:hover{border-left-color:var(--colorStrokeFocus2);}", ".f1czftr5[data-fui-focus-visible]:hover{border-bottom-color:var(--colorStrokeFocus2);}", [".fazmxh[data-fui-focus-visible]{border-radius:var(--borderRadiusSmall);}", {
      p: -1
    }], [".f1b6alqh[data-fui-focus-visible]{border-radius:var(--borderRadiusLarge);}", {
      p: -1
    }]],
    t: ["@supports (-moz-appearance:button){.f12k37oa[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}.fdnykm2[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}}", "@supports (-moz-appearance:button){.fr96u23[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
  });
  var useRootIconOnlyStyles = /* @__PURE__ */ __styles2({
    small: {
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fu97m5z",
      Bf4jedk: "f17fgpbq",
      B2u0y6b: "f1jt17bm"
    },
    medium: {
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f18ktai2",
      Bf4jedk: "fwbmr0d",
      B2u0y6b: "f44c6la"
    },
    large: {
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1hbd1aw",
      Bf4jedk: "f12clzc2",
      B2u0y6b: "fjy1crr"
    }
  }, {
    d: [[".fu97m5z{padding:1px;}", {
      p: -1
    }], ".f17fgpbq{min-width:24px;}", ".f1jt17bm{max-width:24px;}", [".f18ktai2{padding:5px;}", {
      p: -1
    }], ".fwbmr0d{min-width:32px;}", ".f44c6la{max-width:32px;}", [".f1hbd1aw{padding:7px;}", {
      p: -1
    }], ".f12clzc2{min-width:40px;}", ".fjy1crr{max-width:40px;}"]
  });
  var useIconStyles2 = /* @__PURE__ */ __styles2({
    small: {
      Be2twd7: "fe5j1ua",
      Bqenvij: "fjamq6b",
      a9b677: "f64fuq3",
      Bqrlyyl: "fbaiahx"
    },
    medium: {},
    large: {
      Be2twd7: "f1rt2boy",
      Bqenvij: "frvgh55",
      a9b677: "fq4mcun",
      Bqrlyyl: "f1exjqw5"
    },
    before: {
      t21cq0: ["f1nizpg2", "f1a695kz"]
    },
    after: {
      Frg6f3: ["f1a695kz", "f1nizpg2"]
    }
  }, {
    d: [".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".fbaiahx{--fui-Button__icon--spacing:var(--spacingHorizontalXS);}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".f1exjqw5{--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}", ".f1nizpg2{margin-right:var(--fui-Button__icon--spacing);}", ".f1a695kz{margin-left:var(--fui-Button__icon--spacing);}"]
  });
  var useButtonStyles_unstable = (state) => {
    "use no memo";
    const rootBaseClassName = useRootBaseClassName();
    const iconBaseClassName = useIconBaseClassName();
    const rootStyles = useRootStyles3();
    const rootDisabledStyles = useRootDisabledStyles();
    const rootFocusStyles = useRootFocusStyles();
    const rootIconOnlyStyles = useRootIconOnlyStyles();
    const iconStyles = useIconStyles2();
    const {
      appearance,
      disabled,
      disabledFocusable,
      icon,
      iconOnly,
      iconPosition,
      shape,
      size
    } = state;
    state.root.className = mergeClasses(
      buttonClassNames.root,
      rootBaseClassName,
      appearance && rootStyles[appearance],
      rootStyles[size],
      icon && size === "small" && rootStyles.smallWithIcon,
      icon && size === "large" && rootStyles.largeWithIcon,
      rootStyles[shape],
      // Disabled styles
      (disabled || disabledFocusable) && rootDisabledStyles.base,
      (disabled || disabledFocusable) && rootDisabledStyles.highContrast,
      appearance && (disabled || disabledFocusable) && rootDisabledStyles[appearance],
      // Focus styles
      appearance === "primary" && rootFocusStyles.primary,
      rootFocusStyles[size],
      rootFocusStyles[shape],
      // Icon-only styles
      iconOnly && rootIconOnlyStyles[size],
      // User provided class name
      state.root.className
    );
    if (state.icon) {
      state.icon.className = mergeClasses(buttonClassNames.icon, iconBaseClassName, !!state.root.children && iconStyles[iconPosition], iconStyles[size], state.icon.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-button/lib/components/Button/Button.js
  var Button = /* @__PURE__ */ React85.forwardRef((props, ref) => {
    const state = useButton_unstable(props, ref);
    useButtonStyles_unstable(state);
    useCustomStyleHook("useButtonStyles_unstable")(state);
    return renderButton_unstable(state);
  });
  Button.displayName = "Button";

  // ../../node_modules/@fluentui/react-field/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-field/lib/contexts/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-field/lib/contexts/FieldContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React86 = __toESM(require_react());
  var FieldContext = React86.createContext(void 0);
  var FieldContextProvider = FieldContext.Provider;
  var useFieldContext_unstable = () => React86.useContext(FieldContext);

  // ../../node_modules/@fluentui/react-field/lib/contexts/useFieldControlProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function useFieldControlProps_unstable(props, options) {
    return getFieldControlProps(useFieldContext_unstable(), props, options);
  }
  function getFieldControlProps(context, props, options) {
    if (!context) {
      return props;
    }
    props = {
      ...props
    };
    const { generatedControlId, hintId, labelFor, labelId, required, validationMessageId, validationState } = context;
    if (generatedControlId) {
      var _props;
      var _id;
      (_id = (_props = props).id) !== null && _id !== void 0 ? _id : _props.id = generatedControlId;
    }
    if (labelId && (!(options === null || options === void 0 ? void 0 : options.supportsLabelFor) || labelFor !== props.id)) {
      var _props1, _arialabelledby;
      var _;
      (_ = (_props1 = props)[_arialabelledby = "aria-labelledby"]) !== null && _ !== void 0 ? _ : _props1[_arialabelledby] = labelId;
    }
    if (validationMessageId || hintId) {
      props["aria-describedby"] = [
        validationMessageId,
        hintId,
        props === null || props === void 0 ? void 0 : props["aria-describedby"]
      ].filter(Boolean).join(" ");
    }
    if (validationState === "error") {
      var _props2, _ariainvalid;
      var _1;
      (_1 = (_props2 = props)[_ariainvalid = "aria-invalid"]) !== null && _1 !== void 0 ? _1 : _props2[_ariainvalid] = true;
    }
    if (required) {
      if (options === null || options === void 0 ? void 0 : options.supportsRequired) {
        var _props3;
        var _required;
        (_required = (_props3 = props).required) !== null && _required !== void 0 ? _required : _props3.required = true;
      } else {
        var _props4, _ariarequired;
        var _2;
        (_2 = (_props4 = props)[_ariarequired = "aria-required"]) !== null && _2 !== void 0 ? _2 : _props4[_ariarequired] = true;
      }
    }
    if (options === null || options === void 0 ? void 0 : options.supportsSize) {
      var _props5;
      var _size;
      (_size = (_props5 = props).size) !== null && _size !== void 0 ? _size : _props5.size = context.size;
    }
    return props;
  }

  // ../../node_modules/@fluentui/react-label/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-label/lib/Label.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-label/lib/components/Label/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-label/lib/components/Label/Label.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React88 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-label/lib/components/Label/useLabel.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React87 = __toESM(require_react());
  var useLabel_unstable = (props, ref) => {
    const { disabled = false, required = false, weight = "regular", size = "medium" } = props;
    return {
      disabled,
      required: slot_exports.optional(required === true ? "*" : required || void 0, {
        defaultProps: {
          "aria-hidden": "true"
        },
        elementType: "span"
      }),
      weight,
      size,
      components: {
        root: "label",
        required: "span"
      },
      root: slot_exports.always(getIntrinsicElementProps("label", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLLabelElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "label"
      })
    };
  };

  // ../../node_modules/@fluentui/react-label/lib/components/Label/renderLabel.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderLabel_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.root.children,
        state.required && /* @__PURE__ */ jsx(state.required, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-label/lib/components/Label/useLabelStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var labelClassNames = {
    root: "fui-Label",
    required: "fui-Label__required"
  };
  var useStyles4 = /* @__PURE__ */ __styles2({
    root: {
      Bahqtrf: "fk6fouc",
      sj55zd: "f19n0e5"
    },
    disabled: {
      sj55zd: "f1s2aq7o",
      Bbusuzp: "f1dcs8yz"
    },
    required: {
      sj55zd: "f1whyuy6",
      uwmqm3: ["fruq291", "f7x41pl"]
    },
    small: {
      Be2twd7: "fy9rknc",
      Bg96gwp: "fwrc4pm"
    },
    medium: {
      Be2twd7: "fkhj508",
      Bg96gwp: "f1i3iumi"
    },
    large: {
      Be2twd7: "fod5ikn",
      Bg96gwp: "faaz57k",
      Bhrd7zp: "fl43uef"
    },
    semibold: {
      Bhrd7zp: "fl43uef"
    }
  }, {
    d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}"],
    m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useLabelStyles_unstable = (state) => {
    "use no memo";
    const styles2 = useStyles4();
    state.root.className = mergeClasses(labelClassNames.root, styles2.root, state.disabled && styles2.disabled, styles2[state.size], state.weight === "semibold" && styles2.semibold, state.root.className);
    if (state.required) {
      state.required.className = mergeClasses(labelClassNames.required, styles2.required, state.disabled && styles2.disabled, state.required.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-label/lib/components/Label/Label.js
  var Label = /* @__PURE__ */ React88.forwardRef((props, ref) => {
    const state = useLabel_unstable(props, ref);
    useLabelStyles_unstable(state);
    useCustomStyleHook("useLabelStyles_unstable")(state);
    return renderLabel_unstable(state);
  });
  Label.displayName = "Label";

  // ../../node_modules/@fluentui/react-input/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-input/lib/Input.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-input/lib/components/Input/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-input/lib/components/Input/Input.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React90 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-input/lib/components/Input/useInput.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React89 = __toESM(require_react());
  var useInput_unstable = (props, ref) => {
    props = useFieldControlProps_unstable(props, {
      supportsLabelFor: true,
      supportsRequired: true,
      supportsSize: true
    });
    const overrides = useOverrides();
    var _overrides_inputDefaultAppearance;
    const { size = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", onChange } = props;
    if (false) {
      console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
    }
    const [value, setValue] = useControllableState({
      state: props.value,
      defaultState: props.defaultValue,
      initialState: ""
    });
    const nativeProps = getPartitionedNativeProps({
      props,
      primarySlotTagName: "input",
      excludedPropNames: [
        "size",
        "onChange",
        "value",
        "defaultValue"
      ]
    });
    const state = {
      size,
      appearance,
      components: {
        root: "span",
        input: "input",
        contentBefore: "span",
        contentAfter: "span"
      },
      input: slot_exports.always(props.input, {
        defaultProps: {
          type: "text",
          ref,
          ...nativeProps.primary
        },
        elementType: "input"
      }),
      contentAfter: slot_exports.optional(props.contentAfter, {
        elementType: "span"
      }),
      contentBefore: slot_exports.optional(props.contentBefore, {
        elementType: "span"
      }),
      root: slot_exports.always(props.root, {
        defaultProps: nativeProps.root,
        elementType: "span"
      })
    };
    state.input.value = value;
    state.input.onChange = useEventCallback((ev) => {
      const newValue = ev.target.value;
      onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
        value: newValue
      });
      setValue(newValue);
    });
    return state;
  };

  // ../../node_modules/@fluentui/react-input/lib/components/Input/renderInput.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderInput_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.contentBefore && /* @__PURE__ */ jsx(state.contentBefore, {}),
        /* @__PURE__ */ jsx(state.input, {}),
        state.contentAfter && /* @__PURE__ */ jsx(state.contentAfter, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-input/lib/components/Input/useInputStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var inputClassNames = {
    root: "fui-Input",
    input: "fui-Input__input",
    contentBefore: "fui-Input__contentBefore",
    contentAfter: "fui-Input__contentAfter"
  };
  var horizontalPadding = {
    root: {
      small: tokens.spacingHorizontalSNudge,
      medium: tokens.spacingHorizontalMNudge,
      large: tokens.spacingHorizontalM
    },
    input: {
      small: tokens.spacingHorizontalXXS,
      medium: tokens.spacingHorizontalXXS,
      large: tokens.spacingHorizontalSNudge
    },
    combined: {
      small: tokens.spacingHorizontalS,
      medium: tokens.spacingHorizontalM,
      large: `calc(${tokens.spacingHorizontalM} + ${tokens.spacingHorizontalSNudge})`
    }
  };
  var useRootClassName4 = /* @__PURE__ */ __resetStyles2("r1oeeo9n", "r9sxh5", {
    r: [".r1oeeo9n{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.r1oeeo9n::after{box-sizing:border-box;content:"";position:absolute;left:-1px;bottom:-1px;right:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r1oeeo9n:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r1oeeo9n:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r1oeeo9n:focus-within{outline:2px solid transparent;}", ".r9sxh5{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.r9sxh5::after{box-sizing:border-box;content:"";position:absolute;right:-1px;bottom:-1px;left:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r9sxh5:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r9sxh5:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r9sxh5:focus-within{outline:2px solid transparent;}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r9sxh5::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r9sxh5:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}"]
  });
  var useRootStyles4 = /* @__PURE__ */ __styles2({
    small: {
      sshi5w: "f1pha7fy",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fy9rknc",
      Bhrd7zp: "figsok6",
      Bg96gwp: "fwrc4pm"
    },
    medium: {},
    large: {
      sshi5w: "f1w5jphr",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "figsok6",
      Bg96gwp: "faaz57k",
      i8kkvl: 0,
      Belr9w4: 0,
      rmohyg: "f1eyhf9v"
    },
    outline: {},
    outlineInteractive: {
      Bgoe8wy: "fvcxoqz",
      Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
      oetu4i: "f1l4zc64",
      gg5e9n: ["f1m52nbi", "f1ub3y4t"],
      Drbcw7: "f8vnjqi",
      udz0bu: ["fz1etlk", "f1hc16gm"],
      Be8ivqh: "f1klwx88",
      ofdepl: ["f1hc16gm", "fz1etlk"]
    },
    underline: {
      De3pzq: "f1c21dwh",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "fokr779",
      icvyot: "f1ern45e",
      vrafjx: ["f1n71otn", "f1deefiw"],
      wvpqe5: ["f1deefiw", "f1n71otn"],
      Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
      B1piin3: ["f15yvnhg", "f1n6gb5g"]
    },
    underlineInteractive: {
      oetu4i: "f1l4zc64",
      Be8ivqh: "f1klwx88",
      d9w3h3: 0,
      B3778ie: 0,
      B4j8arr: 0,
      Bl18szs: 0,
      Blrzh8d: "f2ale1x"
    },
    filled: {
      g2u3we: "fghlq4f",
      h3c5rm: ["f1gn591s", "fjscplz"],
      B9xav0g: "fb073pr",
      zhjwy3: ["fjscplz", "f1gn591s"]
    },
    filledInteractive: {
      q7v0qe: "ftmjh5b",
      kmh5ft: ["f17blpuu", "fsrcdbj"],
      nagaa4: "f1tpwn32",
      B1yhkcb: ["fsrcdbj", "f17blpuu"]
    },
    invalid: {
      tvckwq: "fs4k3qj",
      gk2u95: ["fcee079", "fmyw78r"],
      hhx65j: "f1fgmyf4",
      Bxowmz0: ["fmyw78r", "fcee079"]
    },
    "filled-darker": {
      De3pzq: "f16xq7d1"
    },
    "filled-lighter": {
      De3pzq: "fxugw4r"
    },
    "filled-darker-shadow": {
      De3pzq: "f16xq7d1",
      E5pizo: "fyed02w"
    },
    "filled-lighter-shadow": {
      De3pzq: "fxugw4r",
      E5pizo: "fyed02w"
    },
    disabled: {
      Bceei9c: "fdrzuqr",
      De3pzq: "f1c21dwh",
      g2u3we: "f1jj8ep1",
      h3c5rm: ["f15xbau", "fy0fskl"],
      B9xav0g: "f4ikngz",
      zhjwy3: ["fy0fskl", "f15xbau"],
      Bjwas2f: "fg455y9",
      Bn1d65q: ["f1rvyvqg", "f14g86mu"],
      Bxeuatn: "f1cwzwz",
      n51gp8: ["f14g86mu", "f1rvyvqg"],
      Bsft5z2: "fhr9occ",
      Bduesf4: "f99w1ws"
    },
    smallWithContentBefore: {
      uwmqm3: ["fk8j09s", "fdw0yi8"]
    },
    smallWithContentAfter: {
      z189sj: ["fdw0yi8", "fk8j09s"]
    },
    mediumWithContentBefore: {
      uwmqm3: ["f1ng84yb", "f11gcy0p"]
    },
    mediumWithContentAfter: {
      z189sj: ["f11gcy0p", "f1ng84yb"]
    },
    largeWithContentBefore: {
      uwmqm3: ["f1uw59to", "fw5db7e"]
    },
    largeWithContentAfter: {
      z189sj: ["fw5db7e", "f1uw59to"]
    }
  }, {
    d: [".f1pha7fy{min-height:24px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1w5jphr{min-height:40px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
      p: -1
    }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".fokr779{border-radius:0;}", {
      p: -1
    }], ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", [".f2ale1x::after{border-radius:0;}", {
      p: -1
    }], ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fyed02w{box-shadow:var(--shadow2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fhr9occ::after{content:unset;}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}"],
    h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}", ".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}"],
    a: [".f8vnjqi:active,.f8vnjqi:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".fz1etlk:active,.fz1etlk:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1hc16gm:active,.f1hc16gm:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1klwx88:active,.f1klwx88:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
    m: [["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }]],
    w: [".f99w1ws:focus-within{outline-style:none;}"]
  });
  var useInputClassName = /* @__PURE__ */ __resetStyles2("r12stul0", null, [".r12stul0{align-self:stretch;box-sizing:border-box;flex-grow:1;min-width:0;border-style:none;padding:0 var(--spacingHorizontalM);color:var(--colorNeutralForeground1);background-color:transparent;outline-style:none;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;}", ".r12stul0::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r12stul0::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r12stul0::placeholder{color:var(--colorNeutralForeground4);opacity:1;}"]);
  var useInputElementStyles = /* @__PURE__ */ __styles2({
    small: {
      uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
      z189sj: ["f1vdfbxk", "f1f5gg8d"]
    },
    medium: {},
    large: {
      uwmqm3: ["fnphzt9", "flt1dlf"],
      z189sj: ["flt1dlf", "fnphzt9"]
    },
    smallWithContentBefore: {
      uwmqm3: ["fgiv446", "ffczdla"]
    },
    smallWithContentAfter: {
      z189sj: ["ffczdla", "fgiv446"]
    },
    mediumWithContentBefore: {
      uwmqm3: ["fgiv446", "ffczdla"]
    },
    mediumWithContentAfter: {
      z189sj: ["ffczdla", "fgiv446"]
    },
    largeWithContentBefore: {
      uwmqm3: ["fk8j09s", "fdw0yi8"]
    },
    largeWithContentAfter: {
      z189sj: ["fdw0yi8", "fk8j09s"]
    },
    disabled: {
      sj55zd: "f1s2aq7o",
      De3pzq: "f1c21dwh",
      Bceei9c: "fdrzuqr",
      yvdlaj: "fahhnxm"
    }
  }, {
    d: [".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".fnphzt9{padding-left:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".flt1dlf{padding-right:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"]
  });
  var useContentClassName = /* @__PURE__ */ __resetStyles2("r1572tok", null, [".r1572tok{box-sizing:border-box;color:var(--colorNeutralForeground3);display:flex;}", ".r1572tok>svg{font-size:20px;}"]);
  var useContentStyles = /* @__PURE__ */ __styles2({
    disabled: {
      sj55zd: "f1s2aq7o"
    },
    small: {
      Duoase: "f3qv9w"
    },
    medium: {},
    large: {
      Duoase: "f16u2scb"
    }
  }, {
    d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f3qv9w>svg{font-size:16px;}", ".f16u2scb>svg{font-size:24px;}"]
  });
  var useInputStyles_unstable = (state) => {
    "use no memo";
    const {
      size,
      appearance
    } = state;
    const disabled = state.input.disabled;
    const invalid = `${state.input["aria-invalid"]}` === "true";
    const filled = appearance.startsWith("filled");
    const rootStyles = useRootStyles4();
    const inputStyles = useInputElementStyles();
    const contentStyles = useContentStyles();
    state.root.className = mergeClasses(inputClassNames.root, useRootClassName4(), rootStyles[size], state.contentBefore && rootStyles[`${size}WithContentBefore`], state.contentAfter && rootStyles[`${size}WithContentAfter`], rootStyles[appearance], !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && appearance === "underline" && rootStyles.underlineInteractive, !disabled && filled && rootStyles.filledInteractive, filled && rootStyles.filled, !disabled && invalid && rootStyles.invalid, disabled && rootStyles.disabled, state.root.className);
    state.input.className = mergeClasses(inputClassNames.input, useInputClassName(), inputStyles[size], state.contentBefore && inputStyles[`${size}WithContentBefore`], state.contentAfter && inputStyles[`${size}WithContentAfter`], disabled && inputStyles.disabled, state.input.className);
    const contentClasses = [useContentClassName(), disabled && contentStyles.disabled, contentStyles[size]];
    if (state.contentBefore) {
      state.contentBefore.className = mergeClasses(inputClassNames.contentBefore, ...contentClasses, state.contentBefore.className);
    }
    if (state.contentAfter) {
      state.contentAfter.className = mergeClasses(inputClassNames.contentAfter, ...contentClasses, state.contentAfter.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-input/lib/components/Input/Input.js
  var Input = /* @__PURE__ */ React90.forwardRef((props, ref) => {
    const state = useInput_unstable(props, ref);
    useInputStyles_unstable(state);
    useCustomStyleHook("useInputStyles_unstable")(state);
    return renderInput_unstable(state);
  });
  Input.displayName = "Input";

  // ../../node_modules/@fluentui/react-spinner/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-spinner/lib/Spinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/Spinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React93 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React92 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-spinner/lib/contexts/SpinnerContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React91 = __toESM(require_react());
  var SpinnerContext = React91.createContext(void 0);
  var SpinnerContextDefaultValue = {};
  var SpinnerContextProvider = SpinnerContext.Provider;
  var useSpinnerContext = () => {
    var _React_useContext;
    return (_React_useContext = React91.useContext(SpinnerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : SpinnerContextDefaultValue;
  };

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinner.js
  var useSpinner_unstable = (props, ref) => {
    const { size: contextSize } = useSpinnerContext();
    const { appearance = "primary", labelPosition = "after", size = contextSize !== null && contextSize !== void 0 ? contextSize : "medium", delay = 0 } = props;
    const baseId = useId4("spinner");
    const { role = "progressbar", ...rest } = props;
    const nativeRoot = slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role,
      ...rest
    }, [
      "size"
    ]), {
      elementType: "div"
    });
    const [isShownAfterDelay, setIsShownAfterDelay] = React92.useState(false);
    const [setDelayTimeout, clearDelayTimeout] = useTimeout();
    React92.useEffect(() => {
      if (delay <= 0) {
        return;
      }
      setDelayTimeout(() => {
        setIsShownAfterDelay(true);
      }, delay);
      return () => {
        clearDelayTimeout();
      };
    }, [
      setDelayTimeout,
      clearDelayTimeout,
      delay
    ]);
    const labelShorthand = slot_exports.optional(props.label, {
      defaultProps: {
        id: baseId
      },
      renderByDefault: false,
      elementType: Label
    });
    const spinnerShortHand = slot_exports.optional(props.spinner, {
      renderByDefault: true,
      elementType: "span"
    });
    if (labelShorthand && nativeRoot && !nativeRoot["aria-labelledby"]) {
      nativeRoot["aria-labelledby"] = labelShorthand.id;
    }
    const state = {
      appearance,
      delay,
      labelPosition,
      size,
      shouldRenderSpinner: !delay || isShownAfterDelay,
      components: {
        root: "div",
        spinner: "span",
        spinnerTail: "span",
        label: Label
      },
      root: nativeRoot,
      spinner: spinnerShortHand,
      spinnerTail: slot_exports.always(props.spinnerTail, {
        elementType: "span"
      }),
      label: labelShorthand
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/renderSpinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderSpinner_unstable = (state) => {
    assertSlots(state);
    const { labelPosition, shouldRenderSpinner } = state;
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.label && shouldRenderSpinner && (labelPosition === "above" || labelPosition === "before") && /* @__PURE__ */ jsx(state.label, {}),
        state.spinner && shouldRenderSpinner && /* @__PURE__ */ jsx(state.spinner, {
          children: state.spinnerTail && /* @__PURE__ */ jsx(state.spinnerTail, {})
        }),
        state.label && shouldRenderSpinner && (labelPosition === "below" || labelPosition === "after") && /* @__PURE__ */ jsx(state.label, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinnerStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var spinnerClassNames = {
    root: "fui-Spinner",
    spinner: "fui-Spinner__spinner",
    spinnerTail: "fui-Spinner__spinnerTail",
    label: "fui-Spinner__label"
  };
  var useRootBaseClassName2 = /* @__PURE__ */ __resetStyles2("r82apo5", null, [".r82apo5{display:flex;align-items:center;justify-content:center;line-height:0;gap:8px;overflow:hidden;}"]);
  var useRootStyles5 = /* @__PURE__ */ __styles2({
    vertical: {
      Beiy3e4: "f1vx9l62"
    }
  }, {
    d: [".f1vx9l62{flex-direction:column;}"]
  });
  var useSpinnerBaseClassName = /* @__PURE__ */ __resetStyles2("rvgcg50", "r15nd2jo", {
    r: [".rvgcg50{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:rb7n1on;}", "@keyframes rb7n1on{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}", ".r15nd2jo{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:r1gx3jof;}", "@keyframes r1gx3jof{0%{transform:rotate(0deg);}100%{transform:rotate(-360deg);}}"],
    s: ["@media screen and (forced-colors: active){.rvgcg50{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.rvgcg50{animation-duration:1.8s;}}", "@media screen and (forced-colors: active){.r15nd2jo{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r15nd2jo{animation-duration:1.8s;}}"]
  });
  var useSpinnerTailBaseClassName = /* @__PURE__ */ __resetStyles2("rxov3xa", "r1o544mv", {
    r: [".rxov3xa{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r15mim6k;}", '.rxov3xa::before,.rxov3xa::after{content:"";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}', "@keyframes r15mim6k{0%{transform:rotate(-135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(225deg);}}", ".rxov3xa::before{animation-name:r18vhmn8;}", "@keyframes r18vhmn8{0%{transform:rotate(0deg);}50%{transform:rotate(105deg);}100%{transform:rotate(0deg);}}", ".rxov3xa::after{animation-name:rkgrvoi;}", "@keyframes rkgrvoi{0%{transform:rotate(0deg);}50%{transform:rotate(225deg);}100%{transform:rotate(0deg);}}", ".r1o544mv{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r109gmi5;}", '.r1o544mv::before,.r1o544mv::after{content:"";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}', "@keyframes r109gmi5{0%{transform:rotate(135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(-225deg);}}", ".r1o544mv::before{animation-name:r17whflh;}", "@keyframes r17whflh{0%{transform:rotate(0deg);}50%{transform:rotate(-105deg);}100%{transform:rotate(0deg);}}", ".r1o544mv::after{animation-name:re4odhl;}", "@keyframes re4odhl{0%{transform:rotate(0deg);}50%{transform:rotate(-225deg);}100%{transform:rotate(0deg);}}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.rxov3xa{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.rxov3xa::before,.rxov3xa::after{content:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r1o544mv{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.r1o544mv::before,.r1o544mv::after{content:none;}}"]
  });
  var useSpinnerStyles = /* @__PURE__ */ __styles2({
    inverted: {
      De3pzq: "fr407j0",
      sj55zd: "f1f7voed"
    },
    rtlTail: {
      btxmck: "f179dep3",
      gb5jj2: "fbz9ihp",
      Br2kee7: "f1wkkxo7"
    },
    "extra-tiny": {
      Bqenvij: "fd461yt",
      a9b677: "fjw5fx7",
      qmp6fs: "f1v3ph3m"
    },
    tiny: {
      Bqenvij: "fjamq6b",
      a9b677: "f64fuq3",
      qmp6fs: "f1v3ph3m"
    },
    "extra-small": {
      Bqenvij: "frvgh55",
      a9b677: "fq4mcun",
      qmp6fs: "f1v3ph3m"
    },
    small: {
      Bqenvij: "fxldao9",
      a9b677: "f1w9dchk",
      qmp6fs: "f1v3ph3m"
    },
    medium: {
      Bqenvij: "f1d2rq10",
      a9b677: "f1szoe96",
      qmp6fs: "fb52u90"
    },
    large: {
      Bqenvij: "f8ljn23",
      a9b677: "fpdz1er",
      qmp6fs: "fb52u90"
    },
    "extra-large": {
      Bqenvij: "fbhnoac",
      a9b677: "feqmc2u",
      qmp6fs: "fb52u90"
    },
    huge: {
      Bqenvij: "f1ft4266",
      a9b677: "fksc0bp",
      qmp6fs: "fa3u9ii"
    }
  }, {
    d: [".fr407j0{background-color:var(--colorNeutralStrokeAlpha2);}", ".f1f7voed{color:var(--colorNeutralStrokeOnBrand2);}", ".f179dep3{-webkit-mask-image:conic-gradient(white 255deg, transparent 255deg);mask-image:conic-gradient(white 255deg, transparent 255deg);}", ".fbz9ihp::before,.fbz9ihp::after{background-image:conic-gradient(transparent 225deg, currentcolor 225deg);}", ".fd461yt{height:16px;}", ".fjw5fx7{width:16px;}", ".f1v3ph3m{--fui-Spinner--strokeWidth:var(--strokeWidthThick);}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".fxldao9{height:28px;}", ".f1w9dchk{width:28px;}", ".f1d2rq10{height:32px;}", ".f1szoe96{width:32px;}", ".fb52u90{--fui-Spinner--strokeWidth:var(--strokeWidthThicker);}", ".f8ljn23{height:36px;}", ".fpdz1er{width:36px;}", ".fbhnoac{height:40px;}", ".feqmc2u{width:40px;}", ".f1ft4266{height:44px;}", ".fksc0bp{width:44px;}", ".fa3u9ii{--fui-Spinner--strokeWidth:var(--strokeWidthThickest);}"],
    m: [["@media screen and (prefers-reduced-motion: reduce){.f1wkkxo7{background-image:conic-gradient(currentcolor 0deg, transparent 240deg);}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }]]
  });
  var useLabelStyles = /* @__PURE__ */ __styles2({
    inverted: {
      sj55zd: "fonrgv7"
    },
    "extra-tiny": {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    tiny: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    "extra-small": {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    small: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    medium: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    large: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    "extra-large": {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    huge: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "f1pp30po",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "f106mvju"
    }
  }, {
    d: [".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}"]
  });
  var useSpinnerStyles_unstable = (state) => {
    "use no memo";
    const {
      labelPosition,
      size,
      appearance
    } = state;
    const {
      dir
    } = useFluent();
    const rootBaseClassName = useRootBaseClassName2();
    const rootStyles = useRootStyles5();
    const spinnerBaseClassName = useSpinnerBaseClassName();
    const spinnerStyles = useSpinnerStyles();
    const spinnerTailBaseClassName = useSpinnerTailBaseClassName();
    const labelStyles = useLabelStyles();
    state.root.className = mergeClasses(spinnerClassNames.root, rootBaseClassName, (labelPosition === "above" || labelPosition === "below") && rootStyles.vertical, state.root.className);
    if (state.spinner) {
      state.spinner.className = mergeClasses(spinnerClassNames.spinner, spinnerBaseClassName, spinnerStyles[size], appearance === "inverted" && spinnerStyles.inverted, state.spinner.className);
    }
    if (state.spinnerTail) {
      state.spinnerTail.className = mergeClasses(spinnerClassNames.spinnerTail, spinnerTailBaseClassName, dir === "rtl" && spinnerStyles.rtlTail, state.spinnerTail.className);
    }
    if (state.label) {
      state.label.className = mergeClasses(spinnerClassNames.label, labelStyles[size], appearance === "inverted" && labelStyles.inverted, state.label.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/Spinner.js
  var Spinner = /* @__PURE__ */ React93.forwardRef((props, ref) => {
    const state = useSpinner_unstable(props, ref);
    useSpinnerStyles_unstable(state);
    useCustomStyleHook("useSpinnerStyles_unstable")(state);
    return renderSpinner_unstable(state);
  });
  Spinner.displayName = "Spinner";

  // ../../node_modules/@fluentui/react-switch/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-switch/lib/Switch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/Switch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React95 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/useSwitch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React94 = __toESM(require_react());
  var useSwitch_unstable = (props, ref) => {
    props = useFieldControlProps_unstable(props, {
      supportsLabelFor: true,
      supportsRequired: true
    });
    const { checked, defaultChecked, disabled, labelPosition = "after", onChange, required } = props;
    const nativeProps = getPartitionedNativeProps({
      props,
      primarySlotTagName: "input",
      excludedPropNames: [
        "checked",
        "defaultChecked",
        "onChange"
      ]
    });
    const id = useId4("switch-", nativeProps.primary.id);
    const root = slot_exports.always(props.root, {
      defaultProps: {
        ref: useFocusWithin(),
        ...nativeProps.root
      },
      elementType: "div"
    });
    const indicator = slot_exports.always(props.indicator, {
      defaultProps: {
        "aria-hidden": true,
        children: /* @__PURE__ */ React94.createElement(CircleFilled, null)
      },
      elementType: "div"
    });
    const input = slot_exports.always(props.input, {
      defaultProps: {
        checked,
        defaultChecked,
        id,
        ref,
        role: "switch",
        type: "checkbox",
        ...nativeProps.primary
      },
      elementType: "input"
    });
    input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      checked: ev.currentTarget.checked
    }));
    const label = slot_exports.optional(props.label, {
      defaultProps: {
        disabled,
        htmlFor: id,
        required,
        size: "medium"
      },
      elementType: Label
    });
    return {
      labelPosition,
      components: {
        root: "div",
        indicator: "div",
        input: "input",
        label: Label
      },
      root,
      indicator,
      input,
      label
    };
  };

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/renderSwitch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderSwitch_unstable = (state) => {
    assertSlots(state);
    const { labelPosition } = state;
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        /* @__PURE__ */ jsx(state.input, {}),
        labelPosition !== "after" && state.label && /* @__PURE__ */ jsx(state.label, {}),
        /* @__PURE__ */ jsx(state.indicator, {}),
        labelPosition === "after" && state.label && /* @__PURE__ */ jsx(state.label, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/useSwitchStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var switchClassNames = {
    root: "fui-Switch",
    indicator: "fui-Switch__indicator",
    input: "fui-Switch__input",
    label: "fui-Switch__label"
  };
  var switchClassName = switchClassNames.root;
  var spaceBetweenThumbAndTrack = 2;
  var trackHeight = 20;
  var thumbSize = trackHeight - spaceBetweenThumbAndTrack;
  var useRootBaseClassName3 = /* @__PURE__ */ __resetStyles2("r2i81i2", "rofhmb8", {
    r: [".r2i81i2{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".r2i81i2:focus{outline-style:none;}", ".r2i81i2:focus-visible{outline-style:none;}", ".r2i81i2[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r2i81i2[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rofhmb8{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".rofhmb8:focus{outline-style:none;}", ".rofhmb8:focus-visible{outline-style:none;}", ".rofhmb8[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rofhmb8[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
    s: ["@media (forced-colors: active){.r2i81i2[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rofhmb8[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
  });
  var useRootStyles6 = /* @__PURE__ */ __styles2({
    vertical: {
      Beiy3e4: "f1vx9l62"
    }
  }, {
    d: [".f1vx9l62{flex-direction:column;}"]
  });
  var useIndicatorBaseClassName = /* @__PURE__ */ __resetStyles2("r1c3hft5", null, {
    r: [".r1c3hft5{border-radius:var(--borderRadiusCircular);border:1px solid;line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;margin:var(--spacingVerticalS) var(--spacingHorizontalS);pointer-events:none;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;}", ".r1c3hft5>*{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.r1c3hft5{transition-duration:0.01ms;}}", "@media (forced-colors: active){.r1c3hft5{color:CanvasText;}.r1c3hft5>i{forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r1c3hft5>*{transition-duration:0.01ms;}}"]
  });
  var useIndicatorStyles = /* @__PURE__ */ __styles2({
    labelAbove: {
      B6of3ja: "f1hu3pq6"
    }
  }, {
    d: [".f1hu3pq6{margin-top:0;}"]
  });
  var useInputBaseClassName = /* @__PURE__ */ __resetStyles2("rsji9ng", "r15xih98", {
    r: [".rsji9ng{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".rsji9ng:checked~.fui-Switch__indicator>*{transform:translateX(20px);}", ".rsji9ng:disabled{cursor:default;}", ".rsji9ng:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".rsji9ng:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".rsji9ng:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".rsji9ng:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".rsji9ng:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rsji9ng:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".rsji9ng:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".rsji9ng:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}", ".r15xih98{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".r15xih98:checked~.fui-Switch__indicator>*{transform:translateX(-20px);}", ".r15xih98:disabled{cursor:default;}", ".r15xih98:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".r15xih98:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".r15xih98:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".r15xih98:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".r15xih98:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".r15xih98:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".r15xih98:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".r15xih98:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".r15xih98:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}"],
    s: ["@media (forced-colors: active){.rsji9ng:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.rsji9ng:disabled~.fui-Switch__label{color:GrayText;}.rsji9ng:hover{color:CanvasText;}.rsji9ng:hover:active{color:CanvasText;}.rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}", "@media (forced-colors: active){.r15xih98:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.r15xih98:disabled~.fui-Switch__label{color:GrayText;}.r15xih98:hover{color:CanvasText;}.r15xih98:hover:active{color:CanvasText;}.r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}"]
  });
  var useInputStyles = /* @__PURE__ */ __styles2({
    before: {
      j35jbq: ["f1e31b4d", "f1vgc2s3"],
      Bhzewxz: "f15twtuk"
    },
    after: {
      oyh7mz: ["f1vgc2s3", "f1e31b4d"],
      Bhzewxz: "f15twtuk"
    },
    above: {
      B5kzvoi: "f1yab3r1",
      Bqenvij: "f1aar7gd",
      a9b677: "fly5x3f"
    }
  }, {
    d: [".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f15twtuk{top:0;}", ".f1yab3r1{bottom:0;}", ".f1aar7gd{height:calc(20px + var(--spacingVerticalS));}", ".fly5x3f{width:100%;}"]
  });
  var useLabelStyles2 = /* @__PURE__ */ __styles2({
    base: {
      Bceei9c: "f1k6fduh",
      jrapky: "f49ad5g",
      B6of3ja: "f1xlvstr",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1f5q0n8"
    },
    above: {
      z8tnut: "f1ywm7hm",
      Byoj8tv: "f14wxoun",
      a9b677: "fly5x3f"
    },
    after: {
      uwmqm3: ["fruq291", "f7x41pl"]
    },
    before: {
      z189sj: ["f7x41pl", "fruq291"]
    }
  }, {
    d: [".f1k6fduh{cursor:pointer;}", ".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}", ".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
      p: -1
    }], ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".fly5x3f{width:100%;}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}"]
  });
  var useSwitchStyles_unstable = (state) => {
    "use no memo";
    const rootBaseClassName = useRootBaseClassName3();
    const rootStyles = useRootStyles6();
    const indicatorBaseClassName = useIndicatorBaseClassName();
    const indicatorStyles = useIndicatorStyles();
    const inputBaseClassName = useInputBaseClassName();
    const inputStyles = useInputStyles();
    const labelStyles = useLabelStyles2();
    const {
      label,
      labelPosition
    } = state;
    state.root.className = mergeClasses(switchClassNames.root, rootBaseClassName, labelPosition === "above" && rootStyles.vertical, state.root.className);
    state.indicator.className = mergeClasses(switchClassNames.indicator, indicatorBaseClassName, label && labelPosition === "above" && indicatorStyles.labelAbove, state.indicator.className);
    state.input.className = mergeClasses(switchClassNames.input, inputBaseClassName, label && inputStyles[labelPosition], state.input.className);
    if (state.label) {
      state.label.className = mergeClasses(switchClassNames.label, labelStyles.base, labelStyles[labelPosition], state.label.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/Switch.js
  var Switch = /* @__PURE__ */ React95.forwardRef((props, ref) => {
    const state = useSwitch_unstable(props, ref);
    useSwitchStyles_unstable(state);
    useCustomStyleHook("useSwitchStyles_unstable")(state);
    return renderSwitch_unstable(state);
  });
  Switch.displayName = "Switch";

  // ../../node_modules/@fluentui/react-tabs/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabs/lib/Tab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/Tab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React98 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React96 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/TabListContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var tabListContextDefaultValue = {
    appearance: "transparent",
    reserveSelectedTabSpace: true,
    selectTabOnFocus: false,
    disabled: false,
    selectedValue: void 0,
    onRegister: () => {
    },
    onUnregister: () => {
    },
    onSelect: () => {
    },
    getRegisteredTabs: () => {
      return {
        registeredTabs: {}
      };
    },
    size: "medium",
    vertical: false
  };
  var TabListContext = createContext20(void 0);
  var TabListProvider = TabListContext.Provider;
  var useTabListContext_unstable = (selector) => useContextSelector(TabListContext, (ctx = tabListContextDefaultValue) => selector(ctx));

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTab.js
  var useTab_unstable = (props, ref) => {
    const { content, disabled: tabDisabled = false, icon, onClick, onFocus, value } = props;
    const appearance = useTabListContext_unstable((ctx) => ctx.appearance);
    const reserveSelectedTabSpace = useTabListContext_unstable((ctx) => ctx.reserveSelectedTabSpace);
    const selectTabOnFocus = useTabListContext_unstable((ctx) => ctx.selectTabOnFocus);
    const listDisabled = useTabListContext_unstable((ctx) => ctx.disabled);
    const selected = useTabListContext_unstable((ctx) => ctx.selectedValue === value);
    const onRegister = useTabListContext_unstable((ctx) => ctx.onRegister);
    const onUnregister = useTabListContext_unstable((ctx) => ctx.onUnregister);
    const onSelect = useTabListContext_unstable((ctx) => ctx.onSelect);
    const size = useTabListContext_unstable((ctx) => ctx.size);
    const vertical = useTabListContext_unstable((ctx) => !!ctx.vertical);
    const disabled = listDisabled || tabDisabled;
    const innerRef = React96.useRef(null);
    const onSelectCallback = (event) => onSelect(event, {
      value
    });
    const onTabClick = useEventCallback(mergeCallbacks(onClick, onSelectCallback));
    const onTabFocus = useEventCallback(mergeCallbacks(onFocus, onSelectCallback));
    const focusProps = useTabsterAttributes({
      focusable: {
        isDefault: selected
      }
    });
    React96.useEffect(() => {
      onRegister({
        value,
        ref: innerRef
      });
      return () => {
        onUnregister({
          value,
          ref: innerRef
        });
      };
    }, [
      onRegister,
      onUnregister,
      innerRef,
      value
    ]);
    const iconSlot = slot_exports.optional(icon, {
      elementType: "span"
    });
    const contentSlot = slot_exports.always(content, {
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    });
    const contentReservedSpace = content && typeof content === "object" ? omit(content, [
      "ref"
    ]) : content;
    const iconOnly = Boolean((iconSlot === null || iconSlot === void 0 ? void 0 : iconSlot.children) && !contentSlot.children);
    return {
      components: {
        root: "button",
        icon: "span",
        content: "span",
        contentReservedSpace: "span"
      },
      root: slot_exports.always(getIntrinsicElementProps("button", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLButtonElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, innerRef),
        role: "tab",
        type: "button",
        // aria-selected undefined indicates it is not selectable
        // according to https://www.w3.org/TR/wai-aria-1.1/#aria-selected
        "aria-selected": disabled ? void 0 : `${selected}`,
        ...focusProps,
        ...props,
        disabled,
        onClick: onTabClick,
        onFocus: selectTabOnFocus ? onTabFocus : onFocus
      }), {
        elementType: "button"
      }),
      icon: iconSlot,
      iconOnly,
      content: contentSlot,
      contentReservedSpace: slot_exports.optional(contentReservedSpace, {
        renderByDefault: !selected && !iconOnly && reserveSelectedTabSpace,
        defaultProps: {
          children: props.children
        },
        elementType: "span"
      }),
      appearance,
      disabled,
      selected,
      size,
      value,
      vertical
    };
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/renderTab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderTab_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.icon && /* @__PURE__ */ jsx(state.icon, {}),
        !state.iconOnly && /* @__PURE__ */ jsx(state.content, {}),
        state.contentReservedSpace && /* @__PURE__ */ jsx(state.contentReservedSpace, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTabStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTabAnimatedIndicator.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React97 = __toESM(require_react());
  var tabIndicatorCssVars_unstable = {
    offsetVar: "--fui-Tab__indicator--offset",
    scaleVar: "--fui-Tab__indicator--scale"
  };
  var useActiveIndicatorStyles = /* @__PURE__ */ __styles2({
    base: {
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1gl81tg"
    },
    animated: {
      Ba2ppi3: "fhwpy7i",
      F2fol1: "f6zz20j",
      B1dyfl9: "f1ai4sc1",
      B0vmy72: "f9qxlq5",
      u9bimw: "f1aql376"
    },
    horizontal: {
      sjv3b2: ["fug4aj8", "f1i5xzg7"],
      b1kco5: "f1q7ujh"
    },
    vertical: {
      sjv3b2: "f1hqboyk",
      b1kco5: "f1dxupa6"
    }
  }, {
    d: [[".f1gl81tg{overflow:visible;}", {
      p: -1
    }], ".fhwpy7i::after{transition-property:transform;}", ".f6zz20j::after{transition-duration:var(--durationSlow);}", ".f1ai4sc1::after{transition-timing-function:var(--curveDecelerateMax);}", ".fug4aj8::after{transform-origin:left;}", ".f1i5xzg7::after{transform-origin:right;}", ".f1q7ujh::after{transform:translateX(var(--fui-Tab__indicator--offset)) scaleX(var(--fui-Tab__indicator--scale));}", ".f1hqboyk::after{transform-origin:top;}", ".f1dxupa6::after{transform:translateY(var(--fui-Tab__indicator--offset)) scaleY(var(--fui-Tab__indicator--scale));}"],
    m: [["@media (prefers-reduced-motion: reduce){.f9qxlq5::after{transition-property:none;}}", {
      m: "(prefers-reduced-motion: reduce)"
    }], ["@media (prefers-reduced-motion: reduce){.f1aql376::after{transition-duration:0.01ms;}}", {
      m: "(prefers-reduced-motion: reduce)"
    }]]
  });
  var calculateTabRect = (element) => {
    if (element) {
      var _element_parentElement;
      const parentRect = ((_element_parentElement = element.parentElement) === null || _element_parentElement === void 0 ? void 0 : _element_parentElement.getBoundingClientRect()) || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      const tabRect = element.getBoundingClientRect();
      return {
        x: tabRect.x - parentRect.x,
        y: tabRect.y - parentRect.y,
        width: tabRect.width,
        height: tabRect.height
      };
    }
    return void 0;
  };
  var getRegisteredTabRect = (registeredTabs, value) => {
    var _registeredTabs_JSON_stringify;
    const element = isValueDefined(value) ? (_registeredTabs_JSON_stringify = registeredTabs[JSON.stringify(value)]) === null || _registeredTabs_JSON_stringify === void 0 ? void 0 : _registeredTabs_JSON_stringify.ref.current : void 0;
    return element ? calculateTabRect(element) : void 0;
  };
  var isValueDefined = (value) => value != null;
  var useTabAnimatedIndicatorStyles_unstable = (state) => {
    const {
      disabled,
      selected,
      vertical
    } = state;
    const activeIndicatorStyles = useActiveIndicatorStyles();
    const [lastAnimatedFrom, setLastAnimatedFrom] = React97.useState();
    const [animationValues, setAnimationValues] = React97.useState({
      offset: 0,
      scale: 1
    });
    const getRegisteredTabs = useTabListContext_unstable((ctx) => ctx.getRegisteredTabs);
    const [requestAnimationFrame] = useAnimationFrame();
    if (selected) {
      const {
        previousSelectedValue,
        selectedValue,
        registeredTabs
      } = getRegisteredTabs();
      if (isValueDefined(previousSelectedValue) && lastAnimatedFrom !== previousSelectedValue) {
        const previousSelectedTabRect = getRegisteredTabRect(registeredTabs, previousSelectedValue);
        const selectedTabRect = getRegisteredTabRect(registeredTabs, selectedValue);
        if (selectedTabRect && previousSelectedTabRect) {
          const offset = vertical ? previousSelectedTabRect.y - selectedTabRect.y : previousSelectedTabRect.x - selectedTabRect.x;
          const scale = vertical ? previousSelectedTabRect.height / selectedTabRect.height : previousSelectedTabRect.width / selectedTabRect.width;
          setAnimationValues({
            offset,
            scale
          });
          setLastAnimatedFrom(previousSelectedValue);
          requestAnimationFrame(() => setAnimationValues({
            offset: 0,
            scale: 1
          }));
        }
      }
    } else if (isValueDefined(lastAnimatedFrom)) {
      setLastAnimatedFrom(void 0);
    }
    if (disabled) {
      return state;
    }
    const animating = animationValues.offset === 0 && animationValues.scale === 1;
    state.root.className = mergeClasses(state.root.className, selected && activeIndicatorStyles.base, selected && animating && activeIndicatorStyles.animated, selected && (vertical ? activeIndicatorStyles.vertical : activeIndicatorStyles.horizontal));
    const rootCssVars = {
      [tabIndicatorCssVars_unstable.offsetVar]: `${animationValues.offset}px`,
      [tabIndicatorCssVars_unstable.scaleVar]: `${animationValues.scale}`
    };
    state.root.style = {
      ...rootCssVars,
      ...state.root.style
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTabStyles.styles.js
  var tabClassNames = {
    root: "fui-Tab",
    icon: "fui-Tab__icon",
    content: "fui-Tab__content"
  };
  var reservedSpaceClassNames = {
    content: "fui-Tab__content--reserved-space"
  };
  var useRootStyles7 = /* @__PURE__ */ __styles2({
    root: {
      Bt984gj: "f122n59",
      mc9l5x: "f13qh94s",
      Bnnss6s: "fi64zpg",
      Bxotwcr: "f1u07yai",
      Budl1dq: "frn2hmy",
      wkccdc: "f1olsevy",
      oeaueh: "f1s6fcnf",
      qhf8xq: "f10pi13n"
    },
    button: {
      Bt984gj: "f122n59",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f3bhgqh",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      Bceei9c: "f1k6fduh",
      mc9l5x: "f13qh94s",
      Bnnss6s: "fi64zpg",
      Bxotwcr: "f1u07yai",
      Budl1dq: "frn2hmy",
      wkccdc: "f1olsevy",
      Bahqtrf: "fk6fouc",
      Bg96gwp: "f1i3iumi",
      oeaueh: "f1s6fcnf",
      qhf8xq: "f10pi13n",
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1a3p1vp",
      B9bfxx9: "f1cxpek8"
    },
    horizontal: {
      Brf1p80: "f4d9j23"
    },
    vertical: {
      Brf1p80: "f1s9ku6b"
    },
    smallHorizontal: {
      i8kkvl: "f14mj54c",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1wmopi4"
    },
    smallVertical: {
      i8kkvl: "f14mj54c",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f12or63q"
    },
    mediumHorizontal: {
      i8kkvl: "f1rjii52",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1w08f2p"
    },
    mediumVertical: {
      i8kkvl: "f1rjii52",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fymxs25"
    },
    largeHorizontal: {
      i8kkvl: "f1rjii52",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1ssfvub"
    },
    largeVertical: {
      i8kkvl: "f1rjii52",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fwkd1rq"
    },
    transparent: {
      De3pzq: "f1c21dwh",
      B95qlz1: "f9rvdkv",
      B7xitij: "f1051ucx",
      Bptxc3x: "fmmjozx",
      Bwqhzpy: "fqhzt5g",
      iyk698: "f7l5cgy",
      cl4aha: "fpkze5g",
      B0q3jbp: "f1iywnoi",
      Be9ayug: "f9n45c4"
    },
    subtle: {
      De3pzq: "fhovq9v",
      B95qlz1: "f1bifk9c",
      B7xitij: "fo6hitd",
      Bptxc3x: "fmmjozx",
      Bwqhzpy: "fqhzt5g",
      iyk698: "f7l5cgy",
      cl4aha: "fpkze5g",
      B0q3jbp: "f1iywnoi",
      Be9ayug: "f9n45c4"
    },
    disabledCursor: {
      Bceei9c: "fdrzuqr"
    },
    disabled: {
      De3pzq: "f1c21dwh",
      Bptxc3x: "fato7r6",
      cl4aha: "fao1bnu"
    },
    selected: {
      Bptxc3x: "f1cadz5z",
      Bwqhzpy: "fwhdxxj",
      iyk698: "fintccb",
      cl4aha: "ffplhdr",
      B0q3jbp: "fjo17wb",
      Be9ayug: "f148789c"
    }
  }, {
    d: [".f122n59{align-items:center;}", ".f13qh94s{display:grid;}", ".fi64zpg{flex-shrink:0;}", ".f1u07yai{grid-auto-flow:column;}", ".frn2hmy{grid-template-columns:auto;}", ".f1olsevy{grid-template-rows:auto;}", ".f1s6fcnf{outline-style:none;}", ".f10pi13n{position:relative;}", [".f3bhgqh{border:none;}", {
      p: -2
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1a3p1vp{overflow:hidden;}", {
      p: -1
    }], ".f1cxpek8{text-transform:none;}", ".f4d9j23{justify-content:center;}", ".f1s9ku6b{justify-content:start;}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", [".f1wmopi4{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalSNudge);}", {
      p: -1
    }], [".f12or63q{padding:var(--spacingVerticalXXS) var(--spacingHorizontalSNudge);}", {
      p: -1
    }], ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", [".f1w08f2p{padding:var(--spacingVerticalM) var(--spacingHorizontalMNudge);}", {
      p: -1
    }], [".fymxs25{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalMNudge);}", {
      p: -1
    }], [".f1ssfvub{padding:var(--spacingVerticalL) var(--spacingHorizontalMNudge);}", {
      p: -1
    }], [".fwkd1rq{padding:var(--spacingVerticalS) var(--spacingHorizontalMNudge);}", {
      p: -1
    }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f9rvdkv:enabled:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f1051ucx:enabled:active{background-color:var(--colorTransparentBackgroundPressed);}", ".fmmjozx .fui-Tab__icon{color:var(--colorNeutralForeground2);}", ".fqhzt5g:enabled:hover .fui-Tab__icon{color:var(--colorNeutralForeground2Hover);}", ".f7l5cgy:enabled:active .fui-Tab__icon{color:var(--colorNeutralForeground2Pressed);}", ".fpkze5g .fui-Tab__content{color:var(--colorNeutralForeground2);}", ".f1iywnoi:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground2Hover);}", ".f9n45c4:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground2Pressed);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", ".fdrzuqr{cursor:not-allowed;}", ".fato7r6 .fui-Tab__icon{color:var(--colorNeutralForegroundDisabled);}", ".fao1bnu .fui-Tab__content{color:var(--colorNeutralForegroundDisabled);}", ".f1cadz5z .fui-Tab__icon{color:var(--colorCompoundBrandForeground1);}", ".fwhdxxj:enabled:hover .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Hover);}", ".fintccb:enabled:active .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Pressed);}", ".ffplhdr .fui-Tab__content{color:var(--colorNeutralForeground1);}", ".fjo17wb:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground1Hover);}", ".f148789c:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground1Pressed);}"]
  });
  var useCircularAppearanceStyles = /* @__PURE__ */ __styles2({
    base: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f44lkw9",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fp7rvkm",
      Bptxc3x: "ftorr8m",
      cl4aha: "f16lqpmv"
    },
    medium: {
      Dbcxam: 0,
      rjzwhg: 0,
      Bblux5w: "f1lj1ynd"
    },
    subtle: {
      De3pzq: "fhovq9v",
      sj55zd: "fkfq4zb",
      B95qlz1: "f1bifk9c",
      Eo63ln: 0,
      r9osk6: 0,
      Itrz8y: 0,
      zeg6vx: 0,
      l65xgk: 0,
      Bw4olcx: 0,
      Folb0i: 0,
      I2h8y4: 0,
      Bgxgoyi: 0,
      Bvlkotb: 0,
      Fwyncl: 0,
      Byh5edv: 0,
      Becqvjq: 0,
      uumbiq: 0,
      B73q3dg: 0,
      Bblwbaf: 0,
      B0ezav: "ft57sj0",
      r4wkhp: "f1fcoy83",
      B7xitij: "fo6hitd",
      d3wsvi: 0,
      Hdqn7s: 0,
      zu5y1p: 0,
      owqphb: 0,
      g9c53k: 0,
      Btmu08z: 0,
      Bthxvy6: 0,
      gluvuq: 0,
      tb88gp: 0,
      wns6jk: 0,
      kdfdk4: 0,
      Bbw008l: 0,
      Bayi1ib: 0,
      B1kkfu3: 0,
      J1oqyp: 0,
      kem6az: 0,
      goa3yj: "fhn220o",
      p743kt: "f15qf7sh",
      uu68id: 0,
      Bxeuatn: 0,
      felo30: 0,
      Bc736ss: 0,
      Bhz882k: 0,
      n51gp8: 0,
      Eshu5l: 0,
      Bk6ri7n: 0,
      v49c4f: 0,
      Bn1d65q: 0,
      c4eypz: 0,
      v3aym: 0,
      hft9gk: 0,
      Bjwas2f: 0,
      Bk5ld8o: 0,
      gwxt9v: 0,
      B6k8go: "f130w16x"
    },
    subtleSelected: {
      De3pzq: "f16xkysk",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f1c2pc3t",
      sj55zd: "faj9fo0",
      B95qlz1: "fsm7zmf",
      Eo63ln: 0,
      r9osk6: 0,
      Itrz8y: 0,
      zeg6vx: 0,
      l65xgk: 0,
      Bw4olcx: 0,
      Folb0i: 0,
      I2h8y4: 0,
      Bgxgoyi: 0,
      Bvlkotb: 0,
      Fwyncl: 0,
      Byh5edv: 0,
      Becqvjq: 0,
      uumbiq: 0,
      B73q3dg: 0,
      Bblwbaf: 0,
      B0ezav: "f1wo0sfq",
      r4wkhp: "f1afuynh",
      B7xitij: "f94ddyl",
      d3wsvi: 0,
      Hdqn7s: 0,
      zu5y1p: 0,
      owqphb: 0,
      g9c53k: 0,
      Btmu08z: 0,
      Bthxvy6: 0,
      gluvuq: 0,
      tb88gp: 0,
      wns6jk: 0,
      kdfdk4: 0,
      Bbw008l: 0,
      Bayi1ib: 0,
      B1kkfu3: 0,
      J1oqyp: 0,
      kem6az: 0,
      goa3yj: "fmle6oo",
      p743kt: "f1d3itm4",
      uu68id: 0,
      Bxeuatn: 0,
      felo30: 0,
      Bc736ss: 0,
      Bhz882k: 0,
      n51gp8: 0,
      Eshu5l: 0,
      Bk6ri7n: 0,
      v49c4f: 0,
      Bn1d65q: 0,
      c4eypz: 0,
      v3aym: 0,
      hft9gk: 0,
      Bjwas2f: 0,
      Bk5ld8o: 0,
      gwxt9v: 0,
      B6k8go: "f19qjb1h"
    },
    subtleDisabled: {
      De3pzq: "fhovq9v",
      sj55zd: "f1s2aq7o"
    },
    subtleDisabledSelected: {
      De3pzq: "f1bg9a2p",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fegtqic",
      sj55zd: "f1s2aq7o"
    },
    filled: {
      De3pzq: "f16xq7d1",
      sj55zd: "fkfq4zb",
      B95qlz1: "fwwxidx",
      r4wkhp: "f1fcoy83",
      B7xitij: "f14i52sd",
      p743kt: "f15qf7sh",
      Bw5j0gk: "f159yq2d",
      Baikq8m: "ful0ncq",
      B2ndh17: "f2rulcp",
      w0x64w: "f19p5z4e",
      Bdzpij4: "fo1bcu3"
    },
    filledSelected: {
      De3pzq: "ffp7eso",
      sj55zd: "f1phragk",
      B95qlz1: "f1lm9dni",
      r4wkhp: "f1mn5ei1",
      B7xitij: "f1g6ncd0",
      p743kt: "fl71aob",
      bml8oc: "f13s88zn",
      qew46a: "f16zjd40",
      B84x17g: "f1mr3uue",
      Jetwu1: "f196ywdt"
    },
    filledDisabled: {
      De3pzq: "f1bg9a2p",
      sj55zd: "f1s2aq7o"
    },
    filledDisabledSelected: {
      De3pzq: "f1bg9a2p",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fegtqic",
      sj55zd: "f1s2aq7o"
    }
  }, {
    d: [[".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], [".fp7rvkm{border:solid var(--strokeWidthThin) var(--colorTransparentStroke);}", {
      p: -2
    }], ".ftorr8m .fui-Tab__icon{color:inherit;}", ".f16lqpmv .fui-Tab__content{color:inherit;}", [".f1lj1ynd{padding-block:var(--spacingVerticalSNudge);}", {
      p: -1
    }], ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", [".ft57sj0:enabled:hover{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Hover);}", {
      p: -2
    }], ".f1fcoy83:enabled:hover{color:var(--colorNeutralForeground2Hover);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", [".fhn220o:enabled:active{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Pressed);}", {
      p: -2
    }], ".f15qf7sh:enabled:active{color:var(--colorNeutralForeground2Pressed);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", [".f1c2pc3t{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStroke);}", {
      p: -2
    }], ".faj9fo0{color:var(--colorBrandForeground2);}", ".fsm7zmf:enabled:hover{background-color:var(--colorBrandBackground2Hover);}", [".f1wo0sfq:enabled:hover{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokeHover);}", {
      p: -2
    }], ".f1afuynh:enabled:hover{color:var(--colorBrandForeground2Hover);}", ".f94ddyl:enabled:active{background-color:var(--colorBrandBackground2Pressed);}", [".fmle6oo:enabled:active{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokePressed);}", {
      p: -2
    }], ".f1d3itm4:enabled:active{color:var(--colorBrandForeground2Pressed);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", [".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", {
      p: -2
    }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fwwxidx:enabled:hover{background-color:var(--colorNeutralBackground3Hover);}", ".f14i52sd:enabled:active{background-color:var(--colorNeutralBackground3Pressed);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".f1lm9dni:enabled:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1mn5ei1:enabled:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f1g6ncd0:enabled:active{background-color:var(--colorBrandBackgroundPressed);}", ".fl71aob:enabled:active{color:var(--colorNeutralForegroundOnBrand);}", [".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", {
      p: -2
    }]],
    m: [["@media (forced-colors: active){.f130w16x{border:solid var(--strokeWidthThin) Canvas;}}", {
      p: -2,
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f19qjb1h{border:solid var(--strokeWidthThin) Highlight;}}", {
      p: -2,
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f159yq2d:enabled:hover{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.ful0ncq:enabled:hover{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f2rulcp:enabled:hover .fui-Tab__content{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f19p5z4e:enabled:hover .fui-Icon-filled{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fo1bcu3:enabled:hover .fui-Icon-regular{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f13s88zn:enabled{background-color:ButtonText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f16zjd40:enabled .fui-Tab__content{color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1mr3uue:enabled .fui-Tab__content{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f196ywdt:enabled .fui-Tab__icon{color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useFocusStyles = /* @__PURE__ */ __styles2({
    base: {
      B8q5s1w: "f8hki3x",
      Bci5o5g: ["f1d2448m", "ffh67wi"],
      n8qw10: "f1bjia2o",
      Bdrgwmp: ["ffh67wi", "f1d2448m"],
      Bn4voq9: "f1p7hgxw",
      Bfpq7zp: "f1way5bb",
      g9k6zt: "f9znhxp",
      j6ew2k: ["fqa318h", "fqa318h"],
      Bhxq17a: "f1vjpng2"
    },
    circular: {
      B8q5s1w: "f8hki3x",
      Bci5o5g: ["f1d2448m", "ffh67wi"],
      n8qw10: "f1bjia2o",
      Bdrgwmp: ["ffh67wi", "f1d2448m"],
      Bn4voq9: "f1p7hgxw",
      Bfpq7zp: "f1way5bb",
      g9k6zt: "f9znhxp",
      j6ew2k: ["fzgyhws", "fqxug60"],
      Bhxq17a: "f1vjpng2"
    }
  }, {
    d: [".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".f1p7hgxw[data-fui-focus-visible]{outline-width:var(--strokeWidthThick);}", ".f1way5bb[data-fui-focus-visible]{outline-color:transparent;}", ".f9znhxp[data-fui-focus-visible]{outline-style:solid;}", ".fqa318h[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2);}", ".f1vjpng2[data-fui-focus-visible]{z-index:1;}", ".fzgyhws[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}", ".fqxug60[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}"]
  });
  var usePendingIndicatorStyles = /* @__PURE__ */ __styles2({
    base: {
      az7l2e: "fhw179n",
      vqofr: 0,
      Bv4n3vi: 0,
      Bgqb9hq: 0,
      B0uxbk8: 0,
      Bf3jju6: "fg9j5n4",
      amg5m6: "f1kmhr4c",
      zkfqfm: "fl1ydde",
      Bkydozb: "f1y7maxz",
      Bka2azo: 0,
      vzq8l0: 0,
      csmgbd: 0,
      Br4ovkg: 0,
      aelrif: "fceyvr4",
      y36c18: "f16cxu0",
      B1ctymy: "f1nwgacf",
      Bgvrrv0: "f15ovonk",
      ddr6p5: "fvje46l"
    },
    disabled: {
      az7l2e: "f1ut20fw",
      Bkydozb: "fhrzcfn",
      Bgvrrv0: "f1v15rkt",
      ddr6p5: "f3nwrnk"
    },
    smallHorizontal: {
      lawp4y: "fchca7p",
      Baz25je: "f1r53b5e",
      Fbdkly: ["f1s6rxz5", "fo35v8s"],
      mdwyqc: ["fo35v8s", "f1s6rxz5"]
    },
    smallVertical: {
      lawp4y: "fze4zud",
      Fbdkly: ["f1fzr1x6", "f1f351id"],
      Bciustq: "fdp32p8",
      Ccq8qp: "f1aij3q"
    },
    mediumHorizontal: {
      lawp4y: "fchca7p",
      Baz25je: "f1s2r9ax",
      Fbdkly: ["f1o0nnkk", "fxb7rol"],
      mdwyqc: ["fxb7rol", "f1o0nnkk"]
    },
    mediumVertical: {
      lawp4y: "f17jracn",
      Fbdkly: ["f1fzr1x6", "f1f351id"],
      Bciustq: "f117lcb2",
      Ccq8qp: "f1aij3q"
    },
    largeHorizontal: {
      lawp4y: "fchca7p",
      Baz25je: "f1s2r9ax",
      Fbdkly: ["f1o0nnkk", "fxb7rol"],
      mdwyqc: ["fxb7rol", "f1o0nnkk"]
    },
    largeVertical: {
      lawp4y: "fel9d3z",
      Fbdkly: ["f1fzr1x6", "f1f351id"],
      Bciustq: "f6vqlre",
      Ccq8qp: "f1aij3q"
    }
  }, {
    h: [".fhw179n:hover::before{background-color:var(--colorNeutralStroke1Hover);}", [".fg9j5n4:hover::before{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], '.f1kmhr4c:hover::before{content:"";}', ".fl1ydde:hover::before{position:absolute;}", ".f1ut20fw:hover::before{background-color:var(--colorTransparentStroke);}"],
    a: [".f1y7maxz:active::before{background-color:var(--colorNeutralStroke1Pressed);}", [".fceyvr4:active::before{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], '.f16cxu0:active::before{content:"";}', ".f1nwgacf:active::before{position:absolute;}", ".fhrzcfn:active::before{background-color:var(--colorTransparentStroke);}"],
    m: [["@media (forced-colors: active){.f15ovonk:hover::before{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fvje46l:active::before{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1v15rkt:hover::before{background-color:transparent;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f3nwrnk:active::before{background-color:transparent;}}", {
      m: "(forced-colors: active)"
    }]],
    d: [".fchca7p::before{bottom:0;}", ".f1r53b5e::before{height:var(--strokeWidthThick);}", ".f1s6rxz5::before{left:var(--spacingHorizontalSNudge);}", ".fo35v8s::before{right:var(--spacingHorizontalSNudge);}", ".fze4zud::before{bottom:var(--spacingVerticalXS);}", ".f1fzr1x6::before{left:0;}", ".f1f351id::before{right:0;}", ".fdp32p8::before{top:var(--spacingVerticalXS);}", ".f1aij3q::before{width:var(--strokeWidthThicker);}", ".f1s2r9ax::before{height:var(--strokeWidthThicker);}", ".f1o0nnkk::before{left:var(--spacingHorizontalM);}", ".fxb7rol::before{right:var(--spacingHorizontalM);}", ".f17jracn::before{bottom:var(--spacingVerticalS);}", ".f117lcb2::before{top:var(--spacingVerticalS);}", ".fel9d3z::before{bottom:var(--spacingVerticalMNudge);}", ".f6vqlre::before{top:var(--spacingVerticalMNudge);}"]
  });
  var useActiveIndicatorStyles2 = /* @__PURE__ */ __styles2({
    base: {
      Bjyk6c5: "f1rp0jgh",
      d9w3h3: 0,
      B3778ie: 0,
      B4j8arr: 0,
      Bl18szs: 0,
      Blrzh8d: "f3b9emi",
      Bsft5z2: "f13zj6fq",
      E3zdtr: "f1mdlcz9"
    },
    selected: {
      Bjyk6c5: "f1ksivud",
      Bej4dhw: "f1476jrx",
      B7wqxwa: "f18q216b",
      f7digc: "fy7ktjt",
      Bvuzv5k: "f1033yux",
      k4sdgo: "fkh9b8o"
    },
    disabled: {
      Bjyk6c5: "f13lkzet"
    },
    smallHorizontal: {
      By385i5: "fo72kxq",
      Dlnsje: "f9bb2ob",
      Eqx8gd: ["f1q70ajw", "f18rbzdx"],
      B1piin3: ["f18rbzdx", "f1q70ajw"]
    },
    smallVertical: {
      By385i5: "fqbue9b",
      Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
      bn5sak: "fk1klkt",
      a2br6o: "f1o25lip"
    },
    mediumHorizontal: {
      By385i5: "fo72kxq",
      Dlnsje: "f1vx7lu8",
      Eqx8gd: ["fna7m5n", "f1oxpfwv"],
      B1piin3: ["f1oxpfwv", "fna7m5n"]
    },
    mediumVertical: {
      By385i5: "fipylg0",
      Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
      bn5sak: "fqchiol",
      a2br6o: "f1o25lip"
    },
    largeHorizontal: {
      By385i5: "fo72kxq",
      Dlnsje: "f1vx7lu8",
      Eqx8gd: ["fna7m5n", "f1oxpfwv"],
      B1piin3: ["f1oxpfwv", "fna7m5n"]
    },
    largeVertical: {
      By385i5: "f1w7dm5g",
      Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
      bn5sak: "f1p6em4m",
      a2br6o: "f1o25lip"
    }
  }, {
    d: [".f1rp0jgh::after{background-color:var(--colorTransparentStroke);}", [".f3b9emi::after{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1ksivud::after{background-color:var(--colorCompoundBrandStroke);}", ".f1476jrx:enabled:hover::after{background-color:var(--colorCompoundBrandStrokeHover);}", ".f18q216b:enabled:active::after{background-color:var(--colorCompoundBrandStrokePressed);}", ".f13lkzet::after{background-color:var(--colorNeutralForegroundDisabled);}", ".fo72kxq::after{bottom:0;}", ".f9bb2ob::after{height:var(--strokeWidthThick);}", ".f1q70ajw::after{left:var(--spacingHorizontalSNudge);}", ".f18rbzdx::after{right:var(--spacingHorizontalSNudge);}", ".fqbue9b::after{bottom:var(--spacingVerticalXS);}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", ".fk1klkt::after{top:var(--spacingVerticalXS);}", ".f1o25lip::after{width:var(--strokeWidthThicker);}", ".f1vx7lu8::after{height:var(--strokeWidthThicker);}", ".fna7m5n::after{left:var(--spacingHorizontalM);}", ".f1oxpfwv::after{right:var(--spacingHorizontalM);}", ".fipylg0::after{bottom:var(--spacingVerticalS);}", ".fqchiol::after{top:var(--spacingVerticalS);}", ".f1w7dm5g::after{bottom:var(--spacingVerticalMNudge);}", ".f1p6em4m::after{top:var(--spacingVerticalMNudge);}"],
    m: [["@media (forced-colors: active){.fy7ktjt::after{background-color:ButtonText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1033yux:enabled:hover::after{background-color:ButtonText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fkh9b8o:enabled:active::after{background-color:ButtonText;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useIconStyles3 = /* @__PURE__ */ __styles2({
    base: {
      Br312pm: "fwpfdsa",
      Ijaq50: "f16hsg94",
      Bt984gj: "f122n59",
      mc9l5x: "ftuwxu6",
      Brf1p80: "f4d9j23",
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1a3p1vp",
      D0sxk3: "f16u1re",
      t6yez3: "f8bsbmo"
    },
    small: {
      Be2twd7: "fe5j1ua",
      Bqenvij: "fjamq6b",
      a9b677: "f64fuq3"
    },
    medium: {
      Be2twd7: "fe5j1ua",
      Bqenvij: "fjamq6b",
      a9b677: "f64fuq3"
    },
    large: {
      Be2twd7: "f1rt2boy",
      Bqenvij: "frvgh55",
      a9b677: "fq4mcun"
    },
    selected: {
      D0sxk3: "fxoiby5",
      t6yez3: "f15q0o9g"
    }
  }, {
    d: [".fwpfdsa{grid-column-start:1;}", ".f16hsg94{grid-row-start:1;}", ".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".f4d9j23{justify-content:center;}", [".f1a3p1vp{overflow:hidden;}", {
      p: -1
    }], ".f16u1re .fui-Icon-filled{display:none;}", ".f8bsbmo .fui-Icon-regular{display:inline;}", ".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".fxoiby5 .fui-Icon-filled{display:inline;}", ".f15q0o9g .fui-Icon-regular{display:none;}"]
  });
  var useContentStyles2 = /* @__PURE__ */ __styles2({
    base: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi",
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1a3p1vp",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1bwptpd"
    },
    selected: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "f1i3iumi"
    },
    large: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "figsok6",
      Bg96gwp: "faaz57k"
    },
    largeSelected: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    noIconBefore: {
      Br312pm: "fwpfdsa",
      Ijaq50: "f16hsg94"
    },
    iconBefore: {
      Br312pm: "fd46tj4",
      Ijaq50: "f16hsg94"
    },
    placeholder: {
      Bcdw1i0: "fd7fpy0"
    }
  }, {
    d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1a3p1vp{overflow:hidden;}", {
      p: -1
    }], [".f1bwptpd{padding:var(--spacingVerticalNone) var(--spacingHorizontalXXS);}", {
      p: -1
    }], ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fwpfdsa{grid-column-start:1;}", ".f16hsg94{grid-row-start:1;}", ".fd46tj4{grid-column-start:2;}", ".fd7fpy0{visibility:hidden;}"]
  });
  var useTabStyles_unstable = (state) => {
    "use no memo";
    useTabIndicatorStyles_unstable(state);
    useTabButtonStyles_unstable(state, state.root);
    useTabContentStyles_unstable(state);
    return state;
  };
  var useTabIndicatorStyles_unstable = (state) => {
    "use no memo";
    const rootStyles = useRootStyles7();
    const pendingIndicatorStyles = usePendingIndicatorStyles();
    const activeIndicatorStyles = useActiveIndicatorStyles2();
    const {
      appearance,
      disabled,
      selected,
      size,
      vertical
    } = state;
    const classes = [tabClassNames.root, rootStyles.root];
    if (appearance !== "subtle-circular" && appearance !== "filled-circular") {
      classes.push(
        // pending indicator (before pseudo element)
        pendingIndicatorStyles.base,
        size === "small" && (vertical ? pendingIndicatorStyles.smallVertical : pendingIndicatorStyles.smallHorizontal),
        size === "medium" && (vertical ? pendingIndicatorStyles.mediumVertical : pendingIndicatorStyles.mediumHorizontal),
        size === "large" && (vertical ? pendingIndicatorStyles.largeVertical : pendingIndicatorStyles.largeHorizontal),
        disabled && pendingIndicatorStyles.disabled,
        // active indicator (after pseudo element)
        selected && activeIndicatorStyles.base,
        selected && !disabled && activeIndicatorStyles.selected,
        selected && size === "small" && (vertical ? activeIndicatorStyles.smallVertical : activeIndicatorStyles.smallHorizontal),
        selected && size === "medium" && (vertical ? activeIndicatorStyles.mediumVertical : activeIndicatorStyles.mediumHorizontal),
        selected && size === "large" && (vertical ? activeIndicatorStyles.largeVertical : activeIndicatorStyles.largeHorizontal),
        selected && disabled && activeIndicatorStyles.disabled
      );
    }
    state.root.className = mergeClasses(...classes, state.root.className);
    useTabAnimatedIndicatorStyles_unstable(state);
    return state;
  };
  var useTabButtonStyles_unstable = (state, slot) => {
    "use no memo";
    const rootStyles = useRootStyles7();
    const focusStyles = useFocusStyles();
    const circularStyles = useCircularAppearanceStyles();
    const {
      appearance,
      disabled,
      selected,
      size,
      vertical
    } = state;
    const isSubtleCircular = appearance === "subtle-circular";
    const isFilledCircular = appearance === "filled-circular";
    const isCircular = isSubtleCircular || isFilledCircular;
    const circularAppearance = [
      circularStyles.base,
      focusStyles.circular,
      // sizes
      size === "medium" && circularStyles.medium,
      // subtle-circular appearance
      isSubtleCircular && circularStyles.subtle,
      selected && isSubtleCircular && circularStyles.subtleSelected,
      disabled && isSubtleCircular && circularStyles.subtleDisabled,
      selected && disabled && isSubtleCircular && circularStyles.subtleDisabledSelected,
      // filled-circular appearance
      isFilledCircular && circularStyles.filled,
      selected && isFilledCircular && circularStyles.filledSelected,
      disabled && isFilledCircular && circularStyles.filledDisabled,
      selected && disabled && isFilledCircular && circularStyles.filledDisabledSelected
    ];
    const regularAppearance = [focusStyles.base, !disabled && appearance === "subtle" && rootStyles.subtle, !disabled && appearance === "transparent" && rootStyles.transparent, !disabled && selected && rootStyles.selected, disabled && rootStyles.disabled];
    slot.className = mergeClasses(
      rootStyles.button,
      // orientation
      vertical ? rootStyles.vertical : rootStyles.horizontal,
      // size
      size === "small" && (vertical ? rootStyles.smallVertical : rootStyles.smallHorizontal),
      size === "medium" && (vertical ? rootStyles.mediumVertical : rootStyles.mediumHorizontal),
      size === "large" && (vertical ? rootStyles.largeVertical : rootStyles.largeHorizontal),
      ...isCircular ? circularAppearance : regularAppearance,
      disabled && rootStyles.disabledCursor,
      slot.className
    );
    return state;
  };
  var useTabContentStyles_unstable = (state) => {
    "use no memo";
    const iconStyles = useIconStyles3();
    const contentStyles = useContentStyles2();
    const {
      selected,
      size
    } = state;
    if (state.icon) {
      state.icon.className = mergeClasses(tabClassNames.icon, iconStyles.base, iconStyles[size], selected && iconStyles.selected, state.icon.className);
    }
    if (state.contentReservedSpace) {
      state.contentReservedSpace.className = mergeClasses(reservedSpaceClassNames.content, contentStyles.base, size === "large" ? contentStyles.largeSelected : contentStyles.selected, state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, contentStyles.placeholder, state.content.className);
      state.contentReservedSpaceClassName = state.contentReservedSpace.className;
    }
    state.content.className = mergeClasses(tabClassNames.content, contentStyles.base, size === "large" && contentStyles.large, selected && (size === "large" ? contentStyles.largeSelected : contentStyles.selected), state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, state.content.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/Tab.js
  var Tab2 = /* @__PURE__ */ React98.forwardRef((props, ref) => {
    const state = useTab_unstable(props, ref);
    useTabStyles_unstable(state);
    useCustomStyleHook("useTabStyles_unstable")(state);
    return renderTab_unstable(state);
  });
  Tab2.displayName = "Tab";

  // ../../node_modules/@fluentui/react-tabs/lib/TabList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/TabList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React100 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/useTabList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React99 = __toESM(require_react());
  var useTabList_unstable = (props, ref) => {
    const { appearance = "transparent", reserveSelectedTabSpace = true, disabled = false, onTabSelect, selectTabOnFocus = false, size = "medium", vertical = false } = props;
    const innerRef = React99.useRef(null);
    const focusAttributes = useArrowNavigationGroup({
      circular: true,
      axis: vertical ? "vertical" : "horizontal",
      memorizeCurrent: false,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      unstable_hasDefault: true
    });
    const [selectedValue, setSelectedValue] = useControllableState({
      state: props.selectedValue,
      defaultState: props.defaultSelectedValue,
      initialState: void 0
    });
    const currentSelectedValue = React99.useRef(void 0);
    const previousSelectedValue = React99.useRef(void 0);
    React99.useEffect(() => {
      previousSelectedValue.current = currentSelectedValue.current;
      currentSelectedValue.current = selectedValue;
    }, [
      selectedValue
    ]);
    const onSelect = useEventCallback((event, data2) => {
      setSelectedValue(data2.value);
      onTabSelect === null || onTabSelect === void 0 ? void 0 : onTabSelect(event, data2);
    });
    const registeredTabs = React99.useRef({});
    const onRegister = useEventCallback((data2) => {
      const key = JSON.stringify(data2.value);
      if (!key && false) {
        console.error([
          `[@fluentui/react-tabs] The value "${data2.value}" cannot be serialized to JSON string.`,
          "Tab component requires serializable values.",
          "Please provide a primitive value (string, number, boolean),",
          `or a plain object/array that doesn't contain functions, symbols, or circular references.`
        ].join(" "));
      }
      registeredTabs.current[key] = data2;
    });
    const onUnregister = useEventCallback((data2) => {
      delete registeredTabs.current[JSON.stringify(data2.value)];
    });
    const getRegisteredTabs = React99.useCallback(() => {
      return {
        selectedValue: currentSelectedValue.current,
        previousSelectedValue: previousSelectedValue.current,
        registeredTabs: registeredTabs.current
      };
    }, []);
    return {
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, innerRef),
        role: "tablist",
        "aria-orientation": vertical ? "vertical" : "horizontal",
        ...focusAttributes,
        ...props
      }), {
        elementType: "div"
      }),
      appearance,
      reserveSelectedTabSpace,
      disabled,
      selectTabOnFocus,
      selectedValue,
      size,
      vertical,
      onRegister,
      onUnregister,
      onSelect,
      getRegisteredTabs
    };
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/renderTabList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderTabList_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx(state.root, {
      children: /* @__PURE__ */ jsx(TabListProvider, {
        value: contextValues.tabList,
        children: state.root.children
      })
    });
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var tabListClassNames = {
    root: "fui-TabList"
  };
  var useStyles5 = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f22iagw",
      Beiy3e4: "f1063pyq",
      Bnnss6s: "fi64zpg",
      Eh141a: "flvyvdh",
      qhf8xq: "f10pi13n"
    },
    horizontal: {
      Bt984gj: "f1q9h2pe",
      Beiy3e4: "f1063pyq"
    },
    vertical: {
      Bt984gj: "f1q9h2pe",
      Beiy3e4: "f1vx9l62"
    },
    roundedSmall: {
      i8kkvl: 0,
      Belr9w4: 0,
      rmohyg: "f1eyhf9v"
    },
    rounded: {
      i8kkvl: 0,
      Belr9w4: 0,
      rmohyg: "faqewft"
    }
  }, {
    d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".fi64zpg{flex-shrink:0;}", ".flvyvdh{flex-wrap:nowrap;}", ".f10pi13n{position:relative;}", ".f1q9h2pe{align-items:stretch;}", ".f1vx9l62{flex-direction:column;}", [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
      p: -1
    }], [".faqewft{gap:var(--spacingHorizontalS);}", {
      p: -1
    }]]
  });
  var useTabListStyles_unstable = (state) => {
    "use no memo";
    const {
      appearance,
      vertical,
      size
    } = state;
    const styles2 = useStyles5();
    const isRounded = appearance === "subtle-circular" || appearance === "filled-circular";
    state.root.className = mergeClasses(tabListClassNames.root, styles2.root, vertical ? styles2.vertical : styles2.horizontal, isRounded && (size === "small" ? styles2.roundedSmall : styles2.rounded), state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function useTabListContextValues_unstable(state) {
    const { appearance, reserveSelectedTabSpace, disabled, selectTabOnFocus, selectedValue: selectedKey, onRegister, onUnregister, onSelect, getRegisteredTabs, size, vertical } = state;
    const tabList = {
      appearance,
      reserveSelectedTabSpace,
      disabled,
      selectTabOnFocus,
      selectedValue: selectedKey,
      onSelect,
      onRegister,
      onUnregister,
      getRegisteredTabs,
      size,
      vertical
    };
    return {
      tabList
    };
  }

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/TabList.js
  var TabList = /* @__PURE__ */ React100.forwardRef((props, ref) => {
    const state = useTabList_unstable(props, ref);
    const contextValues = useTabListContextValues_unstable(state);
    useTabListStyles_unstable(state);
    useCustomStyleHook("useTabListStyles_unstable")(state);
    return renderTabList_unstable(state, contextValues);
  });
  TabList.displayName = "TabList";

  // ../../node_modules/@fluentui/react-textarea/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-textarea/lib/Textarea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/Textarea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React102 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/renderTextarea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderTextarea_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx(state.root, {
      children: /* @__PURE__ */ jsx(state.textarea, {})
    });
  };

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextarea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React101 = __toESM(require_react());
  var useTextarea_unstable = (props, ref) => {
    props = useFieldControlProps_unstable(props, {
      supportsLabelFor: true,
      supportsRequired: true,
      supportsSize: true
    });
    const overrides = useOverrides();
    var _overrides_inputDefaultAppearance;
    const { size = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", resize = "none", onChange } = props;
    if (false) {
      console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
    }
    const [value, setValue] = useControllableState({
      state: props.value,
      defaultState: props.defaultValue,
      initialState: void 0
    });
    const nativeProps = getPartitionedNativeProps({
      props,
      primarySlotTagName: "textarea",
      excludedPropNames: [
        "onChange",
        "value",
        "defaultValue"
      ]
    });
    const state = {
      size,
      appearance,
      resize,
      components: {
        root: "span",
        textarea: "textarea"
      },
      textarea: slot_exports.always(props.textarea, {
        defaultProps: {
          ref,
          ...nativeProps.primary
        },
        elementType: "textarea"
      }),
      root: slot_exports.always(props.root, {
        defaultProps: nativeProps.root,
        elementType: "span"
      })
    };
    state.textarea.value = value;
    state.textarea.onChange = useEventCallback((ev) => {
      const newValue = ev.target.value;
      onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
        value: newValue
      });
      setValue(newValue);
    });
    return state;
  };

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextareaStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var textareaClassNames = {
    root: "fui-Textarea",
    textarea: "fui-Textarea__textarea"
  };
  var useRootStyles8 = /* @__PURE__ */ __styles2({
    base: {
      mc9l5x: "ftuwxu6",
      B7ck84d: "f1ewtqcl",
      qhf8xq: "f10pi13n",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1yiegib",
      jrapky: 0,
      Frg6f3: 0,
      t21cq0: 0,
      B6of3ja: 0,
      B74szlk: "f1s184ao",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      ha4doy: "f12kltsn"
    },
    disabled: {
      De3pzq: "f1c21dwh",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "ff3nzm7",
      Bjwas2f: "fg455y9",
      Bn1d65q: ["f1rvyvqg", "f14g86mu"],
      Bxeuatn: "f1cwzwz",
      n51gp8: ["f14g86mu", "f1rvyvqg"]
    },
    interactive: {
      li1rpt: "f1gw3sf2",
      Bsft5z2: "f13zj6fq",
      E3zdtr: "f1mdlcz9",
      Eqx8gd: ["f1a7op3", "f1cjjd47"],
      By385i5: "f1gboi2j",
      B1piin3: ["f1cjjd47", "f1a7op3"],
      Dlnsje: "ffyw7fx",
      d9w3h3: ["f1kp91vd", "f1ibwz09"],
      B3778ie: ["f1ibwz09", "f1kp91vd"],
      B1q35kw: 0,
      Bw17bha: 0,
      Bcgy8vk: 0,
      Bjuhk93: "f1mnjydx",
      Gjdm7m: "fj2g8qd",
      b1kco5: "f1yk9hq",
      Ba2ppi3: "fhwpy7i",
      F2fol1: "f14ee0xe",
      lck23g: "f1xhbsuh",
      df92cz: "fv8e3ye",
      I188md: "ftb5wc6",
      umuwi5: "fjw5xc1",
      Blcqepd: "f1xdyd5c",
      nplu4u: "fatpbeo",
      Bioka5o: "fb7uyps",
      H713fs: "f1cmft4k",
      B9ooomg: "f1x58t8o",
      Bercvud: "f1ibeo51",
      Bbr2w1p: "f1vnc8sk",
      Bduesf4: "f3e99gv",
      Bpq79vn: "fhljsf7"
    },
    filled: {
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f88035w",
      q7v0qe: "ftmjh5b",
      kmh5ft: ["f17blpuu", "fsrcdbj"],
      nagaa4: "f1tpwn32",
      B1yhkcb: ["fsrcdbj", "f17blpuu"]
    },
    "filled-darker": {
      De3pzq: "f16xq7d1"
    },
    "filled-lighter": {
      De3pzq: "fxugw4r"
    },
    "filled-darker-shadow": {
      De3pzq: "f16xq7d1",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f1gmd7mu",
      E5pizo: "fyed02w"
    },
    "filled-lighter-shadow": {
      De3pzq: "fxugw4r",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f1gmd7mu",
      E5pizo: "fyed02w"
    },
    outline: {
      De3pzq: "fxugw4r",
      Bgfg5da: 0,
      B9xav0g: "f1c1zstj",
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fhz96rm"
    },
    outlineInteractive: {
      kzujx5: 0,
      oetu4i: "f1l4zc64",
      gvrnp0: 0,
      xv9156: 0,
      jek2p4: 0,
      gg5e9n: 0,
      Beu9t3s: 0,
      dt87k2: 0,
      Bt1vbvt: 0,
      Bwzppfd: 0,
      Bop6t4b: 0,
      B2zwrfe: 0,
      Bwp2tzp: 0,
      Bgoe8wy: 0,
      Bf40cpq: 0,
      ckks6v: 0,
      Baalond: "f9mts5e",
      v2iqwr: 0,
      wmxk5l: "f1z0osm6",
      Bj33j0h: 0,
      Bs0cc2w: 0,
      qwjtx1: 0,
      B50zh58: 0,
      f7epvg: 0,
      e1hlit: 0,
      B7mkhst: 0,
      ak43y8: 0,
      Bbcopvn: 0,
      Bvecx4l: 0,
      lwioe0: 0,
      B6oc9vd: 0,
      e2sjt0: 0,
      uqwnxt: 0,
      asj8p9: "f1acnei2",
      Br8fjdy: 0,
      zoxjo1: "f1so894s",
      Bt3ojkv: 0,
      B7pmvfx: 0,
      Bfht2n1: 0,
      an54nd: 0,
      t1ykpo: 0,
      Belqbek: 0,
      bbt1vd: 0,
      Brahy3i: 0,
      r7b1zc: 0,
      rexu52: 0,
      ovtnii: 0,
      Bvq3b66: 0,
      Bawrxx6: 0,
      Bbs6y8j: 0,
      B2qpgjt: "f19ezbcq"
    },
    invalid: {
      tvckwq: "fs4k3qj",
      gk2u95: ["fcee079", "fmyw78r"],
      hhx65j: "f1fgmyf4",
      Bxowmz0: ["fmyw78r", "fcee079"]
    }
  }, {
    d: [".ftuwxu6{display:inline-flex;}", ".f1ewtqcl{box-sizing:border-box;}", ".f10pi13n{position:relative;}", [".f1yiegib{padding:0 0 var(--strokeWidthThick) 0;}", {
      p: -1
    }], [".f1s184ao{margin:0;}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".f12kltsn{vertical-align:top;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".ff3nzm7{border:var(--strokeWidthThin) solid var(--colorNeutralStrokeDisabled);}", {
      p: -2
    }], ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".ffyw7fx::after{height:max(var(--strokeWidthThick), var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
      p: -1
    }], ".fj2g8qd::after{clip-path:inset(calc(100% - var(--strokeWidthThick)) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
      p: -2
    }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", {
      p: -2
    }], ".fyed02w{box-shadow:var(--shadow2);}", [".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", {
      p: -2
    }], [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
      p: -2
    }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}"],
    m: [["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.fv8e3ye::after{transition-duration:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.ftb5wc6::after{transition-delay:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.f1cmft4k:focus-within::after{transition-duration:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.f1x58t8o:focus-within::after{transition-delay:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }]],
    w: [".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1vnc8sk:focus-within{outline-width:var(--strokeWidthThick);}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", [".f19ezbcq:focus-within{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", {
      p: -2
    }], ".f1so894s:focus-within{border-bottom-color:var(--colorCompoundBrandStroke);}"],
    h: [".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}", [".f9mts5e:hover{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Hover);}", {
      p: -2
    }], ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
    a: [[".f1acnei2:active{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", {
      p: -2
    }], ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
  });
  var useTextareaStyles = /* @__PURE__ */ __styles2({
    base: {
      icvyot: "f1ern45e",
      vrafjx: ["f1n71otn", "f1deefiw"],
      oivjwe: "f1h8hb77",
      wvpqe5: ["f1deefiw", "f1n71otn"],
      jrapky: 0,
      Frg6f3: 0,
      t21cq0: 0,
      B6of3ja: 0,
      B74szlk: "f1s184ao",
      De3pzq: "f3rmtva",
      B7ck84d: "f1ewtqcl",
      sj55zd: "f19n0e5",
      Bh6795r: "fqerorx",
      Bahqtrf: "fk6fouc",
      Bqenvij: "f1l02sjl",
      yvdlaj: "fwyc1cq",
      B3o7kgh: "f13ta7ih",
      B4brmom: "f1vw9udw",
      Brrnbx2: "fbb3kq8",
      oeaueh: "f1s6fcnf"
    },
    disabled: {
      sj55zd: "f1s2aq7o",
      Bceei9c: "fdrzuqr",
      yvdlaj: "fahhnxm"
    },
    small: {
      sshi5w: "f1w5jphr",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1pnffij",
      Bxyxcbc: "f192z54u",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fy9rknc",
      Bhrd7zp: "figsok6",
      Bg96gwp: "fwrc4pm"
    },
    medium: {
      sshi5w: "fvmd9f",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1ww82xo",
      Bxyxcbc: "f1if7ixc",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    large: {
      sshi5w: "f1kfson",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f15hvtkj",
      Bxyxcbc: "f3kip1f",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "figsok6",
      Bg96gwp: "faaz57k"
    }
  }, {
    d: [".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", [".f1s184ao{margin:0;}", {
      p: -1
    }], ".f3rmtva{background-color:transparent;}", ".f1ewtqcl{box-sizing:border-box;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fqerorx{flex-grow:1;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1l02sjl{height:100%;}", ".fwyc1cq::-webkit-input-placeholder{color:var(--colorNeutralForeground4);}", ".fwyc1cq::-moz-placeholder{color:var(--colorNeutralForeground4);}", ".f13ta7ih::-webkit-input-placeholder{opacity:1;}", ".f13ta7ih::-moz-placeholder{opacity:1;}", ".f1vw9udw::selection{color:var(--colorNeutralForegroundInverted);}", ".fbb3kq8::selection{background-color:var(--colorNeutralBackgroundInverted);}", ".f1s6fcnf{outline-style:none;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".f1w5jphr{min-height:40px;}", [".f1pnffij{padding:var(--spacingVerticalXS) calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".f192z54u{max-height:200px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fvmd9f{min-height:52px;}", [".f1ww82xo{padding:var(--spacingVerticalSNudge) calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".f1if7ixc{max-height:260px;}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1kfson{min-height:64px;}", [".f15hvtkj{padding:var(--spacingVerticalS) calc(var(--spacingHorizontalM) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".f3kip1f{max-height:320px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
  });
  var useTextareaResizeStyles = /* @__PURE__ */ __styles2({
    none: {
      B3rzk8w: "f1o1s39h"
    },
    both: {
      B3rzk8w: "f1pxm0xe"
    },
    horizontal: {
      B3rzk8w: "fq6nmtn"
    },
    vertical: {
      B3rzk8w: "f1f5ktr4"
    }
  }, {
    d: [".f1o1s39h{resize:none;}", ".f1pxm0xe{resize:both;}", ".fq6nmtn{resize:horizontal;}", ".f1f5ktr4{resize:vertical;}"]
  });
  var useTextareaStyles_unstable = (state) => {
    "use no memo";
    const {
      size,
      appearance,
      resize
    } = state;
    const disabled = state.textarea.disabled;
    const invalid = `${state.textarea["aria-invalid"]}` === "true";
    const filled = appearance.startsWith("filled");
    const rootStyles = useRootStyles8();
    state.root.className = mergeClasses(textareaClassNames.root, rootStyles.base, disabled && rootStyles.disabled, !disabled && filled && rootStyles.filled, !disabled && rootStyles[appearance], !disabled && rootStyles.interactive, !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && invalid && rootStyles.invalid, state.root.className);
    const textareaStyles = useTextareaStyles();
    const textareaResizeStyles = useTextareaResizeStyles();
    state.textarea.className = mergeClasses(textareaClassNames.textarea, textareaStyles.base, textareaStyles[size], textareaResizeStyles[resize], disabled && textareaStyles.disabled, state.textarea.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/Textarea.js
  var Textarea = /* @__PURE__ */ React102.forwardRef((props, ref) => {
    const state = useTextarea_unstable(props, ref);
    useTextareaStyles_unstable(state);
    useCustomStyleHook("useTextareaStyles_unstable")(state);
    return renderTextarea_unstable(state);
  });
  Textarea.displayName = "Textarea";

  // ../../node_modules/@fluentui/react-dialog/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/Dialog.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/Dialog.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React110 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialog.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React107 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/utils/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React103 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var useHTMLNoScrollStyles = /* @__PURE__ */ __resetStyles2("r6pzz3z", null, [".r6pzz3z{overflow-y:hidden;overflow-y:clip;scrollbar-gutter:stable;}"]);
  var useBodyNoScrollStyles = /* @__PURE__ */ __resetStyles2("r144vlu9", null, [".r144vlu9{overflow-y:hidden;}"]);

  // ../../node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.js
  function useDisableBodyScroll() {
    const htmlNoScrollStyles = useHTMLNoScrollStyles();
    const bodyNoScrollStyles = useBodyNoScrollStyles();
    const { targetDocument } = useFluent();
    const disableBodyScroll = React103.useCallback(() => {
      var _targetDocument_defaultView;
      if (!targetDocument) {
        return;
      }
      var _targetDocument_defaultView_innerHeight;
      const isHorizontalScrollbarVisible = (
        // When the window is a fractional height, `innerHeight` always rounds down but `clientHeight` rounds either up or down depending on the value.
        // To properly compare the body clientHeight to the window innerHeight, manually round down the fractional value to match innerHeight's calculation.
        Math.floor(targetDocument.body.getBoundingClientRect().height) > ((_targetDocument_defaultView_innerHeight = (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.innerHeight) !== null && _targetDocument_defaultView_innerHeight !== void 0 ? _targetDocument_defaultView_innerHeight : 0)
      );
      if (!isHorizontalScrollbarVisible) {
        return;
      }
      targetDocument.documentElement.classList.add(htmlNoScrollStyles);
      targetDocument.body.classList.add(bodyNoScrollStyles);
      return;
    }, [
      targetDocument,
      htmlNoScrollStyles,
      bodyNoScrollStyles
    ]);
    const enableBodyScroll = React103.useCallback(() => {
      if (!targetDocument) {
        return;
      }
      targetDocument.documentElement.classList.remove(htmlNoScrollStyles);
      targetDocument.body.classList.remove(bodyNoScrollStyles);
    }, [
      targetDocument,
      htmlNoScrollStyles,
      bodyNoScrollStyles
    ]);
    return {
      disableBodyScroll,
      enableBodyScroll
    };
  }

  // ../../node_modules/@fluentui/react-dialog/lib/utils/useFocusFirstElement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React104 = __toESM(require_react());
  function useFocusFirstElement(open, modalType) {
    const { findFirstFocusable } = useFocusFinders();
    const { targetDocument } = useFluent();
    const dialogRef = React104.useRef(null);
    React104.useEffect(() => {
      if (!open) {
        return;
      }
      const element = dialogRef.current && findFirstFocusable(dialogRef.current);
      if (element) {
        element.focus();
      } else {
        var _dialogRef_current;
        (_dialogRef_current = dialogRef.current) === null || _dialogRef_current === void 0 ? void 0 : _dialogRef_current.focus();
        if (false) {
          console.warn(`@fluentui/react-dialog [useFocusFirstElement]:
A Dialog should have at least one focusable element inside DialogSurface.
Please add at least a close button either on \`DialogTitle\` action slot or inside \`DialogActions\``);
        }
      }
    }, [
      findFirstFocusable,
      open,
      modalType,
      targetDocument
    ]);
    return dialogRef;
  }

  // ../../node_modules/@fluentui/react-dialog/lib/contexts/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/contexts/dialogContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React105 = __toESM(require_react());
  var defaultContextValue = {
    open: false,
    inertTrapFocus: false,
    modalType: "modal",
    isNestedDialog: false,
    dialogRef: {
      current: null
    },
    requestOpenChange() {
    }
  };
  var DialogContext = createContext20(void 0);
  var DialogProvider = DialogContext.Provider;
  var useDialogContext_unstable = (selector) => useContextSelector(DialogContext, (ctx = defaultContextValue) => selector(ctx));

  // ../../node_modules/@fluentui/react-dialog/lib/contexts/dialogSurfaceContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React106 = __toESM(require_react());
  var defaultContextValue2 = false;
  var DialogSurfaceContext = React106.createContext(void 0);
  var DialogSurfaceProvider = DialogSurfaceContext.Provider;
  var useDialogSurfaceContext_unstable = () => {
    var _React_useContext;
    return (_React_useContext = React106.useContext(DialogSurfaceContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue2;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurfaceMotion.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var keyframes = [
    {
      opacity: 0,
      boxShadow: "0px 0px 0px 0px rgba(0, 0, 0, 0.1)",
      transform: "scale(0.85) translateZ(0)"
    },
    {
      boxShadow: tokens.shadow64,
      transform: "scale(1) translateZ(0)",
      opacity: 1
    }
  ];
  var DialogSurfaceMotion = createPresenceComponent({
    enter: {
      keyframes,
      easing: motionTokens.curveDecelerateMid,
      duration: motionTokens.durationGentle
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      easing: motionTokens.curveAccelerateMin,
      duration: motionTokens.durationGentle
    }
  });

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialog.js
  var useDialog_unstable = (props) => {
    const { children, modalType = "modal", onOpenChange, inertTrapFocus = false } = props;
    const [trigger, content] = childrenToTriggerAndContent(children);
    const [open, setOpen] = useControllableState({
      state: props.open,
      defaultState: props.defaultOpen,
      initialState: false
    });
    const requestOpenChange = useEventCallback((data2) => {
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(data2.event, data2);
      if (!data2.event.isDefaultPrevented()) {
        setOpen(data2.open);
      }
    });
    const focusRef = useFocusFirstElement(open, modalType);
    const { modalAttributes, triggerAttributes } = useModalAttributes({
      trapFocus: modalType !== "non-modal",
      legacyTrapFocus: !inertTrapFocus
    });
    const isNestedDialog = useHasParentContext(DialogContext);
    return {
      components: {
        surfaceMotion: DialogSurfaceMotion
      },
      inertTrapFocus,
      open,
      modalType,
      content,
      trigger,
      requestOpenChange,
      dialogTitleId: useId4("dialog-title-"),
      isNestedDialog,
      dialogRef: focusRef,
      modalAttributes,
      triggerAttributes,
      surfaceMotion: presenceMotionSlot(props.surfaceMotion, {
        elementType: DialogSurfaceMotion,
        defaultProps: {
          appear: true,
          visible: open,
          unmountOnExit: true
        }
      })
    };
  };
  function childrenToTriggerAndContent(children) {
    const childrenArray = React107.Children.toArray(children);
    if (false) {
      if (childrenArray.length !== 1 && childrenArray.length !== 2) {
        console.warn(`@fluentui/react-dialog [useDialog]:
Dialog must contain at least one child <DialogSurface/>,
and at most two children <DialogTrigger/> <DialogSurface/> (in this order).`);
      }
    }
    switch (childrenArray.length) {
      // case where there's a trigger followed by content
      case 2:
        return childrenArray;
      // case where there's only content
      case 1:
        return [
          void 0,
          childrenArray[0]
        ];
      // unknown case
      default:
        return [
          void 0,
          void 0
        ];
    }
  }

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/renderDialog.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React109 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/MotionRefForwarder.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React108 = __toESM(require_react());
  var MotionRefForwarderContext = /* @__PURE__ */ React108.createContext(void 0);
  function useMotionForwardedRef() {
    return React108.useContext(MotionRefForwarderContext);
  }
  var MotionRefForwarder = /* @__PURE__ */ React108.forwardRef((props, ref) => {
    return /* @__PURE__ */ React108.createElement(MotionRefForwarderContext.Provider, {
      value: ref
    }, props.children);
  });

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/renderDialog.js
  var renderDialog_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx(DialogProvider, {
      value: contextValues.dialog,
      children: /* @__PURE__ */ jsxs(DialogSurfaceProvider, {
        value: contextValues.dialogSurface,
        children: [
          state.trigger,
          state.content && /* @__PURE__ */ jsx(state.surfaceMotion, {
            children: /* @__PURE__ */ jsx(MotionRefForwarder, {
              children: state.content
            })
          })
        ]
      })
    });
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialogContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function useDialogContextValues_unstable(state) {
    const { modalType, open, dialogRef, dialogTitleId, isNestedDialog, inertTrapFocus, requestOpenChange, modalAttributes, triggerAttributes } = state;
    const dialog = {
      open,
      modalType,
      dialogRef,
      dialogTitleId,
      isNestedDialog,
      inertTrapFocus,
      modalAttributes,
      triggerAttributes,
      requestOpenChange
    };
    const dialogSurface = false;
    return {
      dialog,
      dialogSurface
    };
  }

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/Dialog.js
  var Dialog = /* @__PURE__ */ React110.memo((props) => {
    const state = useDialog_unstable(props);
    const contextValues = useDialogContextValues_unstable(state);
    return renderDialog_unstable(state, contextValues);
  });
  Dialog.displayName = "Dialog";

  // ../../node_modules/@fluentui/react-dialog/lib/DialogTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/DialogTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React112 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/useDialogTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React111 = __toESM(require_react());
  var useDialogTrigger_unstable = (props) => {
    const isInsideSurfaceDialog = useDialogSurfaceContext_unstable();
    const { children, disableButtonEnhancement = false, action = isInsideSurfaceDialog ? "close" : "open" } = props;
    const child = getTriggerChild(children);
    const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
    const { triggerAttributes } = useModalAttributes();
    const handleClick = useEventCallback((event) => {
      var _child_props_onClick, _child_props;
      child === null || child === void 0 ? void 0 : (_child_props_onClick = (_child_props = child.props).onClick) === null || _child_props_onClick === void 0 ? void 0 : _child_props_onClick.call(_child_props, event);
      if (!event.isDefaultPrevented()) {
        requestOpenChange({
          event,
          type: "triggerClick",
          open: action === "open"
        });
      }
    });
    const triggerChildProps = {
      ...child === null || child === void 0 ? void 0 : child.props,
      ref: child === null || child === void 0 ? void 0 : child.ref,
      onClick: handleClick,
      ...triggerAttributes
    };
    const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", {
      ...triggerChildProps,
      type: "button"
    });
    return {
      children: applyTriggerPropsToChildren(children, disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/renderDialogTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderDialogTrigger_unstable = (state) => state.children;

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/DialogTrigger.js
  var DialogTrigger = (props) => {
    const state = useDialogTrigger_unstable(props);
    return renderDialogTrigger_unstable(state);
  };
  DialogTrigger.displayName = "DialogTrigger";
  DialogTrigger.isFluentTriggerComponent = true;

  // ../../node_modules/@fluentui/react-dialog/lib/DialogBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/DialogBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React114 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React113 = __toESM(require_react());
  var useDialogBody_unstable = (props, ref) => {
    var _props_as;
    return {
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/renderDialogBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderDialogBody_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx(state.root, {});
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBodyStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var dialogBodyClassNames = {
    root: "fui-DialogBody"
  };
  var useResetStyles = /* @__PURE__ */ __resetStyles2("r1h3qql9", null, {
    r: [".r1h3qql9{overflow:unset;gap:8px;display:grid;max-height:calc(100vh - 2 * 24px);box-sizing:border-box;grid-template-rows:auto 1fr;grid-template-columns:1fr 1fr auto;}"],
    s: ["@media screen and (max-width: 480px){.r1h3qql9{max-width:100vw;grid-template-rows:auto 1fr auto;}}", "@media screen and (max-height: 359px){.r1h3qql9{max-height:unset;}}"]
  });
  var useDialogBodyStyles_unstable = (state) => {
    "use no memo";
    const resetStyles = useResetStyles();
    state.root.className = mergeClasses(dialogBodyClassNames.root, resetStyles, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/DialogBody.js
  var DialogBody = /* @__PURE__ */ React114.forwardRef((props, ref) => {
    const state = useDialogBody_unstable(props, ref);
    useDialogBodyStyles_unstable(state);
    useCustomStyleHook("useDialogBodyStyles_unstable")(state);
    return renderDialogBody_unstable(state);
  });
  DialogBody.displayName = "DialogBody";

  // ../../node_modules/@fluentui/react-dialog/lib/DialogTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/DialogTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React116 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React115 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitleStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var dialogTitleClassNames = {
    root: "fui-DialogTitle",
    action: "fui-DialogTitle__action"
  };
  var useRootResetStyles = /* @__PURE__ */ __resetStyles2("rxjm636", null, [".rxjm636{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase500);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase500);margin:0;grid-row-start:1;grid-row-end:1;grid-column-start:1;grid-column-end:3;}"]);
  var useStyles6 = /* @__PURE__ */ __styles2({
    rootWithoutAction: {
      Bw0ie65: "fsyjsko"
    }
  }, {
    d: [".fsyjsko{grid-column-end:4;}"]
  });
  var useActionResetStyles = /* @__PURE__ */ __resetStyles2("r13kcrze", null, [".r13kcrze{grid-row-start:1;grid-row-end:1;grid-column-start:3;justify-self:end;align-self:start;}"]);
  var useDialogTitleInternalStyles = /* @__PURE__ */ __resetStyles2("r2avt6e", "roj2bbc", {
    r: [".r2avt6e{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".r2avt6e:focus{outline-style:none;}", ".r2avt6e:focus-visible{outline-style:none;}", ".r2avt6e[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r2avt6e[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".roj2bbc{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".roj2bbc:focus{outline-style:none;}", ".roj2bbc:focus-visible{outline-style:none;}", ".roj2bbc[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.roj2bbc[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
    s: ["@media (forced-colors: active){.r2avt6e[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.roj2bbc[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
  });
  var useDialogTitleStyles_unstable = (state) => {
    "use no memo";
    const rootResetStyles = useRootResetStyles();
    const actionResetStyles = useActionResetStyles();
    const styles2 = useStyles6();
    state.root.className = mergeClasses(dialogTitleClassNames.root, rootResetStyles, !state.action && styles2.rootWithoutAction, state.root.className);
    if (state.action) {
      state.action.className = mergeClasses(dialogTitleClassNames.action, actionResetStyles, state.action.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitle.js
  var useDialogTitle_unstable = (props, ref) => {
    const { action } = props;
    const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
    const internalStyles = useDialogTitleInternalStyles();
    return {
      components: {
        root: "h2",
        action: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("h2", {
        ref,
        id: useDialogContext_unstable((ctx) => ctx.dialogTitleId),
        ...props
      }), {
        elementType: "h2"
      }),
      action: slot_exports.optional(action, {
        renderByDefault: modalType === "non-modal",
        defaultProps: {
          children: /* @__PURE__ */ React115.createElement(DialogTrigger, {
            disableButtonEnhancement: true,
            action: "close"
          }, /* @__PURE__ */ React115.createElement("button", {
            type: "button",
            className: internalStyles,
            // TODO: find a better way to add internal labels
            "aria-label": "close"
          }, /* @__PURE__ */ React115.createElement(Dismiss20Regular, null)))
        },
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/renderDialogTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderDialogTitle_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(import_react19.Fragment, {
      children: [
        /* @__PURE__ */ jsx(state.root, {
          children: state.root.children
        }),
        state.action && /* @__PURE__ */ jsx(state.action, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/DialogTitle.js
  var DialogTitle = /* @__PURE__ */ React116.forwardRef((props, ref) => {
    const state = useDialogTitle_unstable(props, ref);
    useDialogTitleStyles_unstable(state);
    useCustomStyleHook("useDialogTitleStyles_unstable")(state);
    return renderDialogTitle_unstable(state);
  });
  DialogTitle.displayName = "DialogTitle";

  // ../../node_modules/@fluentui/react-dialog/lib/DialogSurface.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/DialogSurface.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React118 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurface.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React117 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBackdropMotion.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var DialogBackdropMotion = FadeRelaxed;

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurface.js
  var useDialogSurface_unstable = (props, ref) => {
    const contextRef = useMotionForwardedRef();
    const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
    const isNestedDialog = useDialogContext_unstable((ctx) => ctx.isNestedDialog);
    const modalAttributes = useDialogContext_unstable((ctx) => ctx.modalAttributes);
    const dialogRef = useDialogContext_unstable((ctx) => ctx.dialogRef);
    const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
    const dialogTitleID = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
    const open = useDialogContext_unstable((ctx) => ctx.open);
    const handledBackdropClick = useEventCallback((event) => {
      if (isResolvedShorthand(props.backdrop)) {
        var _props_backdrop_onClick, _props_backdrop;
        (_props_backdrop_onClick = (_props_backdrop = props.backdrop).onClick) === null || _props_backdrop_onClick === void 0 ? void 0 : _props_backdrop_onClick.call(_props_backdrop, event);
      }
      if (modalType === "modal" && !event.isDefaultPrevented()) {
        requestOpenChange({
          event,
          open: false,
          type: "backdropClick"
        });
      }
    });
    const handleKeyDown = useEventCallback((event) => {
      var _props_onKeyDown;
      (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
      if (event.key === Escape && !event.isDefaultPrevented()) {
        requestOpenChange({
          event,
          open: false,
          type: "escapeKeyDown"
        });
        event.preventDefault();
      }
    });
    const backdrop = slot_exports.optional(props.backdrop, {
      renderByDefault: modalType !== "non-modal",
      defaultProps: {
        "aria-hidden": "true"
      },
      elementType: "div"
    });
    if (backdrop) {
      backdrop.onClick = handledBackdropClick;
    }
    const { disableBodyScroll, enableBodyScroll } = useDisableBodyScroll();
    useIsomorphicLayoutEffect2(() => {
      if (isNestedDialog || modalType === "non-modal") {
        return;
      }
      disableBodyScroll();
      return () => {
        enableBodyScroll();
      };
    }, [
      enableBodyScroll,
      isNestedDialog,
      disableBodyScroll,
      modalType
    ]);
    return {
      components: {
        backdrop: "div",
        root: "div",
        backdropMotion: DialogBackdropMotion
      },
      open,
      backdrop,
      isNestedDialog,
      mountNode: props.mountNode,
      root: slot_exports.always(getIntrinsicElementProps("div", {
        tabIndex: -1,
        "aria-modal": modalType !== "non-modal",
        role: modalType === "alert" ? "alertdialog" : "dialog",
        "aria-labelledby": props["aria-label"] ? void 0 : dialogTitleID,
        ...props,
        ...modalAttributes,
        onKeyDown: handleKeyDown,
        // FIXME:
        // `DialogSurfaceElement` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, contextRef, dialogRef)
      }), {
        elementType: "div"
      }),
      backdropMotion: presenceMotionSlot(props.backdropMotion, {
        elementType: DialogBackdropMotion,
        defaultProps: {
          appear: true,
          visible: open
        }
      }),
      // Deprecated properties
      transitionStatus: void 0
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/renderDialogSurface.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderDialogSurface_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(Portal, {
      mountNode: state.mountNode,
      children: [
        state.backdrop && // TODO: state.backdropMotion is non nullable, but assertSlots asserts it as nullable
        // FIXME: this should be resolved by properly splitting props and state slots declaration
        state.backdropMotion && /* @__PURE__ */ jsx(state.backdropMotion, {
          children: /* @__PURE__ */ jsx(state.backdrop, {})
        }),
        /* @__PURE__ */ jsx(DialogSurfaceProvider, {
          value: contextValues.dialogSurface,
          children: /* @__PURE__ */ jsx(state.root, {})
        })
      ]
    });
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var dialogSurfaceClassNames = {
    root: "fui-DialogSurface",
    backdrop: "fui-DialogSurface__backdrop"
  };
  var useRootBaseStyle = /* @__PURE__ */ __resetStyles2("rsmdyd3", "rup8wml", {
    r: [".rsmdyd3{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}", ".rsmdyd3:focus{outline-style:none;}", ".rsmdyd3:focus-visible{outline-style:none;}", ".rsmdyd3[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.rsmdyd3[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rup8wml{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}", ".rup8wml:focus{outline-style:none;}", ".rup8wml:focus-visible{outline-style:none;}", ".rup8wml[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rup8wml[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
    s: ["@media (forced-colors: active){.rsmdyd3[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media screen and (max-width: 480px){.rsmdyd3{max-width:100vw;}}", "@media screen and (max-height: 359px){.rsmdyd3{overflow-y:auto;padding-right:calc(24px - 4px);border-right-width:4px;border-top-width:4px;border-bottom-width:4px;}}", "@media (forced-colors: active){.rup8wml[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}", "@media screen and (max-width: 480px){.rup8wml{max-width:100vw;}}", "@media screen and (max-height: 359px){.rup8wml{overflow-y:auto;padding-left:calc(24px - 4px);border-left-width:4px;border-top-width:4px;border-bottom-width:4px;}}"]
  });
  var useBackdropBaseStyle = /* @__PURE__ */ __resetStyles2("r1e18s3l", null, [".r1e18s3l{inset:0px;background-color:var(--colorBackgroundOverlay);position:fixed;}"]);
  var useBackdropStyles = /* @__PURE__ */ __styles2({
    nestedDialogBackdrop: {
      De3pzq: "f1c21dwh"
    }
  }, {
    d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}"]
  });
  var useDialogSurfaceStyles_unstable = (state) => {
    "use no memo";
    const {
      isNestedDialog,
      root,
      backdrop
    } = state;
    const rootBaseStyle = useRootBaseStyle();
    const backdropBaseStyle = useBackdropBaseStyle();
    const backdropStyles = useBackdropStyles();
    root.className = mergeClasses(dialogSurfaceClassNames.root, rootBaseStyle, root.className);
    if (backdrop) {
      backdrop.className = mergeClasses(dialogSurfaceClassNames.backdrop, backdropBaseStyle, isNestedDialog && backdropStyles.nestedDialogBackdrop, backdrop.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function useDialogSurfaceContextValues_unstable(state) {
    const dialogSurface = true;
    return {
      dialogSurface
    };
  }

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/DialogSurface.js
  var DialogSurface = /* @__PURE__ */ React118.forwardRef((props, ref) => {
    const state = useDialogSurface_unstable(props, ref);
    const contextValues = useDialogSurfaceContextValues_unstable(state);
    useDialogSurfaceStyles_unstable(state);
    useCustomStyleHook("useDialogSurfaceStyles_unstable")(state);
    return renderDialogSurface_unstable(state, contextValues);
  });
  DialogSurface.displayName = "DialogSurface";

  // ../../node_modules/@fluentui/react-dialog/lib/DialogContent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/DialogContent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React120 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React119 = __toESM(require_react());
  var useDialogContent_unstable = (props, ref) => {
    var _props_as;
    return {
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/renderDialogContent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderDialogContent_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx(state.root, {});
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContentStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var dialogContentClassNames = {
    root: "fui-DialogContent"
  };
  var useStyles7 = /* @__PURE__ */ __resetStyles2("r1v5zwsm", null, {
    r: [".r1v5zwsm{padding:var(--strokeWidthThick);margin:calc(var(--strokeWidthThick) * -1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);overflow-y:auto;min-height:32px;box-sizing:border-box;grid-row-start:2;grid-row-end:2;grid-column-start:1;grid-column-end:4;}"],
    s: ["@media screen and (max-height: 359px){.r1v5zwsm{overflow-y:unset;}}"]
  });
  var useDialogContentStyles_unstable = (state) => {
    "use no memo";
    const styles2 = useStyles7();
    state.root.className = mergeClasses(dialogContentClassNames.root, styles2, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/DialogContent.js
  var DialogContent = /* @__PURE__ */ React120.forwardRef((props, ref) => {
    const state = useDialogContent_unstable(props, ref);
    useDialogContentStyles_unstable(state);
    useCustomStyleHook("useDialogContentStyles_unstable")(state);
    return renderDialogContent_unstable(state);
  });
  DialogContent.displayName = "DialogContent";

  // ../../node_modules/@fluentui/react-table/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-table/lib/contexts/tableContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React121 = __toESM(require_react());
  var tableContext = React121.createContext(void 0);
  var TableContextProvider = tableContext.Provider;

  // ../../node_modules/@fluentui/react-table/lib/Table.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-table/lib/components/Table/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-table/lib/components/Table/Table.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React124 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-table/lib/components/Table/useTable.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React122 = __toESM(require_react());
  var useTable_unstable = (props, ref) => {
    var _props_as;
    const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : props.noNativeElements) ? "div" : "table";
    var _props_size, _props_noNativeElements, _props_sortable;
    return {
      components: {
        root: rootComponent
      },
      root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        role: rootComponent === "div" ? "table" : void 0,
        ...props
      }), {
        elementType: rootComponent
      }),
      size: (_props_size = props.size) !== null && _props_size !== void 0 ? _props_size : "medium",
      noNativeElements: (_props_noNativeElements = props.noNativeElements) !== null && _props_noNativeElements !== void 0 ? _props_noNativeElements : false,
      sortable: (_props_sortable = props.sortable) !== null && _props_sortable !== void 0 ? _props_sortable : false
    };
  };

  // ../../node_modules/@fluentui/react-table/lib/components/Table/renderTable.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderTable_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx(TableContextProvider, {
      value: contextValues.table,
      children: /* @__PURE__ */ jsx(state.root, {})
    });
  };

  // ../../node_modules/@fluentui/react-table/lib/components/Table/useTableStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var tableClassName = "fui-Table";
  var useTableLayoutStyles = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f1w4nmp0",
      ha4doy: "fmrv4ls",
      a9b677: "fly5x3f",
      B73mfa3: "f14m3nip"
    }
  }, {
    d: [".f1w4nmp0{display:table;}", ".fmrv4ls{vertical-align:middle;}", ".fly5x3f{width:100%;}", ".f14m3nip{table-layout:fixed;}"]
  });
  var useFlexLayoutStyles = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "ftgm304"
    }
  }, {
    d: [".ftgm304{display:block;}"]
  });
  var useStyles8 = /* @__PURE__ */ __styles2({
    root: {
      po53p8: "fgkb47j",
      De3pzq: "fhovq9v"
    }
  }, {
    d: [".fgkb47j{border-collapse:collapse;}", ".fhovq9v{background-color:var(--colorSubtleBackground);}"]
  });
  var useTableStyles_unstable = (state) => {
    "use no memo";
    const styles2 = useStyles8();
    const layoutStyles = {
      table: useTableLayoutStyles(),
      flex: useFlexLayoutStyles()
    };
    state.root.className = mergeClasses(tableClassName, styles2.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-table/lib/components/Table/useTableContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React123 = __toESM(require_react());
  function useTableContextValues_unstable(state) {
    const { size, noNativeElements, sortable } = state;
    const tableContext2 = React123.useMemo(() => ({
      noNativeElements,
      size,
      sortable
    }), [
      noNativeElements,
      size,
      sortable
    ]);
    return {
      table: tableContext2
    };
  }

  // ../../node_modules/@fluentui/react-table/lib/components/Table/Table.js
  var Table = /* @__PURE__ */ React124.forwardRef((props, ref) => {
    const state = useTable_unstable(props, ref);
    useTableStyles_unstable(state);
    useCustomStyleHook("useTableStyles_unstable")(state);
    return renderTable_unstable(state, useTableContextValues_unstable(state));
  });
  Table.displayName = "Table";

  // ../../node_modules/@fluentui/react-card/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-card/lib/Card.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-card/lib/components/Card/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-card/lib/components/Card/Card.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React129 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React127 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCardSelectable.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React125 = __toESM(require_react());
  var useCardSelectable = (props, { referenceLabel, referenceId }, cardRef) => {
    const { checkbox = {}, onSelectionChange, floatingAction, onClick, onKeyDown } = props;
    const { findAllFocusable } = useFocusFinders();
    const checkboxRef = React125.useRef(null);
    const [selected, setSelected] = useControllableState({
      state: props.selected,
      defaultState: props.defaultSelected,
      initialState: false
    });
    const selectable = [
      props.selected,
      props.defaultSelected,
      onSelectionChange
    ].some((prop) => typeof prop !== "undefined");
    const [selectFocused, setSelectFocused] = React125.useState(false);
    const shouldRestrictTriggerAction = React125.useCallback((event) => {
      if (!cardRef.current) {
        return false;
      }
      const focusableElements = findAllFocusable(cardRef.current);
      const target = event.target;
      const isElementInFocusableGroup = focusableElements.some((element) => element.contains(target));
      const isCheckboxSlot = (checkboxRef === null || checkboxRef === void 0 ? void 0 : checkboxRef.current) === target;
      return isElementInFocusableGroup && !isCheckboxSlot;
    }, [
      cardRef,
      findAllFocusable
    ]);
    const onChangeHandler = React125.useCallback((event) => {
      if (shouldRestrictTriggerAction(event)) {
        return;
      }
      const newCheckedValue = !selected;
      setSelected(newCheckedValue);
      if (onSelectionChange) {
        onSelectionChange(event, {
          selected: newCheckedValue
        });
      }
    }, [
      onSelectionChange,
      selected,
      setSelected,
      shouldRestrictTriggerAction
    ]);
    const onKeyDownHandler = React125.useCallback((event) => {
      if ([
        Enter
      ].includes(event.key)) {
        event.preventDefault();
        onChangeHandler(event);
      }
    }, [
      onChangeHandler
    ]);
    const checkboxSlot = React125.useMemo(() => {
      if (!selectable || floatingAction) {
        return;
      }
      const selectableCheckboxProps = {};
      if (referenceId) {
        selectableCheckboxProps["aria-labelledby"] = referenceId;
      } else if (referenceLabel) {
        selectableCheckboxProps["aria-label"] = referenceLabel;
      }
      return slot_exports.optional(checkbox, {
        defaultProps: {
          ref: checkboxRef,
          type: "checkbox",
          checked: selected,
          onChange: (event) => onChangeHandler(event),
          onFocus: () => setSelectFocused(true),
          onBlur: () => setSelectFocused(false),
          ...selectableCheckboxProps
        },
        elementType: "input"
      });
    }, [
      checkbox,
      floatingAction,
      selected,
      selectable,
      onChangeHandler,
      referenceId,
      referenceLabel
    ]);
    const floatingActionSlot = React125.useMemo(() => {
      if (!floatingAction) {
        return;
      }
      return slot_exports.optional(floatingAction, {
        defaultProps: {
          ref: checkboxRef
        },
        elementType: "div"
      });
    }, [
      floatingAction
    ]);
    const selectableCardProps = React125.useMemo(() => {
      if (!selectable) {
        return null;
      }
      return {
        onClick: mergeCallbacks(onClick, onChangeHandler),
        onKeyDown: mergeCallbacks(onKeyDown, onKeyDownHandler)
      };
    }, [
      selectable,
      onChangeHandler,
      onClick,
      onKeyDown,
      onKeyDownHandler
    ]);
    return {
      selected,
      selectable,
      selectFocused,
      selectableCardProps,
      checkboxSlot,
      floatingActionSlot
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/CardContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React126 = __toESM(require_react());
  var cardContext = React126.createContext(void 0);
  var cardContextDefaultValue = {
    selectableA11yProps: {
      referenceId: void 0,
      setReferenceId() {
      },
      referenceLabel: void 0,
      setReferenceLabel() {
      }
    }
  };
  var CardProvider = cardContext.Provider;
  var useCardContext_unstable = () => {
    var _React_useContext;
    return (_React_useContext = React126.useContext(cardContext)) !== null && _React_useContext !== void 0 ? _React_useContext : cardContextDefaultValue;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCard.js
  var focusMap = {
    off: void 0,
    "no-tab": "limited-trap-focus",
    "tab-exit": "limited",
    "tab-only": "unlimited"
  };
  var useCardInteractive = ({ focusMode: initialFocusMode, ...props }) => {
    const interactive = [
      "onClick",
      "onDoubleClick",
      "onMouseUp",
      "onMouseDown",
      "onPointerUp",
      "onPointerDown",
      "onTouchStart",
      "onTouchEnd",
      "onDragStart",
      "onDragEnd"
    ].some((prop) => props[prop]);
    const focusMode = initialFocusMode !== null && initialFocusMode !== void 0 ? initialFocusMode : interactive ? "no-tab" : "off";
    const groupperAttrs = useFocusableGroup({
      tabBehavior: focusMap[focusMode]
    });
    const interactiveFocusAttributes = {
      ...groupperAttrs,
      tabIndex: 0
    };
    return {
      interactive,
      focusAttributes: focusMode === "off" ? null : interactiveFocusAttributes
    };
  };
  var useCard_unstable = (props, ref) => {
    const { appearance = "filled", orientation = "vertical", size = "medium" } = props;
    const [referenceId, setReferenceId] = React127.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
    const [referenceLabel, setReferenceLabel] = React127.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
    const cardBaseRef = useFocusWithin();
    const { selectable, selected, selectableCardProps, selectFocused, checkboxSlot, floatingActionSlot } = useCardSelectable(props, {
      referenceId,
      referenceLabel
    }, cardBaseRef);
    const cardRef = useMergedRefs(cardBaseRef, ref);
    const { interactive, focusAttributes } = useCardInteractive(props);
    return {
      appearance,
      orientation,
      size,
      interactive,
      selectable,
      selectFocused,
      selected,
      selectableA11yProps: {
        setReferenceId,
        referenceId,
        referenceLabel,
        setReferenceLabel
      },
      components: {
        root: "div",
        floatingAction: "div",
        checkbox: "input"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        ref: cardRef,
        role: "group",
        ...!selectable ? focusAttributes : null,
        ...props,
        ...selectableCardProps
      }), {
        elementType: "div"
      }),
      floatingAction: floatingActionSlot,
      checkbox: checkboxSlot
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/renderCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderCard_unstable = (state, cardContextValue) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx(state.root, {
      children: /* @__PURE__ */ jsxs(CardProvider, {
        value: cardContextValue,
        children: [
          state.checkbox ? /* @__PURE__ */ jsx(state.checkbox, {}) : null,
          state.floatingAction ? /* @__PURE__ */ jsx(state.floatingAction, {}) : null,
          state.root.children
        ]
      })
    });
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCardStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React128 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreviewStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var cardPreviewClassNames = {
    root: "fui-CardPreview",
    logo: "fui-CardPreview__logo"
  };
  var useStyles9 = /* @__PURE__ */ __styles2({
    root: {
      qhf8xq: "f10pi13n",
      Byfpedg: "fgourly",
      Btj6oj6: "f1vui7lx",
      B1m4t4s: "fda5zwx"
    },
    logo: {
      qhf8xq: "f1euv43f",
      B5kzvoi: "f1gcvs1y",
      oyh7mz: ["f1t6tvco", "ffrfxm3"],
      a9b677: "f1szoe96",
      Bqenvij: "f1d2rq10"
    }
  }, {
    d: [".f10pi13n{position:relative;}", ".fgourly>:not(.fui-CardPreview__logo){display:block;}", ".f1vui7lx>:not(.fui-CardPreview__logo){height:100%;}", ".fda5zwx>:not(.fui-CardPreview__logo){width:100%;}", ".f1euv43f{position:absolute;}", ".f1gcvs1y{bottom:12px;}", ".f1t6tvco{left:12px;}", ".ffrfxm3{right:12px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"]
  });
  var useCardPreviewStyles_unstable = (state) => {
    "use no memo";
    const styles2 = useStyles9();
    state.root.className = mergeClasses(cardPreviewClassNames.root, styles2.root, state.root.className);
    if (state.logo) {
      state.logo.className = mergeClasses(cardPreviewClassNames.logo, styles2.logo, state.logo.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeaderStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var cardHeaderClassNames = {
    root: "fui-CardHeader",
    image: "fui-CardHeader__image",
    header: "fui-CardHeader__header",
    description: "fui-CardHeader__description",
    action: "fui-CardHeader__action"
  };
  var useStyles10 = /* @__PURE__ */ __styles2({
    root: {
      Bkc6ea2: "fkufhic",
      Bt984gj: "f122n59"
    },
    image: {
      mc9l5x: "ftuwxu6",
      t21cq0: ["fql5097", "f6yss9k"]
    },
    header: {
      mc9l5x: "f22iagw"
    },
    description: {
      mc9l5x: "f22iagw"
    },
    action: {
      Frg6f3: ["f6yss9k", "fql5097"],
      B7frvx2: "f1ndzpm5",
      B06c7xf: ["f1fkeggc", "f1u45u6i"],
      B8uq84v: "f16eyofs",
      snkdo8: ["f1u45u6i", "f1fkeggc"],
      Bpf22ct: "f1wkmkig",
      apjfyd: "f18alut9"
    }
  }, {
    d: [".fkufhic{--fui-CardHeader--gap:12px;}", ".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".fql5097{margin-right:var(--fui-CardHeader--gap);}", ".f6yss9k{margin-left:var(--fui-CardHeader--gap);}", ".f22iagw{display:flex;}"],
    m: [["@media (forced-colors: active){.f1ndzpm5 .fui-Button,.f1ndzpm5 .fui-Link{border-top-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1fkeggc .fui-Button,.f1fkeggc .fui-Link{border-right-color:currentColor;}.f1u45u6i .fui-Button,.f1u45u6i .fui-Link{border-left-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f16eyofs .fui-Button,.f16eyofs .fui-Link{border-bottom-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1wkmkig .fui-Button,.f1wkmkig .fui-Link{color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f18alut9 .fui-Button,.f18alut9 .fui-Link{outline-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useStylesGrid = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f13qh94s",
      t4k1zu: "f8a668j"
    },
    image: {
      Br312pm: "fwpfdsa",
      Ijaq50: "fldnz9j"
    },
    header: {
      Br312pm: "fd46tj4",
      Ijaq50: "f16hsg94"
    },
    description: {
      Br312pm: "fd46tj4",
      Ijaq50: "faunodf"
    },
    action: {
      Br312pm: "fis13di",
      Ijaq50: "fldnz9j"
    }
  }, {
    d: [".f13qh94s{display:grid;}", ".f8a668j{grid-auto-columns:min-content 1fr min-content;}", ".fwpfdsa{grid-column-start:1;}", ".fldnz9j{grid-row-start:span 2;}", ".fd46tj4{grid-column-start:2;}", ".f16hsg94{grid-row-start:1;}", ".faunodf{grid-row-start:2;}", ".fis13di{grid-column-start:3;}"]
  });
  var useStylesFlex = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f22iagw"
    },
    header: {
      Bh6795r: "fqerorx"
    },
    image: {},
    description: {},
    action: {}
  }, {
    d: [".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}"]
  });
  var useCardHeaderStyles_unstable = (state) => {
    "use no memo";
    const styles2 = useStyles10();
    const stylesGrid = useStylesGrid();
    const stylesFlex = useStylesFlex();
    const boxModelStyles = state.description ? stylesGrid : stylesFlex;
    const getSlotStyles = (slotName) => {
      var _state_slotName;
      return mergeClasses(cardHeaderClassNames[slotName], styles2[slotName], boxModelStyles[slotName], (_state_slotName = state[slotName]) === null || _state_slotName === void 0 ? void 0 : _state_slotName.className);
    };
    state.root.className = getSlotStyles("root");
    if (state.image) {
      state.image.className = getSlotStyles("image");
    }
    if (state.header) {
      state.header.className = getSlotStyles("header");
    }
    if (state.description) {
      state.description.className = getSlotStyles("description");
    }
    if (state.action) {
      state.action.className = getSlotStyles("action");
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooterStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var cardFooterClassNames = {
    root: "fui-CardFooter",
    action: "fui-CardFooter__action"
  };
  var useStyles11 = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f22iagw",
      Beiy3e4: "f1063pyq",
      i8kkvl: 0,
      Belr9w4: 0,
      rmohyg: "fsbu5mz"
    },
    action: {
      Frg6f3: ["fcgxt0o", "f1ujusj6"],
      B7frvx2: "f1ndzpm5",
      B06c7xf: ["f1fkeggc", "f1u45u6i"],
      B8uq84v: "f16eyofs",
      snkdo8: ["f1u45u6i", "f1fkeggc"],
      Bpf22ct: "f1wkmkig",
      apjfyd: "f18alut9"
    }
  }, {
    d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", [".fsbu5mz{gap:12px;}", {
      p: -1
    }], ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}"],
    m: [["@media (forced-colors: active){.f1ndzpm5 .fui-Button,.f1ndzpm5 .fui-Link{border-top-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1fkeggc .fui-Button,.f1fkeggc .fui-Link{border-right-color:currentColor;}.f1u45u6i .fui-Button,.f1u45u6i .fui-Link{border-left-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f16eyofs .fui-Button,.f16eyofs .fui-Link{border-bottom-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1wkmkig .fui-Button,.f1wkmkig .fui-Link{color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f18alut9 .fui-Button,.f18alut9 .fui-Link{outline-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useCardFooterStyles_unstable = (state) => {
    "use no memo";
    const styles2 = useStyles11();
    state.root.className = mergeClasses(cardFooterClassNames.root, styles2.root, state.root.className);
    if (state.action) {
      state.action.className = mergeClasses(cardFooterClassNames.action, styles2.action, state.action.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCardStyles.styles.js
  var cardClassNames = {
    root: "fui-Card",
    floatingAction: "fui-Card__floatingAction",
    checkbox: "fui-Card__checkbox"
  };
  var cardCSSVars = {
    cardSizeVar: "--fui-Card--size",
    cardBorderRadiusVar: "--fui-Card--border-radius"
  };
  var focusOutlineStyle = {
    outlineRadius: `var(${cardCSSVars.cardBorderRadiusVar})`,
    outlineWidth: tokens.strokeWidthThick,
    outlineOffset: "-2px"
  };
  var useCardResetStyles = /* @__PURE__ */ __resetStyles2("rfxo2k2", "rgle7w9", [".rfxo2k2{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}", '.rfxo2k2::after{position:absolute;top:0;left:0;right:0;bottom:0;content:"";pointer-events:none;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}', ".rfxo2k2>.fui-CardHeader,.rfxo2k2>.fui-CardFooter{flex-shrink:0;}", ".rgle7w9{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}", '.rgle7w9::after{position:absolute;top:0;right:0;left:0;bottom:0;content:"";pointer-events:none;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}', ".rgle7w9>.fui-CardHeader,.rgle7w9>.fui-CardFooter{flex-shrink:0;}"]);
  var useCardStyles = /* @__PURE__ */ __styles2({
    focused: {
      Brovlpu: "ftqa4ok",
      B486eqv: "f2hkw1w",
      B8q5s1w: "f8hki3x",
      Bci5o5g: ["f1d2448m", "ffh67wi"],
      n8qw10: "f1bjia2o",
      Bdrgwmp: ["ffh67wi", "f1d2448m"],
      Bb7d1vk: "f226i61",
      zhwhgb: ["f13kzufm", "fsx75g8"],
      dhy2o1: "flujwa2",
      Gfyso: ["fsx75g8", "f13kzufm"],
      Bm4h7ae: "f15bsgw9",
      B7ys5i9: "f14e48fq",
      Busjfv9: "f18yb2kv",
      Bhk32uz: "fd6o370",
      f6g5ot: 0,
      Boxcth7: 0,
      Bhdgwq3: 0,
      hgwjuy: 0,
      Bshpdp8: 0,
      Bsom6fd: 0,
      Blkhhs4: 0,
      Bonggc9: 0,
      Ddfuxk: 0,
      i03rao: 0,
      kclons: 0,
      clg4pj: 0,
      Bpqj9nj: 0,
      B6dhp37: 0,
      Bf4ptjt: 0,
      Bqtpl0w: 0,
      i4rwgc: "fpqizxz",
      Dah5zi: 0,
      B1tsrr9: 0,
      qqdqy8: 0,
      Bkh64rk: 0,
      e3fwne: "fnd8nzh",
      J0r882: "f15fr7a0",
      Bule8hv: ["fwsq40z", "fy0y4wt"],
      Bjwuhne: "f34ld9f",
      Ghsupd: ["fy0y4wt", "fwsq40z"]
    },
    selectableFocused: {
      Brovlpu: "ftqa4ok",
      B486eqv: "f2hkw1w",
      Bssx7fj: "f1b1k54r",
      uh7if5: ["f4ne723", "fqqcjud"],
      clntm0: "fh7aioi",
      Dlk2r6: ["fqqcjud", "f4ne723"],
      Bm3wd5j: "f1k55ka9",
      Bbrhkcr: ["fgclinu", "f16pcs8n"],
      f1oku: "fycbxed",
      aywvf2: ["f16pcs8n", "fgclinu"],
      B2j2mmj: "ffht0p2",
      wigs8: "f1p0ul1q",
      pbfy6t: "f1c901ms",
      B0v4ure: "f1alokd7",
      Byrf0fs: 0,
      Bsiemmq: 0,
      Bwckmig: 0,
      skfxo0: 0,
      Iidy0u: 0,
      B98u21t: 0,
      Bvwlmkc: 0,
      jo1ztg: 0,
      Ba1iezr: 0,
      Blmvk6g: 0,
      B24cy0v: 0,
      Bil7v7r: 0,
      Br3gin4: 0,
      nr063g: 0,
      ghq09: 0,
      Bbgo44z: 0,
      Bseh09z: "f1i978nd",
      az1dzo: 0,
      Ba3ybja: 0,
      B6352mv: 0,
      vppk2z: 0,
      Biaj6j7: "f1nh8hsq",
      B2pnrqr: "f1amxum7",
      B29w5g4: ["f1cec8w7", "f554mv0"],
      Bhhzhcn: "f1sj6kbr",
      Bec0n69: ["f554mv0", "f1cec8w7"]
    },
    orientationHorizontal: {
      Beiy3e4: "f1063pyq",
      Bt984gj: "f122n59",
      Binpb3b: "ftrw7vg",
      qrt8p2: "f18opajm",
      k6ws3r: ["f13002it", "fqo182t"],
      Btcwela: ["f18yna97", "f1kd6wh7"],
      Fer9m8: "f4i4759"
    },
    orientationVertical: {
      Beiy3e4: "f1vx9l62",
      B5nvv7i: ["f14k419y", "f1fgo9fz"],
      Baxg94k: ["f1fgo9fz", "f14k419y"],
      tn21ii: "fvqmfsm",
      B0ud6bj: "f3am6yf",
      Bgdo4j: "f1r5wgso"
    },
    sizeSmall: {
      B7balbw: "f1pi9uxy",
      B1h88n7: "f1h1zgly"
    },
    sizeMedium: {
      B7balbw: "frsmuga",
      B1h88n7: "fuldkky"
    },
    sizeLarge: {
      B7balbw: "f1qua4xo",
      B1h88n7: "fimkt6v"
    },
    interactive: {
      rhjd8f: "f1epqm3e"
    },
    filled: {
      De3pzq: "fxugw4r",
      E5pizo: "f1whvlc6",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"]
    },
    filledInteractive: {
      Bceei9c: "f1k6fduh",
      De3pzq: "fxugw4r",
      E5pizo: "f1whvlc6",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"],
      Bi91k9c: "feu1g3u",
      Jwef8y: "f1knas48",
      Bvxd0ez: "f1m145df",
      ecr2s2: "fb40n2d"
    },
    filledInteractiveSelected: {
      De3pzq: "f1nfm20t",
      B0n5ga8: "f16eln5f",
      s924m2: ["fa2okxs", "fg4zq3l"],
      B1q35kw: "ff6932p",
      Gp14am: ["fg4zq3l", "fa2okxs"],
      Bi91k9c: "fx9teim",
      Jwef8y: "f1kz6goq"
    },
    filledAlternative: {
      De3pzq: "f1dmdbja",
      E5pizo: "f1whvlc6",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"]
    },
    filledAlternativeInteractive: {
      Bceei9c: "f1k6fduh",
      De3pzq: "f1dmdbja",
      E5pizo: "f1whvlc6",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"],
      Bi91k9c: "fnwyq0v",
      Jwef8y: "f1uvynv3",
      Bvxd0ez: "f1m145df",
      ecr2s2: "f1yhgkbh"
    },
    filledAlternativeInteractiveSelected: {
      De3pzq: "fjxa0vh",
      B0n5ga8: "f16eln5f",
      s924m2: ["fa2okxs", "fg4zq3l"],
      B1q35kw: "ff6932p",
      Gp14am: ["fg4zq3l", "fa2okxs"],
      Bi91k9c: "f1luvkty",
      Jwef8y: "fehi0vp"
    },
    outline: {
      De3pzq: "f1c21dwh",
      E5pizo: "f1couhl3",
      B0n5ga8: "ft83z1f",
      s924m2: ["f1g4150c", "f192dr6e"],
      B1q35kw: "f1qnawh6",
      Gp14am: ["f192dr6e", "f1g4150c"]
    },
    outlineInteractive: {
      Bceei9c: "f1k6fduh",
      De3pzq: "f1c21dwh",
      E5pizo: "f1couhl3",
      B0n5ga8: "ft83z1f",
      s924m2: ["f1g4150c", "f192dr6e"],
      B1q35kw: "f1qnawh6",
      Gp14am: ["f192dr6e", "f1g4150c"],
      Bi91k9c: "feu1g3u",
      Jwef8y: "fjxutwb",
      Be0v6ae: "f1llr77y",
      B5kxglz: ["fzk0khw", "fjj8tog"],
      B3pwyw6: "fb1u8ub",
      Bymgtzf: ["fjj8tog", "fzk0khw"],
      ecr2s2: "fophhak",
      dmfk: "f1uohb70",
      B4ofi8: ["f1jm7v1n", "f1bus3rq"],
      jgq6uv: "f1fbu7rr",
      Baxewws: ["f1bus3rq", "f1jm7v1n"]
    },
    outlineInteractiveSelected: {
      De3pzq: "f1q9pm1r",
      B0n5ga8: "f16eln5f",
      s924m2: ["fa2okxs", "fg4zq3l"],
      B1q35kw: "ff6932p",
      Gp14am: ["fg4zq3l", "fa2okxs"],
      Bi91k9c: "fx9teim",
      Jwef8y: "fg59vm4"
    },
    subtle: {
      De3pzq: "fhovq9v",
      E5pizo: "f1couhl3",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"]
    },
    subtleInteractive: {
      Bceei9c: "f1k6fduh",
      De3pzq: "fhovq9v",
      E5pizo: "f1couhl3",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"],
      Bi91k9c: "feu1g3u",
      Jwef8y: "f1t94bn6",
      ecr2s2: "f1wfn5kd"
    },
    subtleInteractiveSelected: {
      De3pzq: "fq5gl1p",
      B0n5ga8: "f16eln5f",
      s924m2: ["fa2okxs", "fg4zq3l"],
      B1q35kw: "ff6932p",
      Gp14am: ["fg4zq3l", "fa2okxs"],
      Bi91k9c: "fx9teim",
      Jwef8y: "f1uqaxdt"
    },
    highContrastSelected: {
      ycbfsm: "fkc42ay",
      Bsw6fvg: "f1rirnrt",
      Bbusuzp: "f1lkg8j3",
      xgfqdd: "f1nkj0oa",
      Bmmdzwq: "fey3rwa",
      zkpvhj: ["f5jhx11", "fff9uym"],
      B20bydw: "fm7n0jy",
      Bwwwggl: ["fff9uym", "f5jhx11"]
    },
    highContrastInteractive: {
      h1vhog: "fpfvv3l",
      kslmdy: "f1oamsm6",
      Baaf6ca: "f1il21bs",
      x9zz3d: "fnn5dk0",
      Bmmdzwq: "fey3rwa",
      zkpvhj: ["f5jhx11", "fff9uym"],
      B20bydw: "fm7n0jy",
      Bwwwggl: ["fff9uym", "f5jhx11"]
    },
    select: {
      qhf8xq: "f1euv43f",
      Bhzewxz: "fqclxi7",
      j35jbq: ["fiv86kb", "f36uhnt"],
      Bj3rh1h: "f19g0ac"
    },
    hiddenCheckbox: {
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1a3p1vp",
      a9b677: "frkrog8",
      Bqenvij: "f1mpe4l3",
      qhf8xq: "f1euv43f",
      Bh84pgu: "fmf1zke",
      Bgl5zvf: "f1wch0ki",
      Huce71: "fz5stix"
    }
  }, {
    f: [".ftqa4ok:focus{outline-style:none;}"],
    i: [".f2hkw1w:focus-visible{outline-style:none;}"],
    d: [".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", '.f15bsgw9[data-fui-focus-visible]::after{content:"";}', ".f14e48fq[data-fui-focus-visible]::after{position:absolute;}", ".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}", ".fd6o370[data-fui-focus-visible]::after{z-index:1;}", [".fpqizxz[data-fui-focus-visible]::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
      p: -2
    }], [".fnd8nzh[data-fui-focus-visible]::after{border-radius:var(--fui-Card--border-radius);}", {
      p: -1
    }], ".f15fr7a0[data-fui-focus-visible]::after{top:calc(0px - var(--strokeWidthThick) - -2px);}", ".fwsq40z[data-fui-focus-visible]::after{right:calc(0px - var(--strokeWidthThick) - -2px);}", ".fy0y4wt[data-fui-focus-visible]::after{left:calc(0px - var(--strokeWidthThick) - -2px);}", ".f34ld9f[data-fui-focus-visible]::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".f1i978nd[data-fui-focus-within]:focus-within::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
      p: -2
    }], [".f1nh8hsq[data-fui-focus-within]:focus-within::after{border-radius:var(--fui-Card--border-radius);}", {
      p: -1
    }], ".f1amxum7[data-fui-focus-within]:focus-within::after{top:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1cec8w7[data-fui-focus-within]:focus-within::after{right:calc(0px - var(--strokeWidthThick) - -2px);}", ".f554mv0[data-fui-focus-within]:focus-within::after{left:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1sj6kbr[data-fui-focus-within]:focus-within::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1063pyq{flex-direction:row;}", ".f122n59{align-items:center;}", ".ftrw7vg>.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}", ".f18opajm>.fui-CardPreview{margin-bottom:calc(var(--fui-Card--size) * -1);}", '.f13002it>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-left:calc(var(--fui-Card--size) * -1);}', '.fqo182t>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-right:calc(var(--fui-Card--size) * -1);}', '.f18yna97>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-right:calc(var(--fui-Card--size) * -1);}', '.f1kd6wh7>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-left:calc(var(--fui-Card--size) * -1);}', ".f4i4759>.fui-CardHeader:last-of-type,.f4i4759>.fui-CardFooter:last-of-type{flex-grow:1;}", ".f1vx9l62{flex-direction:column;}", ".f14k419y>.fui-CardPreview{margin-left:calc(var(--fui-Card--size) * -1);}", ".f1fgo9fz>.fui-CardPreview{margin-right:calc(var(--fui-Card--size) * -1);}", '.fvqmfsm>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-top:calc(var(--fui-Card--size) * -1);}', ".f3am6yf>.fui-Card__floatingAction+.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}", '.f1r5wgso>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-bottom:calc(var(--fui-Card--size) * -1);}', ".f1pi9uxy{--fui-Card--size:8px;}", ".f1h1zgly{--fui-Card--border-radius:var(--borderRadiusSmall);}", ".frsmuga{--fui-Card--size:12px;}", ".fuldkky{--fui-Card--border-radius:var(--borderRadiusMedium);}", ".f1qua4xo{--fui-Card--size:16px;}", ".fimkt6v{--fui-Card--border-radius:var(--borderRadiusLarge);}", ".f1epqm3e .fui-Text{color:currentColor;}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1whvlc6{box-shadow:var(--shadow4);}", ".f16gxe2i::after{border-top-color:var(--colorTransparentStroke);}", ".fpgykix::after{border-right-color:var(--colorTransparentStroke);}", ".fzybk4o::after{border-left-color:var(--colorTransparentStroke);}", ".f1osi826::after{border-bottom-color:var(--colorTransparentStroke);}", ".f1k6fduh{cursor:pointer;}", ".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".f16eln5f::after{border-top-color:var(--colorNeutralStroke1Selected);}", ".fa2okxs::after{border-right-color:var(--colorNeutralStroke1Selected);}", ".fg4zq3l::after{border-left-color:var(--colorNeutralStroke1Selected);}", ".ff6932p::after{border-bottom-color:var(--colorNeutralStroke1Selected);}", ".f1dmdbja{background-color:var(--colorNeutralBackground2);}", ".fjxa0vh{background-color:var(--colorNeutralBackground2Selected);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1couhl3{box-shadow:none;}", ".ft83z1f::after{border-top-color:var(--colorNeutralStroke1);}", ".f1g4150c::after{border-right-color:var(--colorNeutralStroke1);}", ".f192dr6e::after{border-left-color:var(--colorNeutralStroke1);}", ".f1qnawh6::after{border-bottom-color:var(--colorNeutralStroke1);}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1euv43f{position:absolute;}", ".fqclxi7{top:4px;}", ".fiv86kb{right:4px;}", ".f36uhnt{left:4px;}", ".f19g0ac{z-index:1;}", [".f1a3p1vp{overflow:hidden;}", {
      p: -1
    }], ".frkrog8{width:1px;}", ".f1mpe4l3{height:1px;}", ".fmf1zke{clip:rect(0 0 0 0);}", ".f1wch0ki{clip-path:inset(50%);}", ".fz5stix{white-space:nowrap;}"],
    m: [["@media (forced-colors: active){.f226i61[data-fui-focus-visible]::after{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f13kzufm[data-fui-focus-visible]::after{border-right-color:Highlight;}.fsx75g8[data-fui-focus-visible]::after{border-left-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.flujwa2[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1k55ka9[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f16pcs8n[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}.fgclinu[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fycbxed[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1nkj0oa .fui-CardPreview,.f1nkj0oa .fui-CardFooter{forced-color-adjust:auto;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fey3rwa::after{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f5jhx11::after{border-right-color:Highlight;}.fff9uym::after{border-left-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fm7n0jy::after{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fpfvv3l:hover,.fpfvv3l :active{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1oamsm6:hover,.f1oamsm6 :active{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1il21bs:hover,.f1il21bs :active{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fnn5dk0:hover .fui-CardPreview,.fnn5dk0 :active .fui-CardPreview,.fnn5dk0:hover .fui-CardFooter,.fnn5dk0 :active .fui-CardFooter{forced-color-adjust:auto;}}", {
      m: "(forced-colors: active)"
    }]],
    h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".f1m145df:hover{box-shadow:var(--shadow8);}", ".fx9teim:hover{color:var(--colorNeutralForeground1Selected);}", ".f1kz6goq:hover{background-color:var(--colorNeutralBackground1Selected);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".f1uvynv3:hover{background-color:var(--colorNeutralBackground2Hover);}", ".f1luvkty:hover{color:var(--colorNeutralForeground2Selected);}", ".fehi0vp:hover{background-color:var(--colorNeutralBackground2Selected);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f1llr77y:hover::after{border-top-color:var(--colorNeutralStroke1Hover);}", ".fzk0khw:hover::after{border-right-color:var(--colorNeutralStroke1Hover);}", ".fjj8tog:hover::after{border-left-color:var(--colorNeutralStroke1Hover);}", ".fb1u8ub:hover::after{border-bottom-color:var(--colorNeutralStroke1Hover);}", ".fg59vm4:hover{background-color:var(--colorTransparentBackgroundSelected);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".f1uqaxdt:hover{background-color:var(--colorSubtleBackgroundSelected);}"],
    a: [".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".f1yhgkbh:active{background-color:var(--colorNeutralBackground2Pressed);}", ".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f1uohb70:active::after{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1jm7v1n:active::after{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1bus3rq:active::after{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1fbu7rr:active::after{border-bottom-color:var(--colorNeutralStroke1Pressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}"]
  });
  var useCardStyles_unstable = (state) => {
    "use no memo";
    const resetStyles = useCardResetStyles();
    const styles2 = useCardStyles();
    const orientationMap = {
      horizontal: styles2.orientationHorizontal,
      vertical: styles2.orientationVertical
    };
    const sizeMap = {
      small: styles2.sizeSmall,
      medium: styles2.sizeMedium,
      large: styles2.sizeLarge
    };
    const appearanceMap = {
      filled: styles2.filled,
      "filled-alternative": styles2.filledAlternative,
      outline: styles2.outline,
      subtle: styles2.subtle
    };
    const selectedMap = {
      filled: styles2.filledInteractiveSelected,
      "filled-alternative": styles2.filledAlternativeInteractiveSelected,
      outline: styles2.outlineInteractiveSelected,
      subtle: styles2.subtleInteractiveSelected
    };
    const interactiveMap = {
      filled: styles2.filledInteractive,
      "filled-alternative": styles2.filledAlternativeInteractive,
      outline: styles2.outlineInteractive,
      subtle: styles2.subtleInteractive
    };
    const isSelectableOrInteractive = state.interactive || state.selectable;
    const focusedClassName = React128.useMemo(() => {
      if (state.selectable) {
        if (state.selectFocused) {
          return styles2.selectableFocused;
        }
        return "";
      }
      return styles2.focused;
    }, [state.selectFocused, state.selectable, styles2.focused, styles2.selectableFocused]);
    state.root.className = mergeClasses(cardClassNames.root, resetStyles, orientationMap[state.orientation], sizeMap[state.size], appearanceMap[state.appearance], isSelectableOrInteractive && styles2.interactive, isSelectableOrInteractive && interactiveMap[state.appearance], state.selected && selectedMap[state.appearance], focusedClassName, isSelectableOrInteractive && styles2.highContrastInteractive, state.selected && styles2.highContrastSelected, state.root.className);
    if (state.floatingAction) {
      state.floatingAction.className = mergeClasses(cardClassNames.floatingAction, styles2.select, state.floatingAction.className);
    }
    if (state.checkbox) {
      state.checkbox.className = mergeClasses(cardClassNames.checkbox, styles2.hiddenCheckbox, state.checkbox.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCardContextValue.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  function useCardContextValue({ selectableA11yProps }) {
    return {
      selectableA11yProps
    };
  }

  // ../../node_modules/@fluentui/react-card/lib/components/Card/Card.js
  var Card = /* @__PURE__ */ React129.forwardRef((props, ref) => {
    const state = useCard_unstable(props, ref);
    const cardContextValue = useCardContextValue(state);
    useCardStyles_unstable(state);
    useCustomStyleHook("useCardStyles_unstable")(state);
    return renderCard_unstable(state, cardContextValue);
  });
  Card.displayName = "Card";

  // ../../node_modules/@fluentui/react-card/lib/CardFooter.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/CardFooter.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React131 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooter.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React130 = __toESM(require_react());
  var useCardFooter_unstable = (props, ref) => {
    const { action } = props;
    return {
      components: {
        root: "div",
        action: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      }),
      action: slot_exports.optional(action, {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/renderCardFooter.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderCardFooter_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.root.children,
        state.action && /* @__PURE__ */ jsx(state.action, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/CardFooter.js
  var CardFooter = /* @__PURE__ */ React131.forwardRef((props, ref) => {
    const state = useCardFooter_unstable(props, ref);
    useCardFooterStyles_unstable(state);
    useCustomStyleHook("useCardFooterStyles_unstable")(state);
    return renderCardFooter_unstable(state);
  });
  CardFooter.displayName = "CardFooter";

  // ../../node_modules/@fluentui/react-card/lib/CardHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/CardHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React133 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React132 = __toESM(require_react());
  function getChildWithId(header) {
    function isReactElementWithIdProp(element) {
      return React132.isValidElement(element) && Boolean(element.props.id);
    }
    return React132.Children.toArray(header).find(isReactElementWithIdProp);
  }
  function getReferenceId(headerId, childWithId, generatedId) {
    if (headerId) {
      return headerId;
    }
    if (childWithId === null || childWithId === void 0 ? void 0 : childWithId.props.id) {
      return childWithId.props.id;
    }
    return generatedId;
  }
  var useCardHeader_unstable = (props, ref) => {
    const { image, header, description, action } = props;
    const { selectableA11yProps: { referenceId, setReferenceId } } = useCardContext_unstable();
    const headerRef = React132.useRef(null);
    const hasChildId = React132.useRef(false);
    const generatedId = useId4(cardHeaderClassNames.header, referenceId);
    const headerSlot = slot_exports.optional(header, {
      renderByDefault: true,
      defaultProps: {
        ref: headerRef,
        id: !hasChildId.current ? referenceId : void 0
      },
      elementType: "div"
    });
    React132.useEffect(() => {
      var _headerRef_current;
      const headerId = !hasChildId.current ? (_headerRef_current = headerRef.current) === null || _headerRef_current === void 0 ? void 0 : _headerRef_current.id : void 0;
      const childWithId = getChildWithId(headerSlot === null || headerSlot === void 0 ? void 0 : headerSlot.children);
      hasChildId.current = Boolean(childWithId);
      setReferenceId(getReferenceId(headerId, childWithId, generatedId));
    }, [
      generatedId,
      header,
      headerSlot,
      setReferenceId
    ]);
    return {
      components: {
        root: "div",
        image: "div",
        header: "div",
        description: "div",
        action: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      }),
      image: slot_exports.optional(image, {
        elementType: "div"
      }),
      header: headerSlot,
      description: slot_exports.optional(description, {
        elementType: "div"
      }),
      action: slot_exports.optional(action, {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/renderCardHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderCardHeader_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.image && /* @__PURE__ */ jsx(state.image, {}),
        state.header && /* @__PURE__ */ jsx(state.header, {}),
        state.description && /* @__PURE__ */ jsx(state.description, {}),
        state.action && /* @__PURE__ */ jsx(state.action, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/CardHeader.js
  var CardHeader = /* @__PURE__ */ React133.forwardRef((props, ref) => {
    const state = useCardHeader_unstable(props, ref);
    useCardHeaderStyles_unstable(state);
    useCustomStyleHook("useCardHeaderStyles_unstable")(state);
    return renderCardHeader_unstable(state);
  });
  CardHeader.displayName = "CardHeader";

  // ../../node_modules/@fluentui/react-card/lib/CardPreview.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/CardPreview.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React135 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreview.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React134 = __toESM(require_react());
  var useCardPreview_unstable = (props, ref) => {
    const { logo } = props;
    const { selectableA11yProps: { referenceLabel, referenceId, setReferenceLabel, setReferenceId } } = useCardContext_unstable();
    const previewRef = useMergedRefs(ref, React134.useRef(null));
    React134.useEffect(() => {
      if (referenceLabel && referenceId) {
        return;
      }
      if (previewRef.current && previewRef.current.parentNode) {
        const img = previewRef.current.parentNode.querySelector(`.${cardPreviewClassNames.root} > img`);
        if (img) {
          const ariaLabel = img.getAttribute("aria-label");
          const ariaDescribedby = img.getAttribute("aria-describedby");
          if (ariaDescribedby) {
            setReferenceId(ariaDescribedby);
          } else if (img.alt) {
            setReferenceLabel(img.alt);
          } else if (ariaLabel) {
            setReferenceLabel(ariaLabel);
          }
        }
      }
    }, [
      setReferenceLabel,
      referenceLabel,
      previewRef,
      referenceId,
      setReferenceId
    ]);
    return {
      components: {
        root: "div",
        logo: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        ref: previewRef,
        ...props
      }), {
        elementType: "div"
      }),
      logo: slot_exports.optional(logo, {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/renderCardPreview.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderCardPreview_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.root.children,
        state.logo && /* @__PURE__ */ jsx(state.logo, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/CardPreview.js
  var CardPreview = /* @__PURE__ */ React135.forwardRef((props, ref) => {
    const state = useCardPreview_unstable(props, ref);
    useCardPreviewStyles_unstable(state);
    useCustomStyleHook("useCardPreviewStyles_unstable")(state);
    return renderCardPreview_unstable(state);
  });
  CardPreview.displayName = "CardPreview";

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Button.js
  var Button2 = ({ variant = "primary", size = "medium", ...rest }) => (0, import_jsx_runtime40.jsx)(Button, { appearance: variant === "primary" ? "primary" : variant === "secondary" ? "secondary" : variant === "outline" ? "outline" : "transparent", size: size === "sm" || size === "small" ? "small" : size === "lg" || size === "large" ? "large" : "medium", ...rest });

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Input.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime41 = __toESM(require_jsx_runtime());
  var Input2 = (props) => {
    const { size, ...rest } = props;
    const sizeProp = typeof size === "string" ? size === "sm" || size === "small" ? "small" : size === "lg" || size === "large" ? "large" : "medium" : "medium";
    return (0, import_jsx_runtime41.jsx)(Input, { size: sizeProp, ...rest });
  };

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Card.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime42 = __toESM(require_jsx_runtime());
  var Card2 = ({ title, text, actions }) => (0, import_jsx_runtime42.jsxs)(Card, { children: [(0, import_jsx_runtime42.jsx)(CardHeader, { header: (0, import_jsx_runtime42.jsx)("span", { children: title }) }), (0, import_jsx_runtime42.jsx)(CardPreview, { children: text }), actions && (0, import_jsx_runtime42.jsx)(CardFooter, { children: actions })] });

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Alert.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime44 = __toESM(require_jsx_runtime());

  // ../../node_modules/@fluentui/react-alert/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/Alert.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React137 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/renderAlert.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var renderAlert_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs(state.root, {
      children: [
        state.icon && /* @__PURE__ */ jsx(state.icon, {}),
        state.avatar && /* @__PURE__ */ jsx(state.avatar, {}),
        state.root.children,
        state.action && /* @__PURE__ */ jsx(state.action, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/useAlert.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var React136 = __toESM(require_react());
  var useAlert_unstable = (props, ref) => {
    const { appearance = "primary", intent } = props;
    let defaultIcon;
    let defaultRole = "status";
    switch (intent) {
      case "success":
        defaultIcon = /* @__PURE__ */ React136.createElement(CheckmarkCircleFilled, null);
        break;
      case "error":
        defaultIcon = /* @__PURE__ */ React136.createElement(DismissCircleFilled, null);
        defaultRole = "alert";
        break;
      case "warning":
        defaultIcon = /* @__PURE__ */ React136.createElement(WarningFilled, null);
        defaultRole = "alert";
        break;
      case "info":
        defaultIcon = /* @__PURE__ */ React136.createElement(InfoFilled, null);
        break;
    }
    const action = slot_exports.optional(props.action, {
      defaultProps: {
        appearance: "transparent"
      },
      elementType: Button
    });
    const avatar = slot_exports.optional(props.avatar, {
      elementType: Avatar
    });
    let icon;
    if (!avatar) {
      icon = slot_exports.optional(props.icon, {
        defaultProps: {
          children: defaultIcon
        },
        renderByDefault: !!props.intent,
        elementType: "span"
      });
    }
    return {
      action,
      appearance,
      avatar,
      components: {
        root: "div",
        icon: "span",
        action: Button,
        avatar: Avatar
      },
      icon,
      intent,
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        role: defaultRole,
        children: props.children,
        ...props
      }), {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/useAlertStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var alertClassNames = {
    root: "fui-Alert",
    icon: "fui-Alert__icon",
    action: "fui-Alert__action",
    avatar: "fui-Alert__avatar"
  };
  var useStyles12 = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f22iagw",
      Bt984gj: "f122n59",
      sshi5w: "f5pgtk9",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1oic3e7",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ff3glw6",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f9ggezi",
      E5pizo: "fz58gqq",
      Be2twd7: "fkhj508",
      Bhrd7zp: "fl43uef",
      sj55zd: "f19n0e5",
      De3pzq: "fxugw4r"
    },
    inverted: {
      sj55zd: "f1w7i9ko",
      De3pzq: "f5pduvr"
    },
    icon: {
      Bqenvij: "fd461yt",
      Be2twd7: "f4ybsrx",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: ["fhivll6", "f1cgepy8"]
    },
    avatar: {
      jrapky: 0,
      Frg6f3: 0,
      t21cq0: 0,
      B6of3ja: 0,
      B74szlk: ["fxal17o", "ftghr3s"]
    },
    action: {
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f4jnnbt",
      Bf4jedk: "fy77jfu",
      Frg6f3: ["fcgxt0o", "f1ujusj6"],
      sj55zd: "f16muhyy"
    }
  }, {
    d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".f5pgtk9{min-height:44px;}", [".f1oic3e7{padding:0 12px;}", {
      p: -1
    }], [".ff3glw6{border-radius:4px;}", {
      p: -1
    }], [".f9ggezi{border:1px solid var(--colorTransparentStroke);}", {
      p: -2
    }], ".fz58gqq{box-shadow:var(--shadow8);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}", ".f5pduvr{background-color:var(--colorNeutralBackgroundInverted);}", ".fd461yt{height:16px;}", ".f4ybsrx{font-size:16px;}", [".fhivll6{padding:0 8px 0 0;}", {
      p: -1
    }], [".f1cgepy8{padding:0 0 0 8px;}", {
      p: -1
    }], [".fxal17o{margin:0 8px 0 0;}", {
      p: -1
    }], [".ftghr3s{margin:0 0 0 8px;}", {
      p: -1
    }], [".f4jnnbt{padding:5px 10px;}", {
      p: -1
    }], ".fy77jfu{min-width:0;}", ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}", ".f16muhyy{color:var(--colorBrandForeground1);}"]
  });
  var useIntentIconStyles = /* @__PURE__ */ __styles2({
    success: {
      sj55zd: "f1m7fhi8"
    },
    error: {
      sj55zd: "f1whyuy6"
    },
    warning: {
      sj55zd: "fpti2h4"
    },
    info: {
      sj55zd: "fkfq4zb"
    }
  }, {
    d: [".f1m7fhi8{color:var(--colorPaletteGreenForeground3);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".fpti2h4{color:var(--colorPaletteYellowForeground2);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}"]
  });
  var useIntentIconStylesInverted = /* @__PURE__ */ __styles2({
    success: {
      sj55zd: "f1pvjcpr"
    },
    error: {
      sj55zd: "fcrp5ll"
    },
    warning: {
      sj55zd: "f1r8f1cl"
    },
    info: {
      sj55zd: "f1w7i9ko"
    }
  }, {
    d: [".f1pvjcpr{color:var(--colorPaletteGreenForegroundInverted);}", ".fcrp5ll{color:var(--colorPaletteRedForegroundInverted);}", ".f1r8f1cl{color:var(--colorPaletteYellowForegroundInverted);}", ".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}"]
  });
  var useActionButtonColorInverted = /* @__PURE__ */ __styles2({
    action: {
      sj55zd: "f1qz2gb0",
      B8q5s1w: "fa5e339",
      Bci5o5g: ["fk4svks", "fqzoz0o"],
      n8qw10: "fw8q0i0",
      Bdrgwmp: ["fqzoz0o", "fk4svks"],
      Bfpq7zp: "f1dlk4fq"
    }
  }, {
    d: [".f1qz2gb0{color:var(--colorBrandForegroundInverted);}", ".fa5e339[data-fui-focus-visible]{border-top-color:var(--colorTransparentStrokeInteractive);}", ".fk4svks[data-fui-focus-visible]{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fqzoz0o[data-fui-focus-visible]{border-left-color:var(--colorTransparentStrokeInteractive);}", ".fw8q0i0[data-fui-focus-visible]{border-bottom-color:var(--colorTransparentStrokeInteractive);}", ".f1dlk4fq[data-fui-focus-visible]{outline-color:var(--colorNeutralBackground5Pressed);}"]
  });
  var useAlertStyles_unstable = (state) => {
    const inverted = state.appearance === "inverted";
    const styles2 = useStyles12();
    const intentIconStylesPrimary = useIntentIconStyles();
    const intentIconStylesInverted = useIntentIconStylesInverted();
    const actionStylesInverted = useActionButtonColorInverted();
    state.root.className = mergeClasses(alertClassNames.root, styles2.root, inverted && styles2.inverted, state.root.className);
    if (state.icon) {
      state.icon.className = mergeClasses(alertClassNames.icon, styles2.icon, state.intent && (inverted ? intentIconStylesInverted[state.intent] : intentIconStylesPrimary[state.intent]), state.icon.className);
    }
    if (state.avatar) {
      state.avatar.className = mergeClasses(alertClassNames.avatar, styles2.avatar, state.avatar.className);
    }
    if (state.action) {
      state.action.className = mergeClasses(alertClassNames.action, styles2.action, inverted && actionStylesInverted.action, state.action.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/Alert.js
  var Alert = /* @__PURE__ */ React137.forwardRef((props, ref) => {
    const state = useAlert_unstable(props, ref);
    useAlertStyles_unstable(state);
    return renderAlert_unstable(state);
  });
  Alert.displayName = "Alert";

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Alert.js
  var Alert2 = ({ variant, className, children }) => (0, import_jsx_runtime44.jsx)(Alert, { appearance: variant === "danger" || variant === "error" ? "primary" : variant === "warning" ? "inverted" : void 0, className, children });

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Spinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime45 = __toESM(require_jsx_runtime());
  var Spinner2 = ({ size = "tiny", className }) => (0, import_jsx_runtime45.jsx)(Spinner, { size: size === "sm" || size === "tiny" ? "tiny" : size === "xs" || size === "extra-small" ? "extra-small" : size === "md" || size === "medium" ? "medium" : size === "lg" || size === "large" ? "large" : "tiny", className });

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Modal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime46 = __toESM(require_jsx_runtime());
  var Modal = ({ show, onHide, size, title, centered, children }) => (0, import_jsx_runtime46.jsxs)(Dialog, { open: show, onOpenChange: (_, data2) => !data2.open && onHide(), children: [(0, import_jsx_runtime46.jsx)(DialogTrigger, { disableButtonEnhancement: true, children: (0, import_jsx_runtime46.jsx)("span", { style: { display: "none" } }) }), (0, import_jsx_runtime46.jsx)(DialogSurface, { style: centered ? {
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  } : void 0, children: (0, import_jsx_runtime46.jsxs)(DialogBody, { style: { width: "100%" }, children: [(0, import_jsx_runtime46.jsx)(DialogTitle, { children: title }), (0, import_jsx_runtime46.jsx)(DialogContent, { children })] }) })] });

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Tabs.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime47 = __toESM(require_jsx_runtime());
  var React138 = __toESM(require_react());
  var Tabs = ({ activeKey, onSelect, className, children }) => {
    const headers = [];
    let activePanel = null;
    React138.Children.forEach(children, (child) => {
      if (!React138.isValidElement(child))
        return;
      const tab = child;
      const { eventKey, title } = tab.props;
      headers.push((0, import_jsx_runtime47.jsx)(Tab2, { value: eventKey, children: title }, eventKey));
      if (eventKey === activeKey) {
        activePanel = (0, import_jsx_runtime47.jsx)("div", { style: { padding: "1em 0" }, children: tab.props.children });
      }
    });
    return (0, import_jsx_runtime47.jsxs)("div", { className, children: [(0, import_jsx_runtime47.jsx)(TabList, { selectedValue: activeKey, onTabSelect: (_, data2) => onSelect(data2.value), children: headers }), activePanel] });
  };

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Tab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var Tab3 = () => null;
  Tab3.displayName = "McpFluentTab";

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Badge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime48 = __toESM(require_jsx_runtime());
  var Badge2 = ({ bg, text, children }) => (0, import_jsx_runtime48.jsx)(Badge, { color: bg == "primary" ? "brand" : bg, children: text ?? children });

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Table.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime49 = __toESM(require_jsx_runtime());
  var Table2 = (props) => (0, import_jsx_runtime49.jsx)(Table, { ...props, children: props.children });

  // ../../packages/mcphappey-theme-fluent/dist/primitives/CloseButton.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime50 = __toESM(require_jsx_runtime());
  var CloseButton = ({ onClick, className, style, "aria-label": ariaLabel }) => (0, import_jsx_runtime50.jsx)(Button, { appearance: "subtle", shape: "circular", icon: (0, import_jsx_runtime50.jsx)(Dismiss24Regular, {}), "aria-label": ariaLabel || "Close", onClick, className, style });

  // ../../packages/mcphappey-theme-fluent/dist/primitives/Switch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime51 = __toESM(require_jsx_runtime());
  var Switch2 = ({ id, label, checked, onChange, className }) => (0, import_jsx_runtime51.jsx)(Switch, { id, checked, onChange: (_, data2) => onChange(data2.checked), className, label });

  // ../../packages/mcphappey-theme-fluent/dist/primitives/TextArea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var import_jsx_runtime52 = __toESM(require_jsx_runtime());
  var TextArea = ({ rows, value, onChange, style, className }) => (0, import_jsx_runtime52.jsx)(Textarea, { rows, value, onChange: (_, data2) => onChange(data2.value), style, className });

  // ../../packages/mcphappey-theme-fluent/dist/fluentTheme.js
  var fluentTheme = {
    Button: Button2,
    Input: Input2,
    Card: Card2,
    Alert: Alert2,
    Spinner: Spinner2,
    Modal,
    Tabs,
    Tab: Tab3,
    Badge: Badge2,
    Table: Table2,
    CloseButton,
    Switch: Switch2,
    TextArea
  };

  // ../../packages/mcphappey-theme-fluent/dist/ThemeProvider.js
  var ThemeProvider2 = ({ children }) => (0, import_jsx_runtime53.jsx)(ThemeContext.Provider, { value: fluentTheme, children: (0, import_jsx_runtime53.jsx)(FluentProvider, { theme: webLightTheme, children }) });

  // src/config.ts
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  var DEFAULT_MCP_SERVER_LIST_URLS = define_DEFAULT_MCP_SERVER_LIST_URLS_default || ["http://localhost:3001/mcp.json"];

  // src/App.tsx
  var import_jsx_runtime54 = __toESM(require_jsx_runtime());
  var App = () => /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(ThemeProvider2, { children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(dist_default, { initialLists: DEFAULT_MCP_SERVER_LIST_URLS }) });
  var App_default = App;

  // src/main.tsx
  var import_jsx_runtime55 = __toESM(require_jsx_runtime());
  var router = createBrowserRouter([
    {
      path: "/oauth-callback",
      element: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(OAuthCallbackPage_default, {})
    },
    {
      path: "/*",
      element: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(App_default, {})
    }
  ]);
  var container = document.getElementById("root");
  if (container) {
    const root = (0, import_client2.createRoot)(container);
    root.render(/* @__PURE__ */ (0, import_jsx_runtime55.jsx)(RouterProvider, { router }));
  }
})();
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.production.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

react-is/cjs/react-is.production.min.js:
  (** @license React v17.0.2
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-router/dist/development/chunk-QMGIS6GS.mjs:
react-router/dist/development/index.mjs:
  (**
   * react-router v7.6.3
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

keyborg/dist/esm/index.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)
*/
//# sourceMappingURL=bundle.js.map
